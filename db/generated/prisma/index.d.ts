
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Bookings
 * 
 */
export type Bookings = $Result.DefaultSelection<Prisma.$BookingsPayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model DriverVehicle
 * 
 */
export type DriverVehicle = $Result.DefaultSelection<Prisma.$DriverVehiclePayload>
/**
 * Model DriverWallet
 * 
 */
export type DriverWallet = $Result.DefaultSelection<Prisma.$DriverWalletPayload>
/**
 * Model FareNegotiation
 * 
 */
export type FareNegotiation = $Result.DefaultSelection<Prisma.$FareNegotiationPayload>
/**
 * Model Owner
 * 
 */
export type Owner = $Result.DefaultSelection<Prisma.$OwnerPayload>
/**
 * Model OwnerDriver
 * 
 */
export type OwnerDriver = $Result.DefaultSelection<Prisma.$OwnerDriverPayload>
/**
 * Model OwnerVehicle
 * 
 */
export type OwnerVehicle = $Result.DefaultSelection<Prisma.$OwnerVehiclePayload>
/**
 * Model OwnerWallet
 * 
 */
export type OwnerWallet = $Result.DefaultSelection<Prisma.$OwnerWalletPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserWallet
 * 
 */
export type UserWallet = $Result.DefaultSelection<Prisma.$UserWalletPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model otps
 * 
 */
export type otps = $Result.DefaultSelection<Prisma.$otpsPayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model permission_audit_logs
 * 
 */
export type permission_audit_logs = $Result.DefaultSelection<Prisma.$permission_audit_logsPayload>
/**
 * Model permission_categories
 * 
 */
export type permission_categories = $Result.DefaultSelection<Prisma.$permission_categoriesPayload>
/**
 * Model permissions
 * 
 */
export type permissions = $Result.DefaultSelection<Prisma.$permissionsPayload>
/**
 * Model role_permissions
 * 
 */
export type role_permissions = $Result.DefaultSelection<Prisma.$role_permissionsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model user_roles
 * 
 */
export type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BookingStatus: {
  Pending: 'Pending',
  Confirmed: 'Confirmed',
  Cancelled: 'Cancelled',
  Ongoing: 'Ongoing',
  Completed: 'Completed'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const PaymentMode: {
  CASH: 'CASH',
  ONLINE: 'ONLINE'
};

export type PaymentMode = (typeof PaymentMode)[keyof typeof PaymentMode]


export const UserType: {
  DRIVER: 'DRIVER',
  OWNER: 'OWNER',
  USER: 'USER'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const AuditActionType: {
  GRANT: 'GRANT',
  REVOKE: 'REVOKE',
  ROLE_CREATE: 'ROLE_CREATE',
  ROLE_UPDATE: 'ROLE_UPDATE',
  ROLE_DELETE: 'ROLE_DELETE'
};

export type AuditActionType = (typeof AuditActionType)[keyof typeof AuditActionType]

}

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type PaymentMode = $Enums.PaymentMode

export const PaymentMode: typeof $Enums.PaymentMode

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type AuditActionType = $Enums.AuditActionType

export const AuditActionType: typeof $Enums.AuditActionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bookings
 * const bookings = await prisma.bookings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bookings
   * const bookings = await prisma.bookings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.bookings`: Exposes CRUD operations for the **Bookings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.bookings.findMany()
    * ```
    */
  get bookings(): Prisma.BookingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driverVehicle`: Exposes CRUD operations for the **DriverVehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverVehicles
    * const driverVehicles = await prisma.driverVehicle.findMany()
    * ```
    */
  get driverVehicle(): Prisma.DriverVehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driverWallet`: Exposes CRUD operations for the **DriverWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverWallets
    * const driverWallets = await prisma.driverWallet.findMany()
    * ```
    */
  get driverWallet(): Prisma.DriverWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fareNegotiation`: Exposes CRUD operations for the **FareNegotiation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FareNegotiations
    * const fareNegotiations = await prisma.fareNegotiation.findMany()
    * ```
    */
  get fareNegotiation(): Prisma.FareNegotiationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): Prisma.OwnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ownerDriver`: Exposes CRUD operations for the **OwnerDriver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerDrivers
    * const ownerDrivers = await prisma.ownerDriver.findMany()
    * ```
    */
  get ownerDriver(): Prisma.OwnerDriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ownerVehicle`: Exposes CRUD operations for the **OwnerVehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerVehicles
    * const ownerVehicles = await prisma.ownerVehicle.findMany()
    * ```
    */
  get ownerVehicle(): Prisma.OwnerVehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ownerWallet`: Exposes CRUD operations for the **OwnerWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerWallets
    * const ownerWallets = await prisma.ownerWallet.findMany()
    * ```
    */
  get ownerWallet(): Prisma.OwnerWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userWallet`: Exposes CRUD operations for the **UserWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserWallets
    * const userWallets = await prisma.userWallet.findMany()
    * ```
    */
  get userWallet(): Prisma.UserWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otps`: Exposes CRUD operations for the **otps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otps.findMany()
    * ```
    */
  get otps(): Prisma.otpsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission_audit_logs`: Exposes CRUD operations for the **permission_audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permission_audit_logs
    * const permission_audit_logs = await prisma.permission_audit_logs.findMany()
    * ```
    */
  get permission_audit_logs(): Prisma.permission_audit_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission_categories`: Exposes CRUD operations for the **permission_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permission_categories
    * const permission_categories = await prisma.permission_categories.findMany()
    * ```
    */
  get permission_categories(): Prisma.permission_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role_permissions`: Exposes CRUD operations for the **role_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_permissions
    * const role_permissions = await prisma.role_permissions.findMany()
    * ```
    */
  get role_permissions(): Prisma.role_permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_roles.findMany()
    * ```
    */
  get user_roles(): Prisma.user_rolesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Bookings: 'Bookings',
    Driver: 'Driver',
    DriverVehicle: 'DriverVehicle',
    DriverWallet: 'DriverWallet',
    FareNegotiation: 'FareNegotiation',
    Owner: 'Owner',
    OwnerDriver: 'OwnerDriver',
    OwnerVehicle: 'OwnerVehicle',
    OwnerWallet: 'OwnerWallet',
    User: 'User',
    UserWallet: 'UserWallet',
    Vehicle: 'Vehicle',
    otps: 'otps',
    admin: 'admin',
    permission_audit_logs: 'permission_audit_logs',
    permission_categories: 'permission_categories',
    permissions: 'permissions',
    role_permissions: 'role_permissions',
    roles: 'roles',
    user_roles: 'user_roles'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "bookings" | "driver" | "driverVehicle" | "driverWallet" | "fareNegotiation" | "owner" | "ownerDriver" | "ownerVehicle" | "ownerWallet" | "user" | "userWallet" | "vehicle" | "otps" | "admin" | "permission_audit_logs" | "permission_categories" | "permissions" | "role_permissions" | "roles" | "user_roles"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Bookings: {
        payload: Prisma.$BookingsPayload<ExtArgs>
        fields: Prisma.BookingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          findFirst: {
            args: Prisma.BookingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          findMany: {
            args: Prisma.BookingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>[]
          }
          create: {
            args: Prisma.BookingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          createMany: {
            args: Prisma.BookingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>[]
          }
          delete: {
            args: Prisma.BookingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          update: {
            args: Prisma.BookingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          deleteMany: {
            args: Prisma.BookingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>[]
          }
          upsert: {
            args: Prisma.BookingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          aggregate: {
            args: Prisma.BookingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookings>
          }
          groupBy: {
            args: Prisma.BookingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingsCountArgs<ExtArgs>
            result: $Utils.Optional<BookingsCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      DriverVehicle: {
        payload: Prisma.$DriverVehiclePayload<ExtArgs>
        fields: Prisma.DriverVehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverVehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverVehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>
          }
          findFirst: {
            args: Prisma.DriverVehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverVehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>
          }
          findMany: {
            args: Prisma.DriverVehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>[]
          }
          create: {
            args: Prisma.DriverVehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>
          }
          createMany: {
            args: Prisma.DriverVehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverVehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>[]
          }
          delete: {
            args: Prisma.DriverVehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>
          }
          update: {
            args: Prisma.DriverVehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>
          }
          deleteMany: {
            args: Prisma.DriverVehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverVehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverVehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>[]
          }
          upsert: {
            args: Prisma.DriverVehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehiclePayload>
          }
          aggregate: {
            args: Prisma.DriverVehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverVehicle>
          }
          groupBy: {
            args: Prisma.DriverVehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverVehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverVehicleCountArgs<ExtArgs>
            result: $Utils.Optional<DriverVehicleCountAggregateOutputType> | number
          }
        }
      }
      DriverWallet: {
        payload: Prisma.$DriverWalletPayload<ExtArgs>
        fields: Prisma.DriverWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>
          }
          findFirst: {
            args: Prisma.DriverWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>
          }
          findMany: {
            args: Prisma.DriverWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>[]
          }
          create: {
            args: Prisma.DriverWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>
          }
          createMany: {
            args: Prisma.DriverWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>[]
          }
          delete: {
            args: Prisma.DriverWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>
          }
          update: {
            args: Prisma.DriverWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>
          }
          deleteMany: {
            args: Prisma.DriverWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>[]
          }
          upsert: {
            args: Prisma.DriverWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverWalletPayload>
          }
          aggregate: {
            args: Prisma.DriverWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverWallet>
          }
          groupBy: {
            args: Prisma.DriverWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverWalletCountArgs<ExtArgs>
            result: $Utils.Optional<DriverWalletCountAggregateOutputType> | number
          }
        }
      }
      FareNegotiation: {
        payload: Prisma.$FareNegotiationPayload<ExtArgs>
        fields: Prisma.FareNegotiationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FareNegotiationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FareNegotiationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>
          }
          findFirst: {
            args: Prisma.FareNegotiationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FareNegotiationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>
          }
          findMany: {
            args: Prisma.FareNegotiationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>[]
          }
          create: {
            args: Prisma.FareNegotiationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>
          }
          createMany: {
            args: Prisma.FareNegotiationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FareNegotiationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>[]
          }
          delete: {
            args: Prisma.FareNegotiationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>
          }
          update: {
            args: Prisma.FareNegotiationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>
          }
          deleteMany: {
            args: Prisma.FareNegotiationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FareNegotiationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FareNegotiationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>[]
          }
          upsert: {
            args: Prisma.FareNegotiationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareNegotiationPayload>
          }
          aggregate: {
            args: Prisma.FareNegotiationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFareNegotiation>
          }
          groupBy: {
            args: Prisma.FareNegotiationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FareNegotiationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FareNegotiationCountArgs<ExtArgs>
            result: $Utils.Optional<FareNegotiationCountAggregateOutputType> | number
          }
        }
      }
      Owner: {
        payload: Prisma.$OwnerPayload<ExtArgs>
        fields: Prisma.OwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findFirst: {
            args: Prisma.OwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findMany: {
            args: Prisma.OwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          create: {
            args: Prisma.OwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          createMany: {
            args: Prisma.OwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          delete: {
            args: Prisma.OwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          update: {
            args: Prisma.OwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          upsert: {
            args: Prisma.OwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          aggregate: {
            args: Prisma.OwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwner>
          }
          groupBy: {
            args: Prisma.OwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerCountAggregateOutputType> | number
          }
        }
      }
      OwnerDriver: {
        payload: Prisma.$OwnerDriverPayload<ExtArgs>
        fields: Prisma.OwnerDriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerDriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerDriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>
          }
          findFirst: {
            args: Prisma.OwnerDriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerDriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>
          }
          findMany: {
            args: Prisma.OwnerDriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>[]
          }
          create: {
            args: Prisma.OwnerDriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>
          }
          createMany: {
            args: Prisma.OwnerDriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerDriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>[]
          }
          delete: {
            args: Prisma.OwnerDriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>
          }
          update: {
            args: Prisma.OwnerDriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerDriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnerDriverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>[]
          }
          upsert: {
            args: Prisma.OwnerDriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDriverPayload>
          }
          aggregate: {
            args: Prisma.OwnerDriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerDriver>
          }
          groupBy: {
            args: Prisma.OwnerDriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerDriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerDriverCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerDriverCountAggregateOutputType> | number
          }
        }
      }
      OwnerVehicle: {
        payload: Prisma.$OwnerVehiclePayload<ExtArgs>
        fields: Prisma.OwnerVehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerVehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerVehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>
          }
          findFirst: {
            args: Prisma.OwnerVehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerVehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>
          }
          findMany: {
            args: Prisma.OwnerVehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>[]
          }
          create: {
            args: Prisma.OwnerVehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>
          }
          createMany: {
            args: Prisma.OwnerVehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerVehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>[]
          }
          delete: {
            args: Prisma.OwnerVehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>
          }
          update: {
            args: Prisma.OwnerVehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>
          }
          deleteMany: {
            args: Prisma.OwnerVehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerVehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnerVehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>[]
          }
          upsert: {
            args: Prisma.OwnerVehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerVehiclePayload>
          }
          aggregate: {
            args: Prisma.OwnerVehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerVehicle>
          }
          groupBy: {
            args: Prisma.OwnerVehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerVehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerVehicleCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerVehicleCountAggregateOutputType> | number
          }
        }
      }
      OwnerWallet: {
        payload: Prisma.$OwnerWalletPayload<ExtArgs>
        fields: Prisma.OwnerWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>
          }
          findFirst: {
            args: Prisma.OwnerWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>
          }
          findMany: {
            args: Prisma.OwnerWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>[]
          }
          create: {
            args: Prisma.OwnerWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>
          }
          createMany: {
            args: Prisma.OwnerWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>[]
          }
          delete: {
            args: Prisma.OwnerWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>
          }
          update: {
            args: Prisma.OwnerWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>
          }
          deleteMany: {
            args: Prisma.OwnerWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnerWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>[]
          }
          upsert: {
            args: Prisma.OwnerWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerWalletPayload>
          }
          aggregate: {
            args: Prisma.OwnerWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerWallet>
          }
          groupBy: {
            args: Prisma.OwnerWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerWalletCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerWalletCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserWallet: {
        payload: Prisma.$UserWalletPayload<ExtArgs>
        fields: Prisma.UserWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          findFirst: {
            args: Prisma.UserWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          findMany: {
            args: Prisma.UserWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>[]
          }
          create: {
            args: Prisma.UserWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          createMany: {
            args: Prisma.UserWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>[]
          }
          delete: {
            args: Prisma.UserWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          update: {
            args: Prisma.UserWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          deleteMany: {
            args: Prisma.UserWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>[]
          }
          upsert: {
            args: Prisma.UserWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWalletPayload>
          }
          aggregate: {
            args: Prisma.UserWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserWallet>
          }
          groupBy: {
            args: Prisma.UserWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserWalletCountArgs<ExtArgs>
            result: $Utils.Optional<UserWalletCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      otps: {
        payload: Prisma.$otpsPayload<ExtArgs>
        fields: Prisma.otpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.otpsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.otpsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          findFirst: {
            args: Prisma.otpsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.otpsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          findMany: {
            args: Prisma.otpsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>[]
          }
          create: {
            args: Prisma.otpsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          createMany: {
            args: Prisma.otpsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.otpsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>[]
          }
          delete: {
            args: Prisma.otpsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          update: {
            args: Prisma.otpsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          deleteMany: {
            args: Prisma.otpsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.otpsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.otpsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>[]
          }
          upsert: {
            args: Prisma.otpsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          aggregate: {
            args: Prisma.OtpsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtps>
          }
          groupBy: {
            args: Prisma.otpsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.otpsCountArgs<ExtArgs>
            result: $Utils.Optional<OtpsCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.adminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      permission_audit_logs: {
        payload: Prisma.$permission_audit_logsPayload<ExtArgs>
        fields: Prisma.permission_audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permission_audit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permission_audit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>
          }
          findFirst: {
            args: Prisma.permission_audit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permission_audit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>
          }
          findMany: {
            args: Prisma.permission_audit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>[]
          }
          create: {
            args: Prisma.permission_audit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>
          }
          createMany: {
            args: Prisma.permission_audit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permission_audit_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>[]
          }
          delete: {
            args: Prisma.permission_audit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>
          }
          update: {
            args: Prisma.permission_audit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.permission_audit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permission_audit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.permission_audit_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>[]
          }
          upsert: {
            args: Prisma.permission_audit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Permission_audit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission_audit_logs>
          }
          groupBy: {
            args: Prisma.permission_audit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Permission_audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.permission_audit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Permission_audit_logsCountAggregateOutputType> | number
          }
        }
      }
      permission_categories: {
        payload: Prisma.$permission_categoriesPayload<ExtArgs>
        fields: Prisma.permission_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permission_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permission_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>
          }
          findFirst: {
            args: Prisma.permission_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permission_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>
          }
          findMany: {
            args: Prisma.permission_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>[]
          }
          create: {
            args: Prisma.permission_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>
          }
          createMany: {
            args: Prisma.permission_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permission_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>[]
          }
          delete: {
            args: Prisma.permission_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>
          }
          update: {
            args: Prisma.permission_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.permission_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permission_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.permission_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.permission_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permission_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Permission_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission_categories>
          }
          groupBy: {
            args: Prisma.permission_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Permission_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.permission_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Permission_categoriesCountAggregateOutputType> | number
          }
        }
      }
      permissions: {
        payload: Prisma.$permissionsPayload<ExtArgs>
        fields: Prisma.permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findFirst: {
            args: Prisma.permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findMany: {
            args: Prisma.permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          create: {
            args: Prisma.permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          createMany: {
            args: Prisma.permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          delete: {
            args: Prisma.permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          update: {
            args: Prisma.permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          deleteMany: {
            args: Prisma.permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.permissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          upsert: {
            args: Prisma.permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      role_permissions: {
        payload: Prisma.$role_permissionsPayload<ExtArgs>
        fields: Prisma.role_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.role_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.role_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          findFirst: {
            args: Prisma.role_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.role_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          findMany: {
            args: Prisma.role_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
          }
          create: {
            args: Prisma.role_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          createMany: {
            args: Prisma.role_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.role_permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
          }
          delete: {
            args: Prisma.role_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          update: {
            args: Prisma.role_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.role_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.role_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.role_permissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
          }
          upsert: {
            args: Prisma.role_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Role_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole_permissions>
          }
          groupBy: {
            args: Prisma.role_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.role_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      user_roles: {
        payload: Prisma.$user_rolesPayload<ExtArgs>
        fields: Prisma.user_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findFirst: {
            args: Prisma.user_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findMany: {
            args: Prisma.user_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          create: {
            args: Prisma.user_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          createMany: {
            args: Prisma.user_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          delete: {
            args: Prisma.user_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          update: {
            args: Prisma.user_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          deleteMany: {
            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          upsert: {
            args: Prisma.user_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          aggregate: {
            args: Prisma.User_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_roles>
          }
          groupBy: {
            args: Prisma.user_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    bookings?: BookingsOmit
    driver?: DriverOmit
    driverVehicle?: DriverVehicleOmit
    driverWallet?: DriverWalletOmit
    fareNegotiation?: FareNegotiationOmit
    owner?: OwnerOmit
    ownerDriver?: OwnerDriverOmit
    ownerVehicle?: OwnerVehicleOmit
    ownerWallet?: OwnerWalletOmit
    user?: UserOmit
    userWallet?: UserWalletOmit
    vehicle?: VehicleOmit
    otps?: otpsOmit
    admin?: adminOmit
    permission_audit_logs?: permission_audit_logsOmit
    permission_categories?: permission_categoriesOmit
    permissions?: permissionsOmit
    role_permissions?: role_permissionsOmit
    roles?: rolesOmit
    user_roles?: user_rolesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BookingsCountOutputType
   */

  export type BookingsCountOutputType = {
    FareNegotiation: number
  }

  export type BookingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FareNegotiation?: boolean | BookingsCountOutputTypeCountFareNegotiationArgs
  }

  // Custom InputTypes
  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingsCountOutputType
     */
    select?: BookingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountFareNegotiationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareNegotiationWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    Bookings: number
    DriverVehicle: number
    FareNegotiation: number
    OwnerDriver: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | DriverCountOutputTypeCountBookingsArgs
    DriverVehicle?: boolean | DriverCountOutputTypeCountDriverVehicleArgs
    FareNegotiation?: boolean | DriverCountOutputTypeCountFareNegotiationArgs
    OwnerDriver?: boolean | DriverCountOutputTypeCountOwnerDriverArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingsWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountDriverVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverVehicleWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountFareNegotiationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareNegotiationWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountOwnerDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDriverWhereInput
  }


  /**
   * Count Type OwnerCountOutputType
   */

  export type OwnerCountOutputType = {
    FareNegotiation: number
    OwnerDriver: number
    OwnerVehicle: number
  }

  export type OwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FareNegotiation?: boolean | OwnerCountOutputTypeCountFareNegotiationArgs
    OwnerDriver?: boolean | OwnerCountOutputTypeCountOwnerDriverArgs
    OwnerVehicle?: boolean | OwnerCountOutputTypeCountOwnerVehicleArgs
  }

  // Custom InputTypes
  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCountOutputType
     */
    select?: OwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountFareNegotiationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareNegotiationWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountOwnerDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDriverWhereInput
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountOwnerVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerVehicleWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Bookings: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | UserCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingsWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    Bookings: number
    DriverVehicle: number
    OwnerVehicle: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | VehicleCountOutputTypeCountBookingsArgs
    DriverVehicle?: boolean | VehicleCountOutputTypeCountDriverVehicleArgs
    OwnerVehicle?: boolean | VehicleCountOutputTypeCountOwnerVehicleArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingsWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountDriverVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverVehicleWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountOwnerVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerVehicleWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    permission_audit_logs: number
    roles: number
    user_roles_user_roles_adminIdToadmin: number
    user_roles_user_roles_assignedByIdToadmin: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_audit_logs?: boolean | AdminCountOutputTypeCountPermission_audit_logsArgs
    roles?: boolean | AdminCountOutputTypeCountRolesArgs
    user_roles_user_roles_adminIdToadmin?: boolean | AdminCountOutputTypeCountUser_roles_user_roles_adminIdToadminArgs
    user_roles_user_roles_assignedByIdToadmin?: boolean | AdminCountOutputTypeCountUser_roles_user_roles_assignedByIdToadminArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountPermission_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permission_audit_logsWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountUser_roles_user_roles_adminIdToadminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountUser_roles_user_roles_assignedByIdToadminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Count Type Permission_categoriesCountOutputType
   */

  export type Permission_categoriesCountOutputType = {
    permissions: number
  }

  export type Permission_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Permission_categoriesCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * Permission_categoriesCountOutputType without action
   */
  export type Permission_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission_categoriesCountOutputType
     */
    select?: Permission_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Permission_categoriesCountOutputType without action
   */
  export type Permission_categoriesCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionsWhereInput
  }


  /**
   * Count Type PermissionsCountOutputType
   */

  export type PermissionsCountOutputType = {
    permission_audit_logs: number
    role_permissions: number
  }

  export type PermissionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_audit_logs?: boolean | PermissionsCountOutputTypeCountPermission_audit_logsArgs
    role_permissions?: boolean | PermissionsCountOutputTypeCountRole_permissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionsCountOutputType
     */
    select?: PermissionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountPermission_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permission_audit_logsWhereInput
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountRole_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    permission_audit_logs: number
    role_permissions: number
    user_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_audit_logs?: boolean | RolesCountOutputTypeCountPermission_audit_logsArgs
    role_permissions?: boolean | RolesCountOutputTypeCountRole_permissionsArgs
    user_roles?: boolean | RolesCountOutputTypeCountUser_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountPermission_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permission_audit_logsWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRole_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Bookings
   */

  export type AggregateBookings = {
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  export type BookingsAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
    DriverId: number | null
    VehicleId: number | null
  }

  export type BookingsSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
    DriverId: number | null
    VehicleId: number | null
  }

  export type BookingsMinAggregateOutputType = {
    Id: number | null
    UserId: number | null
    PickUpLocation: string | null
    DropLocation: string | null
    Product: string | null
    Distance: string | null
    Status: $Enums.BookingStatus | null
    PaymentMode: $Enums.PaymentMode | null
    BookingTime: Date | null
    DriverId: number | null
    Fare: string | null
    VehicleId: number | null
    StartTime: Date | null
    CreatedDateTime: Date | null
    UpdatedDateTime: Date | null
  }

  export type BookingsMaxAggregateOutputType = {
    Id: number | null
    UserId: number | null
    PickUpLocation: string | null
    DropLocation: string | null
    Product: string | null
    Distance: string | null
    Status: $Enums.BookingStatus | null
    PaymentMode: $Enums.PaymentMode | null
    BookingTime: Date | null
    DriverId: number | null
    Fare: string | null
    VehicleId: number | null
    StartTime: Date | null
    CreatedDateTime: Date | null
    UpdatedDateTime: Date | null
  }

  export type BookingsCountAggregateOutputType = {
    Id: number
    UserId: number
    PickUpLocation: number
    DropLocation: number
    Product: number
    Distance: number
    Status: number
    PaymentMode: number
    BookingTime: number
    DriverId: number
    Fare: number
    VehicleId: number
    StartTime: number
    CreatedDateTime: number
    UpdatedDateTime: number
    _all: number
  }


  export type BookingsAvgAggregateInputType = {
    Id?: true
    UserId?: true
    DriverId?: true
    VehicleId?: true
  }

  export type BookingsSumAggregateInputType = {
    Id?: true
    UserId?: true
    DriverId?: true
    VehicleId?: true
  }

  export type BookingsMinAggregateInputType = {
    Id?: true
    UserId?: true
    PickUpLocation?: true
    DropLocation?: true
    Product?: true
    Distance?: true
    Status?: true
    PaymentMode?: true
    BookingTime?: true
    DriverId?: true
    Fare?: true
    VehicleId?: true
    StartTime?: true
    CreatedDateTime?: true
    UpdatedDateTime?: true
  }

  export type BookingsMaxAggregateInputType = {
    Id?: true
    UserId?: true
    PickUpLocation?: true
    DropLocation?: true
    Product?: true
    Distance?: true
    Status?: true
    PaymentMode?: true
    BookingTime?: true
    DriverId?: true
    Fare?: true
    VehicleId?: true
    StartTime?: true
    CreatedDateTime?: true
    UpdatedDateTime?: true
  }

  export type BookingsCountAggregateInputType = {
    Id?: true
    UserId?: true
    PickUpLocation?: true
    DropLocation?: true
    Product?: true
    Distance?: true
    Status?: true
    PaymentMode?: true
    BookingTime?: true
    DriverId?: true
    Fare?: true
    VehicleId?: true
    StartTime?: true
    CreatedDateTime?: true
    UpdatedDateTime?: true
    _all?: true
  }

  export type BookingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to aggregate.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingsMaxAggregateInputType
  }

  export type GetBookingsAggregateType<T extends BookingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBookings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookings[P]>
      : GetScalarType<T[P], AggregateBookings[P]>
  }




  export type BookingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingsWhereInput
    orderBy?: BookingsOrderByWithAggregationInput | BookingsOrderByWithAggregationInput[]
    by: BookingsScalarFieldEnum[] | BookingsScalarFieldEnum
    having?: BookingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingsCountAggregateInputType | true
    _avg?: BookingsAvgAggregateInputType
    _sum?: BookingsSumAggregateInputType
    _min?: BookingsMinAggregateInputType
    _max?: BookingsMaxAggregateInputType
  }

  export type BookingsGroupByOutputType = {
    Id: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime: Date
    DriverId: number | null
    Fare: string
    VehicleId: number | null
    StartTime: Date
    CreatedDateTime: Date
    UpdatedDateTime: Date
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  type GetBookingsGroupByPayload<T extends BookingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingsGroupByOutputType[P]>
            : GetScalarType<T[P], BookingsGroupByOutputType[P]>
        }
      >
    >


  export type BookingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    PickUpLocation?: boolean
    DropLocation?: boolean
    Product?: boolean
    Distance?: boolean
    Status?: boolean
    PaymentMode?: boolean
    BookingTime?: boolean
    DriverId?: boolean
    Fare?: boolean
    VehicleId?: boolean
    StartTime?: boolean
    CreatedDateTime?: boolean
    UpdatedDateTime?: boolean
    Driver?: boolean | Bookings$DriverArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Vehicle?: boolean | Bookings$VehicleArgs<ExtArgs>
    FareNegotiation?: boolean | Bookings$FareNegotiationArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type BookingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    PickUpLocation?: boolean
    DropLocation?: boolean
    Product?: boolean
    Distance?: boolean
    Status?: boolean
    PaymentMode?: boolean
    BookingTime?: boolean
    DriverId?: boolean
    Fare?: boolean
    VehicleId?: boolean
    StartTime?: boolean
    CreatedDateTime?: boolean
    UpdatedDateTime?: boolean
    Driver?: boolean | Bookings$DriverArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Vehicle?: boolean | Bookings$VehicleArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type BookingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    PickUpLocation?: boolean
    DropLocation?: boolean
    Product?: boolean
    Distance?: boolean
    Status?: boolean
    PaymentMode?: boolean
    BookingTime?: boolean
    DriverId?: boolean
    Fare?: boolean
    VehicleId?: boolean
    StartTime?: boolean
    CreatedDateTime?: boolean
    UpdatedDateTime?: boolean
    Driver?: boolean | Bookings$DriverArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Vehicle?: boolean | Bookings$VehicleArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type BookingsSelectScalar = {
    Id?: boolean
    UserId?: boolean
    PickUpLocation?: boolean
    DropLocation?: boolean
    Product?: boolean
    Distance?: boolean
    Status?: boolean
    PaymentMode?: boolean
    BookingTime?: boolean
    DriverId?: boolean
    Fare?: boolean
    VehicleId?: boolean
    StartTime?: boolean
    CreatedDateTime?: boolean
    UpdatedDateTime?: boolean
  }

  export type BookingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UserId" | "PickUpLocation" | "DropLocation" | "Product" | "Distance" | "Status" | "PaymentMode" | "BookingTime" | "DriverId" | "Fare" | "VehicleId" | "StartTime" | "CreatedDateTime" | "UpdatedDateTime", ExtArgs["result"]["bookings"]>
  export type BookingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | Bookings$DriverArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Vehicle?: boolean | Bookings$VehicleArgs<ExtArgs>
    FareNegotiation?: boolean | Bookings$FareNegotiationArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | Bookings$DriverArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Vehicle?: boolean | Bookings$VehicleArgs<ExtArgs>
  }
  export type BookingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | Bookings$DriverArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Vehicle?: boolean | Bookings$VehicleArgs<ExtArgs>
  }

  export type $BookingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookings"
    objects: {
      Driver: Prisma.$DriverPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
      Vehicle: Prisma.$VehiclePayload<ExtArgs> | null
      FareNegotiation: Prisma.$FareNegotiationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UserId: number
      PickUpLocation: string
      DropLocation: string
      Product: string
      Distance: string
      Status: $Enums.BookingStatus
      PaymentMode: $Enums.PaymentMode
      BookingTime: Date
      DriverId: number | null
      Fare: string
      VehicleId: number | null
      StartTime: Date
      CreatedDateTime: Date
      UpdatedDateTime: Date
    }, ExtArgs["result"]["bookings"]>
    composites: {}
  }

  type BookingsGetPayload<S extends boolean | null | undefined | BookingsDefaultArgs> = $Result.GetResult<Prisma.$BookingsPayload, S>

  type BookingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingsCountAggregateInputType | true
    }

  export interface BookingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookings'], meta: { name: 'Bookings' } }
    /**
     * Find zero or one Bookings that matches the filter.
     * @param {BookingsFindUniqueArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingsFindUniqueArgs>(args: SelectSubset<T, BookingsFindUniqueArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bookings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingsFindUniqueOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingsFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsFindFirstArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingsFindFirstArgs>(args?: SelectSubset<T, BookingsFindFirstArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsFindFirstOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingsFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.bookings.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.bookings.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const bookingsWithIdOnly = await prisma.bookings.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends BookingsFindManyArgs>(args?: SelectSubset<T, BookingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bookings.
     * @param {BookingsCreateArgs} args - Arguments to create a Bookings.
     * @example
     * // Create one Bookings
     * const Bookings = await prisma.bookings.create({
     *   data: {
     *     // ... data to create a Bookings
     *   }
     * })
     * 
     */
    create<T extends BookingsCreateArgs>(args: SelectSubset<T, BookingsCreateArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingsCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingsCreateManyArgs>(args?: SelectSubset<T, BookingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingsCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `Id`
     * const bookingsWithIdOnly = await prisma.bookings.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingsCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bookings.
     * @param {BookingsDeleteArgs} args - Arguments to delete one Bookings.
     * @example
     * // Delete one Bookings
     * const Bookings = await prisma.bookings.delete({
     *   where: {
     *     // ... filter to delete one Bookings
     *   }
     * })
     * 
     */
    delete<T extends BookingsDeleteArgs>(args: SelectSubset<T, BookingsDeleteArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bookings.
     * @param {BookingsUpdateArgs} args - Arguments to update one Bookings.
     * @example
     * // Update one Bookings
     * const bookings = await prisma.bookings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingsUpdateArgs>(args: SelectSubset<T, BookingsUpdateArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingsDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.bookings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingsDeleteManyArgs>(args?: SelectSubset<T, BookingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const bookings = await prisma.bookings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingsUpdateManyArgs>(args: SelectSubset<T, BookingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingsUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const bookings = await prisma.bookings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `Id`
     * const bookingsWithIdOnly = await prisma.bookings.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingsUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bookings.
     * @param {BookingsUpsertArgs} args - Arguments to update or create a Bookings.
     * @example
     * // Update or create a Bookings
     * const bookings = await prisma.bookings.upsert({
     *   create: {
     *     // ... data to create a Bookings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookings we want to update
     *   }
     * })
     */
    upsert<T extends BookingsUpsertArgs>(args: SelectSubset<T, BookingsUpsertArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.bookings.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingsCountArgs>(
      args?: Subset<T, BookingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingsAggregateArgs>(args: Subset<T, BookingsAggregateArgs>): Prisma.PrismaPromise<GetBookingsAggregateType<T>>

    /**
     * Group by Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingsGroupByArgs['orderBy'] }
        : { orderBy?: BookingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookings model
   */
  readonly fields: BookingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Driver<T extends Bookings$DriverArgs<ExtArgs> = {}>(args?: Subset<T, Bookings$DriverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Vehicle<T extends Bookings$VehicleArgs<ExtArgs> = {}>(args?: Subset<T, Bookings$VehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    FareNegotiation<T extends Bookings$FareNegotiationArgs<ExtArgs> = {}>(args?: Subset<T, Bookings$FareNegotiationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookings model
   */
  interface BookingsFieldRefs {
    readonly Id: FieldRef<"Bookings", 'Int'>
    readonly UserId: FieldRef<"Bookings", 'Int'>
    readonly PickUpLocation: FieldRef<"Bookings", 'String'>
    readonly DropLocation: FieldRef<"Bookings", 'String'>
    readonly Product: FieldRef<"Bookings", 'String'>
    readonly Distance: FieldRef<"Bookings", 'String'>
    readonly Status: FieldRef<"Bookings", 'BookingStatus'>
    readonly PaymentMode: FieldRef<"Bookings", 'PaymentMode'>
    readonly BookingTime: FieldRef<"Bookings", 'DateTime'>
    readonly DriverId: FieldRef<"Bookings", 'Int'>
    readonly Fare: FieldRef<"Bookings", 'String'>
    readonly VehicleId: FieldRef<"Bookings", 'Int'>
    readonly StartTime: FieldRef<"Bookings", 'DateTime'>
    readonly CreatedDateTime: FieldRef<"Bookings", 'DateTime'>
    readonly UpdatedDateTime: FieldRef<"Bookings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bookings findUnique
   */
  export type BookingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings findUniqueOrThrow
   */
  export type BookingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings findFirst
   */
  export type BookingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Bookings findFirstOrThrow
   */
  export type BookingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Bookings findMany
   */
  export type BookingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Bookings create
   */
  export type BookingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookings.
     */
    data: XOR<BookingsCreateInput, BookingsUncheckedCreateInput>
  }

  /**
   * Bookings createMany
   */
  export type BookingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingsCreateManyInput | BookingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookings createManyAndReturn
   */
  export type BookingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingsCreateManyInput | BookingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookings update
   */
  export type BookingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookings.
     */
    data: XOR<BookingsUpdateInput, BookingsUncheckedUpdateInput>
    /**
     * Choose, which Bookings to update.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings updateMany
   */
  export type BookingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingsWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Bookings updateManyAndReturn
   */
  export type BookingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingsWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookings upsert
   */
  export type BookingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookings to update in case it exists.
     */
    where: BookingsWhereUniqueInput
    /**
     * In case the Bookings found by the `where` argument doesn't exist, create a new Bookings with this data.
     */
    create: XOR<BookingsCreateInput, BookingsUncheckedCreateInput>
    /**
     * In case the Bookings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingsUpdateInput, BookingsUncheckedUpdateInput>
  }

  /**
   * Bookings delete
   */
  export type BookingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter which Bookings to delete.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings deleteMany
   */
  export type BookingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingsWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Bookings.Driver
   */
  export type Bookings$DriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * Bookings.Vehicle
   */
  export type Bookings$VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Bookings.FareNegotiation
   */
  export type Bookings$FareNegotiationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    where?: FareNegotiationWhereInput
    orderBy?: FareNegotiationOrderByWithRelationInput | FareNegotiationOrderByWithRelationInput[]
    cursor?: FareNegotiationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareNegotiationScalarFieldEnum | FareNegotiationScalarFieldEnum[]
  }

  /**
   * Bookings without action
   */
  export type BookingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    Id: number | null
  }

  export type DriverSumAggregateOutputType = {
    Id: number | null
  }

  export type DriverMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Gender: $Enums.Gender | null
    Password: string | null
    MobileNumber: string | null
    DOB: Date | null
    DrivingLicenceNumber: string | null
    DrivingLicenceFrontImage: string | null
    DrivingLicenceBackImage: string | null
    DriverImage: string | null
    Email: string | null
    AdhaarCardNumber: string | null
    FrontSideAdhaarImage: string | null
    BackSideAdhaarImage: string | null
    PanNumber: string | null
    PanImage: string | null
    LastLoggedIn: Date | null
    CreatedDate: Date | null
    IsOnline: boolean | null
  }

  export type DriverMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Gender: $Enums.Gender | null
    Password: string | null
    MobileNumber: string | null
    DOB: Date | null
    DrivingLicenceNumber: string | null
    DrivingLicenceFrontImage: string | null
    DrivingLicenceBackImage: string | null
    DriverImage: string | null
    Email: string | null
    AdhaarCardNumber: string | null
    FrontSideAdhaarImage: string | null
    BackSideAdhaarImage: string | null
    PanNumber: string | null
    PanImage: string | null
    LastLoggedIn: Date | null
    CreatedDate: Date | null
    IsOnline: boolean | null
  }

  export type DriverCountAggregateOutputType = {
    Id: number
    Name: number
    Gender: number
    Password: number
    MobileNumber: number
    DOB: number
    DrivingLicenceNumber: number
    DrivingLicenceFrontImage: number
    DrivingLicenceBackImage: number
    DriverImage: number
    Email: number
    AdhaarCardNumber: number
    FrontSideAdhaarImage: number
    BackSideAdhaarImage: number
    PanNumber: number
    PanImage: number
    LastLoggedIn: number
    CreatedDate: number
    IsOnline: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    Id?: true
  }

  export type DriverSumAggregateInputType = {
    Id?: true
  }

  export type DriverMinAggregateInputType = {
    Id?: true
    Name?: true
    Gender?: true
    Password?: true
    MobileNumber?: true
    DOB?: true
    DrivingLicenceNumber?: true
    DrivingLicenceFrontImage?: true
    DrivingLicenceBackImage?: true
    DriverImage?: true
    Email?: true
    AdhaarCardNumber?: true
    FrontSideAdhaarImage?: true
    BackSideAdhaarImage?: true
    PanNumber?: true
    PanImage?: true
    LastLoggedIn?: true
    CreatedDate?: true
    IsOnline?: true
  }

  export type DriverMaxAggregateInputType = {
    Id?: true
    Name?: true
    Gender?: true
    Password?: true
    MobileNumber?: true
    DOB?: true
    DrivingLicenceNumber?: true
    DrivingLicenceFrontImage?: true
    DrivingLicenceBackImage?: true
    DriverImage?: true
    Email?: true
    AdhaarCardNumber?: true
    FrontSideAdhaarImage?: true
    BackSideAdhaarImage?: true
    PanNumber?: true
    PanImage?: true
    LastLoggedIn?: true
    CreatedDate?: true
    IsOnline?: true
  }

  export type DriverCountAggregateInputType = {
    Id?: true
    Name?: true
    Gender?: true
    Password?: true
    MobileNumber?: true
    DOB?: true
    DrivingLicenceNumber?: true
    DrivingLicenceFrontImage?: true
    DrivingLicenceBackImage?: true
    DriverImage?: true
    Email?: true
    AdhaarCardNumber?: true
    FrontSideAdhaarImage?: true
    BackSideAdhaarImage?: true
    PanNumber?: true
    PanImage?: true
    LastLoggedIn?: true
    CreatedDate?: true
    IsOnline?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    Id: number
    Name: string | null
    Gender: $Enums.Gender
    Password: string | null
    MobileNumber: string
    DOB: Date | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn: Date
    CreatedDate: Date
    IsOnline: boolean
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    Gender?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    DrivingLicenceNumber?: boolean
    DrivingLicenceFrontImage?: boolean
    DrivingLicenceBackImage?: boolean
    DriverImage?: boolean
    Email?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
    IsOnline?: boolean
    Bookings?: boolean | Driver$BookingsArgs<ExtArgs>
    DriverVehicle?: boolean | Driver$DriverVehicleArgs<ExtArgs>
    DriverWallet?: boolean | Driver$DriverWalletArgs<ExtArgs>
    FareNegotiation?: boolean | Driver$FareNegotiationArgs<ExtArgs>
    OwnerDriver?: boolean | Driver$OwnerDriverArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    Gender?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    DrivingLicenceNumber?: boolean
    DrivingLicenceFrontImage?: boolean
    DrivingLicenceBackImage?: boolean
    DriverImage?: boolean
    Email?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
    IsOnline?: boolean
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    Gender?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    DrivingLicenceNumber?: boolean
    DrivingLicenceFrontImage?: boolean
    DrivingLicenceBackImage?: boolean
    DriverImage?: boolean
    Email?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
    IsOnline?: boolean
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    Id?: boolean
    Name?: boolean
    Gender?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    DrivingLicenceNumber?: boolean
    DrivingLicenceFrontImage?: boolean
    DrivingLicenceBackImage?: boolean
    DriverImage?: boolean
    Email?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
    IsOnline?: boolean
  }

  export type DriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Name" | "Gender" | "Password" | "MobileNumber" | "DOB" | "DrivingLicenceNumber" | "DrivingLicenceFrontImage" | "DrivingLicenceBackImage" | "DriverImage" | "Email" | "AdhaarCardNumber" | "FrontSideAdhaarImage" | "BackSideAdhaarImage" | "PanNumber" | "PanImage" | "LastLoggedIn" | "CreatedDate" | "IsOnline", ExtArgs["result"]["driver"]>
  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | Driver$BookingsArgs<ExtArgs>
    DriverVehicle?: boolean | Driver$DriverVehicleArgs<ExtArgs>
    DriverWallet?: boolean | Driver$DriverWalletArgs<ExtArgs>
    FareNegotiation?: boolean | Driver$FareNegotiationArgs<ExtArgs>
    OwnerDriver?: boolean | Driver$OwnerDriverArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DriverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      Bookings: Prisma.$BookingsPayload<ExtArgs>[]
      DriverVehicle: Prisma.$DriverVehiclePayload<ExtArgs>[]
      DriverWallet: Prisma.$DriverWalletPayload<ExtArgs> | null
      FareNegotiation: Prisma.$FareNegotiationPayload<ExtArgs>[]
      OwnerDriver: Prisma.$OwnerDriverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Name: string | null
      Gender: $Enums.Gender
      Password: string | null
      MobileNumber: string
      DOB: Date | null
      DrivingLicenceNumber: string
      DrivingLicenceFrontImage: string
      DrivingLicenceBackImage: string
      DriverImage: string
      Email: string | null
      AdhaarCardNumber: string
      FrontSideAdhaarImage: string
      BackSideAdhaarImage: string
      PanNumber: string
      PanImage: string
      LastLoggedIn: Date
      CreatedDate: Date
      IsOnline: boolean
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `Id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers and returns the data updated in the database.
     * @param {DriverUpdateManyAndReturnArgs} args - Arguments to update many Drivers.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drivers and only return the `Id`
     * const driverWithIdOnly = await prisma.driver.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bookings<T extends Driver$BookingsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$BookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DriverVehicle<T extends Driver$DriverVehicleArgs<ExtArgs> = {}>(args?: Subset<T, Driver$DriverVehicleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DriverWallet<T extends Driver$DriverWalletArgs<ExtArgs> = {}>(args?: Subset<T, Driver$DriverWalletArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    FareNegotiation<T extends Driver$FareNegotiationArgs<ExtArgs> = {}>(args?: Subset<T, Driver$FareNegotiationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OwnerDriver<T extends Driver$OwnerDriverArgs<ExtArgs> = {}>(args?: Subset<T, Driver$OwnerDriverArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */
  interface DriverFieldRefs {
    readonly Id: FieldRef<"Driver", 'Int'>
    readonly Name: FieldRef<"Driver", 'String'>
    readonly Gender: FieldRef<"Driver", 'Gender'>
    readonly Password: FieldRef<"Driver", 'String'>
    readonly MobileNumber: FieldRef<"Driver", 'String'>
    readonly DOB: FieldRef<"Driver", 'DateTime'>
    readonly DrivingLicenceNumber: FieldRef<"Driver", 'String'>
    readonly DrivingLicenceFrontImage: FieldRef<"Driver", 'String'>
    readonly DrivingLicenceBackImage: FieldRef<"Driver", 'String'>
    readonly DriverImage: FieldRef<"Driver", 'String'>
    readonly Email: FieldRef<"Driver", 'String'>
    readonly AdhaarCardNumber: FieldRef<"Driver", 'String'>
    readonly FrontSideAdhaarImage: FieldRef<"Driver", 'String'>
    readonly BackSideAdhaarImage: FieldRef<"Driver", 'String'>
    readonly PanNumber: FieldRef<"Driver", 'String'>
    readonly PanImage: FieldRef<"Driver", 'String'>
    readonly LastLoggedIn: FieldRef<"Driver", 'DateTime'>
    readonly CreatedDate: FieldRef<"Driver", 'DateTime'>
    readonly IsOnline: FieldRef<"Driver", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Driver updateManyAndReturn
   */
  export type DriverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to delete.
     */
    limit?: number
  }

  /**
   * Driver.Bookings
   */
  export type Driver$BookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    where?: BookingsWhereInput
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    cursor?: BookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Driver.DriverVehicle
   */
  export type Driver$DriverVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    where?: DriverVehicleWhereInput
    orderBy?: DriverVehicleOrderByWithRelationInput | DriverVehicleOrderByWithRelationInput[]
    cursor?: DriverVehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverVehicleScalarFieldEnum | DriverVehicleScalarFieldEnum[]
  }

  /**
   * Driver.DriverWallet
   */
  export type Driver$DriverWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    where?: DriverWalletWhereInput
  }

  /**
   * Driver.FareNegotiation
   */
  export type Driver$FareNegotiationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    where?: FareNegotiationWhereInput
    orderBy?: FareNegotiationOrderByWithRelationInput | FareNegotiationOrderByWithRelationInput[]
    cursor?: FareNegotiationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareNegotiationScalarFieldEnum | FareNegotiationScalarFieldEnum[]
  }

  /**
   * Driver.OwnerDriver
   */
  export type Driver$OwnerDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    where?: OwnerDriverWhereInput
    orderBy?: OwnerDriverOrderByWithRelationInput | OwnerDriverOrderByWithRelationInput[]
    cursor?: OwnerDriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerDriverScalarFieldEnum | OwnerDriverScalarFieldEnum[]
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model DriverVehicle
   */

  export type AggregateDriverVehicle = {
    _count: DriverVehicleCountAggregateOutputType | null
    _avg: DriverVehicleAvgAggregateOutputType | null
    _sum: DriverVehicleSumAggregateOutputType | null
    _min: DriverVehicleMinAggregateOutputType | null
    _max: DriverVehicleMaxAggregateOutputType | null
  }

  export type DriverVehicleAvgAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    VehicleId: number | null
  }

  export type DriverVehicleSumAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    VehicleId: number | null
  }

  export type DriverVehicleMinAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    VehicleId: number | null
  }

  export type DriverVehicleMaxAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    VehicleId: number | null
  }

  export type DriverVehicleCountAggregateOutputType = {
    Id: number
    DriverId: number
    VehicleId: number
    _all: number
  }


  export type DriverVehicleAvgAggregateInputType = {
    Id?: true
    DriverId?: true
    VehicleId?: true
  }

  export type DriverVehicleSumAggregateInputType = {
    Id?: true
    DriverId?: true
    VehicleId?: true
  }

  export type DriverVehicleMinAggregateInputType = {
    Id?: true
    DriverId?: true
    VehicleId?: true
  }

  export type DriverVehicleMaxAggregateInputType = {
    Id?: true
    DriverId?: true
    VehicleId?: true
  }

  export type DriverVehicleCountAggregateInputType = {
    Id?: true
    DriverId?: true
    VehicleId?: true
    _all?: true
  }

  export type DriverVehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverVehicle to aggregate.
     */
    where?: DriverVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicles to fetch.
     */
    orderBy?: DriverVehicleOrderByWithRelationInput | DriverVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverVehicles
    **/
    _count?: true | DriverVehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverVehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverVehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverVehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverVehicleMaxAggregateInputType
  }

  export type GetDriverVehicleAggregateType<T extends DriverVehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverVehicle[P]>
      : GetScalarType<T[P], AggregateDriverVehicle[P]>
  }




  export type DriverVehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverVehicleWhereInput
    orderBy?: DriverVehicleOrderByWithAggregationInput | DriverVehicleOrderByWithAggregationInput[]
    by: DriverVehicleScalarFieldEnum[] | DriverVehicleScalarFieldEnum
    having?: DriverVehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverVehicleCountAggregateInputType | true
    _avg?: DriverVehicleAvgAggregateInputType
    _sum?: DriverVehicleSumAggregateInputType
    _min?: DriverVehicleMinAggregateInputType
    _max?: DriverVehicleMaxAggregateInputType
  }

  export type DriverVehicleGroupByOutputType = {
    Id: number
    DriverId: number
    VehicleId: number
    _count: DriverVehicleCountAggregateOutputType | null
    _avg: DriverVehicleAvgAggregateOutputType | null
    _sum: DriverVehicleSumAggregateOutputType | null
    _min: DriverVehicleMinAggregateOutputType | null
    _max: DriverVehicleMaxAggregateOutputType | null
  }

  type GetDriverVehicleGroupByPayload<T extends DriverVehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverVehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverVehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverVehicleGroupByOutputType[P]>
            : GetScalarType<T[P], DriverVehicleGroupByOutputType[P]>
        }
      >
    >


  export type DriverVehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DriverId?: boolean
    VehicleId?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverVehicle"]>

  export type DriverVehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DriverId?: boolean
    VehicleId?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverVehicle"]>

  export type DriverVehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DriverId?: boolean
    VehicleId?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverVehicle"]>

  export type DriverVehicleSelectScalar = {
    Id?: boolean
    DriverId?: boolean
    VehicleId?: boolean
  }

  export type DriverVehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "DriverId" | "VehicleId", ExtArgs["result"]["driverVehicle"]>
  export type DriverVehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type DriverVehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type DriverVehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $DriverVehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverVehicle"
    objects: {
      Driver: Prisma.$DriverPayload<ExtArgs>
      Vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      DriverId: number
      VehicleId: number
    }, ExtArgs["result"]["driverVehicle"]>
    composites: {}
  }

  type DriverVehicleGetPayload<S extends boolean | null | undefined | DriverVehicleDefaultArgs> = $Result.GetResult<Prisma.$DriverVehiclePayload, S>

  type DriverVehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverVehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverVehicleCountAggregateInputType | true
    }

  export interface DriverVehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverVehicle'], meta: { name: 'DriverVehicle' } }
    /**
     * Find zero or one DriverVehicle that matches the filter.
     * @param {DriverVehicleFindUniqueArgs} args - Arguments to find a DriverVehicle
     * @example
     * // Get one DriverVehicle
     * const driverVehicle = await prisma.driverVehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverVehicleFindUniqueArgs>(args: SelectSubset<T, DriverVehicleFindUniqueArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DriverVehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverVehicleFindUniqueOrThrowArgs} args - Arguments to find a DriverVehicle
     * @example
     * // Get one DriverVehicle
     * const driverVehicle = await prisma.driverVehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverVehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverVehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverVehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleFindFirstArgs} args - Arguments to find a DriverVehicle
     * @example
     * // Get one DriverVehicle
     * const driverVehicle = await prisma.driverVehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverVehicleFindFirstArgs>(args?: SelectSubset<T, DriverVehicleFindFirstArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverVehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleFindFirstOrThrowArgs} args - Arguments to find a DriverVehicle
     * @example
     * // Get one DriverVehicle
     * const driverVehicle = await prisma.driverVehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverVehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverVehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DriverVehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverVehicles
     * const driverVehicles = await prisma.driverVehicle.findMany()
     * 
     * // Get first 10 DriverVehicles
     * const driverVehicles = await prisma.driverVehicle.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const driverVehicleWithIdOnly = await prisma.driverVehicle.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends DriverVehicleFindManyArgs>(args?: SelectSubset<T, DriverVehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DriverVehicle.
     * @param {DriverVehicleCreateArgs} args - Arguments to create a DriverVehicle.
     * @example
     * // Create one DriverVehicle
     * const DriverVehicle = await prisma.driverVehicle.create({
     *   data: {
     *     // ... data to create a DriverVehicle
     *   }
     * })
     * 
     */
    create<T extends DriverVehicleCreateArgs>(args: SelectSubset<T, DriverVehicleCreateArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DriverVehicles.
     * @param {DriverVehicleCreateManyArgs} args - Arguments to create many DriverVehicles.
     * @example
     * // Create many DriverVehicles
     * const driverVehicle = await prisma.driverVehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverVehicleCreateManyArgs>(args?: SelectSubset<T, DriverVehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriverVehicles and returns the data saved in the database.
     * @param {DriverVehicleCreateManyAndReturnArgs} args - Arguments to create many DriverVehicles.
     * @example
     * // Create many DriverVehicles
     * const driverVehicle = await prisma.driverVehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriverVehicles and only return the `Id`
     * const driverVehicleWithIdOnly = await prisma.driverVehicle.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverVehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverVehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DriverVehicle.
     * @param {DriverVehicleDeleteArgs} args - Arguments to delete one DriverVehicle.
     * @example
     * // Delete one DriverVehicle
     * const DriverVehicle = await prisma.driverVehicle.delete({
     *   where: {
     *     // ... filter to delete one DriverVehicle
     *   }
     * })
     * 
     */
    delete<T extends DriverVehicleDeleteArgs>(args: SelectSubset<T, DriverVehicleDeleteArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DriverVehicle.
     * @param {DriverVehicleUpdateArgs} args - Arguments to update one DriverVehicle.
     * @example
     * // Update one DriverVehicle
     * const driverVehicle = await prisma.driverVehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverVehicleUpdateArgs>(args: SelectSubset<T, DriverVehicleUpdateArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DriverVehicles.
     * @param {DriverVehicleDeleteManyArgs} args - Arguments to filter DriverVehicles to delete.
     * @example
     * // Delete a few DriverVehicles
     * const { count } = await prisma.driverVehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverVehicleDeleteManyArgs>(args?: SelectSubset<T, DriverVehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverVehicles
     * const driverVehicle = await prisma.driverVehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverVehicleUpdateManyArgs>(args: SelectSubset<T, DriverVehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverVehicles and returns the data updated in the database.
     * @param {DriverVehicleUpdateManyAndReturnArgs} args - Arguments to update many DriverVehicles.
     * @example
     * // Update many DriverVehicles
     * const driverVehicle = await prisma.driverVehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DriverVehicles and only return the `Id`
     * const driverVehicleWithIdOnly = await prisma.driverVehicle.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverVehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverVehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DriverVehicle.
     * @param {DriverVehicleUpsertArgs} args - Arguments to update or create a DriverVehicle.
     * @example
     * // Update or create a DriverVehicle
     * const driverVehicle = await prisma.driverVehicle.upsert({
     *   create: {
     *     // ... data to create a DriverVehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverVehicle we want to update
     *   }
     * })
     */
    upsert<T extends DriverVehicleUpsertArgs>(args: SelectSubset<T, DriverVehicleUpsertArgs<ExtArgs>>): Prisma__DriverVehicleClient<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DriverVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleCountArgs} args - Arguments to filter DriverVehicles to count.
     * @example
     * // Count the number of DriverVehicles
     * const count = await prisma.driverVehicle.count({
     *   where: {
     *     // ... the filter for the DriverVehicles we want to count
     *   }
     * })
    **/
    count<T extends DriverVehicleCountArgs>(
      args?: Subset<T, DriverVehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverVehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverVehicleAggregateArgs>(args: Subset<T, DriverVehicleAggregateArgs>): Prisma.PrismaPromise<GetDriverVehicleAggregateType<T>>

    /**
     * Group by DriverVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverVehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverVehicleGroupByArgs['orderBy'] }
        : { orderBy?: DriverVehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverVehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverVehicle model
   */
  readonly fields: DriverVehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverVehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverVehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverVehicle model
   */
  interface DriverVehicleFieldRefs {
    readonly Id: FieldRef<"DriverVehicle", 'Int'>
    readonly DriverId: FieldRef<"DriverVehicle", 'Int'>
    readonly VehicleId: FieldRef<"DriverVehicle", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DriverVehicle findUnique
   */
  export type DriverVehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicle to fetch.
     */
    where: DriverVehicleWhereUniqueInput
  }

  /**
   * DriverVehicle findUniqueOrThrow
   */
  export type DriverVehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicle to fetch.
     */
    where: DriverVehicleWhereUniqueInput
  }

  /**
   * DriverVehicle findFirst
   */
  export type DriverVehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicle to fetch.
     */
    where?: DriverVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicles to fetch.
     */
    orderBy?: DriverVehicleOrderByWithRelationInput | DriverVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverVehicles.
     */
    cursor?: DriverVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverVehicles.
     */
    distinct?: DriverVehicleScalarFieldEnum | DriverVehicleScalarFieldEnum[]
  }

  /**
   * DriverVehicle findFirstOrThrow
   */
  export type DriverVehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicle to fetch.
     */
    where?: DriverVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicles to fetch.
     */
    orderBy?: DriverVehicleOrderByWithRelationInput | DriverVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverVehicles.
     */
    cursor?: DriverVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverVehicles.
     */
    distinct?: DriverVehicleScalarFieldEnum | DriverVehicleScalarFieldEnum[]
  }

  /**
   * DriverVehicle findMany
   */
  export type DriverVehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicles to fetch.
     */
    where?: DriverVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicles to fetch.
     */
    orderBy?: DriverVehicleOrderByWithRelationInput | DriverVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverVehicles.
     */
    cursor?: DriverVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicles.
     */
    skip?: number
    distinct?: DriverVehicleScalarFieldEnum | DriverVehicleScalarFieldEnum[]
  }

  /**
   * DriverVehicle create
   */
  export type DriverVehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverVehicle.
     */
    data: XOR<DriverVehicleCreateInput, DriverVehicleUncheckedCreateInput>
  }

  /**
   * DriverVehicle createMany
   */
  export type DriverVehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverVehicles.
     */
    data: DriverVehicleCreateManyInput | DriverVehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverVehicle createManyAndReturn
   */
  export type DriverVehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * The data used to create many DriverVehicles.
     */
    data: DriverVehicleCreateManyInput | DriverVehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverVehicle update
   */
  export type DriverVehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverVehicle.
     */
    data: XOR<DriverVehicleUpdateInput, DriverVehicleUncheckedUpdateInput>
    /**
     * Choose, which DriverVehicle to update.
     */
    where: DriverVehicleWhereUniqueInput
  }

  /**
   * DriverVehicle updateMany
   */
  export type DriverVehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverVehicles.
     */
    data: XOR<DriverVehicleUpdateManyMutationInput, DriverVehicleUncheckedUpdateManyInput>
    /**
     * Filter which DriverVehicles to update
     */
    where?: DriverVehicleWhereInput
    /**
     * Limit how many DriverVehicles to update.
     */
    limit?: number
  }

  /**
   * DriverVehicle updateManyAndReturn
   */
  export type DriverVehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * The data used to update DriverVehicles.
     */
    data: XOR<DriverVehicleUpdateManyMutationInput, DriverVehicleUncheckedUpdateManyInput>
    /**
     * Filter which DriverVehicles to update
     */
    where?: DriverVehicleWhereInput
    /**
     * Limit how many DriverVehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverVehicle upsert
   */
  export type DriverVehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverVehicle to update in case it exists.
     */
    where: DriverVehicleWhereUniqueInput
    /**
     * In case the DriverVehicle found by the `where` argument doesn't exist, create a new DriverVehicle with this data.
     */
    create: XOR<DriverVehicleCreateInput, DriverVehicleUncheckedCreateInput>
    /**
     * In case the DriverVehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverVehicleUpdateInput, DriverVehicleUncheckedUpdateInput>
  }

  /**
   * DriverVehicle delete
   */
  export type DriverVehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    /**
     * Filter which DriverVehicle to delete.
     */
    where: DriverVehicleWhereUniqueInput
  }

  /**
   * DriverVehicle deleteMany
   */
  export type DriverVehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverVehicles to delete
     */
    where?: DriverVehicleWhereInput
    /**
     * Limit how many DriverVehicles to delete.
     */
    limit?: number
  }

  /**
   * DriverVehicle without action
   */
  export type DriverVehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
  }


  /**
   * Model DriverWallet
   */

  export type AggregateDriverWallet = {
    _count: DriverWalletCountAggregateOutputType | null
    _avg: DriverWalletAvgAggregateOutputType | null
    _sum: DriverWalletSumAggregateOutputType | null
    _min: DriverWalletMinAggregateOutputType | null
    _max: DriverWalletMaxAggregateOutputType | null
  }

  export type DriverWalletAvgAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    Amount: number | null
  }

  export type DriverWalletSumAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    Amount: number | null
  }

  export type DriverWalletMinAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    Amount: number | null
    LastUpdated: Date | null
  }

  export type DriverWalletMaxAggregateOutputType = {
    Id: number | null
    DriverId: number | null
    Amount: number | null
    LastUpdated: Date | null
  }

  export type DriverWalletCountAggregateOutputType = {
    Id: number
    DriverId: number
    Amount: number
    LastUpdated: number
    _all: number
  }


  export type DriverWalletAvgAggregateInputType = {
    Id?: true
    DriverId?: true
    Amount?: true
  }

  export type DriverWalletSumAggregateInputType = {
    Id?: true
    DriverId?: true
    Amount?: true
  }

  export type DriverWalletMinAggregateInputType = {
    Id?: true
    DriverId?: true
    Amount?: true
    LastUpdated?: true
  }

  export type DriverWalletMaxAggregateInputType = {
    Id?: true
    DriverId?: true
    Amount?: true
    LastUpdated?: true
  }

  export type DriverWalletCountAggregateInputType = {
    Id?: true
    DriverId?: true
    Amount?: true
    LastUpdated?: true
    _all?: true
  }

  export type DriverWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverWallet to aggregate.
     */
    where?: DriverWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverWallets to fetch.
     */
    orderBy?: DriverWalletOrderByWithRelationInput | DriverWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverWallets
    **/
    _count?: true | DriverWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverWalletMaxAggregateInputType
  }

  export type GetDriverWalletAggregateType<T extends DriverWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverWallet[P]>
      : GetScalarType<T[P], AggregateDriverWallet[P]>
  }




  export type DriverWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWalletWhereInput
    orderBy?: DriverWalletOrderByWithAggregationInput | DriverWalletOrderByWithAggregationInput[]
    by: DriverWalletScalarFieldEnum[] | DriverWalletScalarFieldEnum
    having?: DriverWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverWalletCountAggregateInputType | true
    _avg?: DriverWalletAvgAggregateInputType
    _sum?: DriverWalletSumAggregateInputType
    _min?: DriverWalletMinAggregateInputType
    _max?: DriverWalletMaxAggregateInputType
  }

  export type DriverWalletGroupByOutputType = {
    Id: number
    DriverId: number
    Amount: number
    LastUpdated: Date
    _count: DriverWalletCountAggregateOutputType | null
    _avg: DriverWalletAvgAggregateOutputType | null
    _sum: DriverWalletSumAggregateOutputType | null
    _min: DriverWalletMinAggregateOutputType | null
    _max: DriverWalletMaxAggregateOutputType | null
  }

  type GetDriverWalletGroupByPayload<T extends DriverWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverWalletGroupByOutputType[P]>
            : GetScalarType<T[P], DriverWalletGroupByOutputType[P]>
        }
      >
    >


  export type DriverWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DriverId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverWallet"]>

  export type DriverWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DriverId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverWallet"]>

  export type DriverWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DriverId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverWallet"]>

  export type DriverWalletSelectScalar = {
    Id?: boolean
    DriverId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
  }

  export type DriverWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "DriverId" | "Amount" | "LastUpdated", ExtArgs["result"]["driverWallet"]>
  export type DriverWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
  }
  export type DriverWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
  }
  export type DriverWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
  }

  export type $DriverWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverWallet"
    objects: {
      Driver: Prisma.$DriverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      DriverId: number
      Amount: number
      LastUpdated: Date
    }, ExtArgs["result"]["driverWallet"]>
    composites: {}
  }

  type DriverWalletGetPayload<S extends boolean | null | undefined | DriverWalletDefaultArgs> = $Result.GetResult<Prisma.$DriverWalletPayload, S>

  type DriverWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverWalletCountAggregateInputType | true
    }

  export interface DriverWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverWallet'], meta: { name: 'DriverWallet' } }
    /**
     * Find zero or one DriverWallet that matches the filter.
     * @param {DriverWalletFindUniqueArgs} args - Arguments to find a DriverWallet
     * @example
     * // Get one DriverWallet
     * const driverWallet = await prisma.driverWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverWalletFindUniqueArgs>(args: SelectSubset<T, DriverWalletFindUniqueArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DriverWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverWalletFindUniqueOrThrowArgs} args - Arguments to find a DriverWallet
     * @example
     * // Get one DriverWallet
     * const driverWallet = await prisma.driverWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverWalletFindFirstArgs} args - Arguments to find a DriverWallet
     * @example
     * // Get one DriverWallet
     * const driverWallet = await prisma.driverWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverWalletFindFirstArgs>(args?: SelectSubset<T, DriverWalletFindFirstArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverWalletFindFirstOrThrowArgs} args - Arguments to find a DriverWallet
     * @example
     * // Get one DriverWallet
     * const driverWallet = await prisma.driverWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DriverWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverWallets
     * const driverWallets = await prisma.driverWallet.findMany()
     * 
     * // Get first 10 DriverWallets
     * const driverWallets = await prisma.driverWallet.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const driverWalletWithIdOnly = await prisma.driverWallet.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends DriverWalletFindManyArgs>(args?: SelectSubset<T, DriverWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DriverWallet.
     * @param {DriverWalletCreateArgs} args - Arguments to create a DriverWallet.
     * @example
     * // Create one DriverWallet
     * const DriverWallet = await prisma.driverWallet.create({
     *   data: {
     *     // ... data to create a DriverWallet
     *   }
     * })
     * 
     */
    create<T extends DriverWalletCreateArgs>(args: SelectSubset<T, DriverWalletCreateArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DriverWallets.
     * @param {DriverWalletCreateManyArgs} args - Arguments to create many DriverWallets.
     * @example
     * // Create many DriverWallets
     * const driverWallet = await prisma.driverWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverWalletCreateManyArgs>(args?: SelectSubset<T, DriverWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriverWallets and returns the data saved in the database.
     * @param {DriverWalletCreateManyAndReturnArgs} args - Arguments to create many DriverWallets.
     * @example
     * // Create many DriverWallets
     * const driverWallet = await prisma.driverWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriverWallets and only return the `Id`
     * const driverWalletWithIdOnly = await prisma.driverWallet.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DriverWallet.
     * @param {DriverWalletDeleteArgs} args - Arguments to delete one DriverWallet.
     * @example
     * // Delete one DriverWallet
     * const DriverWallet = await prisma.driverWallet.delete({
     *   where: {
     *     // ... filter to delete one DriverWallet
     *   }
     * })
     * 
     */
    delete<T extends DriverWalletDeleteArgs>(args: SelectSubset<T, DriverWalletDeleteArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DriverWallet.
     * @param {DriverWalletUpdateArgs} args - Arguments to update one DriverWallet.
     * @example
     * // Update one DriverWallet
     * const driverWallet = await prisma.driverWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverWalletUpdateArgs>(args: SelectSubset<T, DriverWalletUpdateArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DriverWallets.
     * @param {DriverWalletDeleteManyArgs} args - Arguments to filter DriverWallets to delete.
     * @example
     * // Delete a few DriverWallets
     * const { count } = await prisma.driverWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverWalletDeleteManyArgs>(args?: SelectSubset<T, DriverWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverWallets
     * const driverWallet = await prisma.driverWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverWalletUpdateManyArgs>(args: SelectSubset<T, DriverWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverWallets and returns the data updated in the database.
     * @param {DriverWalletUpdateManyAndReturnArgs} args - Arguments to update many DriverWallets.
     * @example
     * // Update many DriverWallets
     * const driverWallet = await prisma.driverWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DriverWallets and only return the `Id`
     * const driverWalletWithIdOnly = await prisma.driverWallet.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DriverWallet.
     * @param {DriverWalletUpsertArgs} args - Arguments to update or create a DriverWallet.
     * @example
     * // Update or create a DriverWallet
     * const driverWallet = await prisma.driverWallet.upsert({
     *   create: {
     *     // ... data to create a DriverWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverWallet we want to update
     *   }
     * })
     */
    upsert<T extends DriverWalletUpsertArgs>(args: SelectSubset<T, DriverWalletUpsertArgs<ExtArgs>>): Prisma__DriverWalletClient<$Result.GetResult<Prisma.$DriverWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DriverWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverWalletCountArgs} args - Arguments to filter DriverWallets to count.
     * @example
     * // Count the number of DriverWallets
     * const count = await prisma.driverWallet.count({
     *   where: {
     *     // ... the filter for the DriverWallets we want to count
     *   }
     * })
    **/
    count<T extends DriverWalletCountArgs>(
      args?: Subset<T, DriverWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverWalletAggregateArgs>(args: Subset<T, DriverWalletAggregateArgs>): Prisma.PrismaPromise<GetDriverWalletAggregateType<T>>

    /**
     * Group by DriverWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverWalletGroupByArgs['orderBy'] }
        : { orderBy?: DriverWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverWallet model
   */
  readonly fields: DriverWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverWallet model
   */
  interface DriverWalletFieldRefs {
    readonly Id: FieldRef<"DriverWallet", 'Int'>
    readonly DriverId: FieldRef<"DriverWallet", 'Int'>
    readonly Amount: FieldRef<"DriverWallet", 'Int'>
    readonly LastUpdated: FieldRef<"DriverWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriverWallet findUnique
   */
  export type DriverWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * Filter, which DriverWallet to fetch.
     */
    where: DriverWalletWhereUniqueInput
  }

  /**
   * DriverWallet findUniqueOrThrow
   */
  export type DriverWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * Filter, which DriverWallet to fetch.
     */
    where: DriverWalletWhereUniqueInput
  }

  /**
   * DriverWallet findFirst
   */
  export type DriverWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * Filter, which DriverWallet to fetch.
     */
    where?: DriverWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverWallets to fetch.
     */
    orderBy?: DriverWalletOrderByWithRelationInput | DriverWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverWallets.
     */
    cursor?: DriverWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverWallets.
     */
    distinct?: DriverWalletScalarFieldEnum | DriverWalletScalarFieldEnum[]
  }

  /**
   * DriverWallet findFirstOrThrow
   */
  export type DriverWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * Filter, which DriverWallet to fetch.
     */
    where?: DriverWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverWallets to fetch.
     */
    orderBy?: DriverWalletOrderByWithRelationInput | DriverWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverWallets.
     */
    cursor?: DriverWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverWallets.
     */
    distinct?: DriverWalletScalarFieldEnum | DriverWalletScalarFieldEnum[]
  }

  /**
   * DriverWallet findMany
   */
  export type DriverWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * Filter, which DriverWallets to fetch.
     */
    where?: DriverWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverWallets to fetch.
     */
    orderBy?: DriverWalletOrderByWithRelationInput | DriverWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverWallets.
     */
    cursor?: DriverWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverWallets.
     */
    skip?: number
    distinct?: DriverWalletScalarFieldEnum | DriverWalletScalarFieldEnum[]
  }

  /**
   * DriverWallet create
   */
  export type DriverWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverWallet.
     */
    data: XOR<DriverWalletCreateInput, DriverWalletUncheckedCreateInput>
  }

  /**
   * DriverWallet createMany
   */
  export type DriverWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverWallets.
     */
    data: DriverWalletCreateManyInput | DriverWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverWallet createManyAndReturn
   */
  export type DriverWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * The data used to create many DriverWallets.
     */
    data: DriverWalletCreateManyInput | DriverWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverWallet update
   */
  export type DriverWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverWallet.
     */
    data: XOR<DriverWalletUpdateInput, DriverWalletUncheckedUpdateInput>
    /**
     * Choose, which DriverWallet to update.
     */
    where: DriverWalletWhereUniqueInput
  }

  /**
   * DriverWallet updateMany
   */
  export type DriverWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverWallets.
     */
    data: XOR<DriverWalletUpdateManyMutationInput, DriverWalletUncheckedUpdateManyInput>
    /**
     * Filter which DriverWallets to update
     */
    where?: DriverWalletWhereInput
    /**
     * Limit how many DriverWallets to update.
     */
    limit?: number
  }

  /**
   * DriverWallet updateManyAndReturn
   */
  export type DriverWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * The data used to update DriverWallets.
     */
    data: XOR<DriverWalletUpdateManyMutationInput, DriverWalletUncheckedUpdateManyInput>
    /**
     * Filter which DriverWallets to update
     */
    where?: DriverWalletWhereInput
    /**
     * Limit how many DriverWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverWallet upsert
   */
  export type DriverWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverWallet to update in case it exists.
     */
    where: DriverWalletWhereUniqueInput
    /**
     * In case the DriverWallet found by the `where` argument doesn't exist, create a new DriverWallet with this data.
     */
    create: XOR<DriverWalletCreateInput, DriverWalletUncheckedCreateInput>
    /**
     * In case the DriverWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverWalletUpdateInput, DriverWalletUncheckedUpdateInput>
  }

  /**
   * DriverWallet delete
   */
  export type DriverWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
    /**
     * Filter which DriverWallet to delete.
     */
    where: DriverWalletWhereUniqueInput
  }

  /**
   * DriverWallet deleteMany
   */
  export type DriverWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverWallets to delete
     */
    where?: DriverWalletWhereInput
    /**
     * Limit how many DriverWallets to delete.
     */
    limit?: number
  }

  /**
   * DriverWallet without action
   */
  export type DriverWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverWallet
     */
    select?: DriverWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverWallet
     */
    omit?: DriverWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverWalletInclude<ExtArgs> | null
  }


  /**
   * Model FareNegotiation
   */

  export type AggregateFareNegotiation = {
    _count: FareNegotiationCountAggregateOutputType | null
    _avg: FareNegotiationAvgAggregateOutputType | null
    _sum: FareNegotiationSumAggregateOutputType | null
    _min: FareNegotiationMinAggregateOutputType | null
    _max: FareNegotiationMaxAggregateOutputType | null
  }

  export type FareNegotiationAvgAggregateOutputType = {
    Id: number | null
    BookingId: number | null
    DriverId: number | null
    OwnerId: number | null
  }

  export type FareNegotiationSumAggregateOutputType = {
    Id: number | null
    BookingId: number | null
    DriverId: number | null
    OwnerId: number | null
  }

  export type FareNegotiationMinAggregateOutputType = {
    Id: number | null
    BookingId: number | null
    DriverId: number | null
    OwnerId: number | null
    NegotiatedFare: string | null
    NegotiatedTime: Date | null
  }

  export type FareNegotiationMaxAggregateOutputType = {
    Id: number | null
    BookingId: number | null
    DriverId: number | null
    OwnerId: number | null
    NegotiatedFare: string | null
    NegotiatedTime: Date | null
  }

  export type FareNegotiationCountAggregateOutputType = {
    Id: number
    BookingId: number
    DriverId: number
    OwnerId: number
    NegotiatedFare: number
    NegotiatedTime: number
    _all: number
  }


  export type FareNegotiationAvgAggregateInputType = {
    Id?: true
    BookingId?: true
    DriverId?: true
    OwnerId?: true
  }

  export type FareNegotiationSumAggregateInputType = {
    Id?: true
    BookingId?: true
    DriverId?: true
    OwnerId?: true
  }

  export type FareNegotiationMinAggregateInputType = {
    Id?: true
    BookingId?: true
    DriverId?: true
    OwnerId?: true
    NegotiatedFare?: true
    NegotiatedTime?: true
  }

  export type FareNegotiationMaxAggregateInputType = {
    Id?: true
    BookingId?: true
    DriverId?: true
    OwnerId?: true
    NegotiatedFare?: true
    NegotiatedTime?: true
  }

  export type FareNegotiationCountAggregateInputType = {
    Id?: true
    BookingId?: true
    DriverId?: true
    OwnerId?: true
    NegotiatedFare?: true
    NegotiatedTime?: true
    _all?: true
  }

  export type FareNegotiationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FareNegotiation to aggregate.
     */
    where?: FareNegotiationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareNegotiations to fetch.
     */
    orderBy?: FareNegotiationOrderByWithRelationInput | FareNegotiationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FareNegotiationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareNegotiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareNegotiations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FareNegotiations
    **/
    _count?: true | FareNegotiationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FareNegotiationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FareNegotiationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FareNegotiationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FareNegotiationMaxAggregateInputType
  }

  export type GetFareNegotiationAggregateType<T extends FareNegotiationAggregateArgs> = {
        [P in keyof T & keyof AggregateFareNegotiation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFareNegotiation[P]>
      : GetScalarType<T[P], AggregateFareNegotiation[P]>
  }




  export type FareNegotiationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareNegotiationWhereInput
    orderBy?: FareNegotiationOrderByWithAggregationInput | FareNegotiationOrderByWithAggregationInput[]
    by: FareNegotiationScalarFieldEnum[] | FareNegotiationScalarFieldEnum
    having?: FareNegotiationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FareNegotiationCountAggregateInputType | true
    _avg?: FareNegotiationAvgAggregateInputType
    _sum?: FareNegotiationSumAggregateInputType
    _min?: FareNegotiationMinAggregateInputType
    _max?: FareNegotiationMaxAggregateInputType
  }

  export type FareNegotiationGroupByOutputType = {
    Id: number
    BookingId: number
    DriverId: number
    OwnerId: number
    NegotiatedFare: string
    NegotiatedTime: Date
    _count: FareNegotiationCountAggregateOutputType | null
    _avg: FareNegotiationAvgAggregateOutputType | null
    _sum: FareNegotiationSumAggregateOutputType | null
    _min: FareNegotiationMinAggregateOutputType | null
    _max: FareNegotiationMaxAggregateOutputType | null
  }

  type GetFareNegotiationGroupByPayload<T extends FareNegotiationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FareNegotiationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FareNegotiationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FareNegotiationGroupByOutputType[P]>
            : GetScalarType<T[P], FareNegotiationGroupByOutputType[P]>
        }
      >
    >


  export type FareNegotiationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    BookingId?: boolean
    DriverId?: boolean
    OwnerId?: boolean
    NegotiatedFare?: boolean
    NegotiatedTime?: boolean
    Bookings?: boolean | BookingsDefaultArgs<ExtArgs>
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fareNegotiation"]>

  export type FareNegotiationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    BookingId?: boolean
    DriverId?: boolean
    OwnerId?: boolean
    NegotiatedFare?: boolean
    NegotiatedTime?: boolean
    Bookings?: boolean | BookingsDefaultArgs<ExtArgs>
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fareNegotiation"]>

  export type FareNegotiationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    BookingId?: boolean
    DriverId?: boolean
    OwnerId?: boolean
    NegotiatedFare?: boolean
    NegotiatedTime?: boolean
    Bookings?: boolean | BookingsDefaultArgs<ExtArgs>
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fareNegotiation"]>

  export type FareNegotiationSelectScalar = {
    Id?: boolean
    BookingId?: boolean
    DriverId?: boolean
    OwnerId?: boolean
    NegotiatedFare?: boolean
    NegotiatedTime?: boolean
  }

  export type FareNegotiationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "BookingId" | "DriverId" | "OwnerId" | "NegotiatedFare" | "NegotiatedTime", ExtArgs["result"]["fareNegotiation"]>
  export type FareNegotiationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | BookingsDefaultArgs<ExtArgs>
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type FareNegotiationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | BookingsDefaultArgs<ExtArgs>
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type FareNegotiationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | BookingsDefaultArgs<ExtArgs>
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $FareNegotiationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FareNegotiation"
    objects: {
      Bookings: Prisma.$BookingsPayload<ExtArgs>
      Driver: Prisma.$DriverPayload<ExtArgs>
      Owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      BookingId: number
      DriverId: number
      OwnerId: number
      NegotiatedFare: string
      NegotiatedTime: Date
    }, ExtArgs["result"]["fareNegotiation"]>
    composites: {}
  }

  type FareNegotiationGetPayload<S extends boolean | null | undefined | FareNegotiationDefaultArgs> = $Result.GetResult<Prisma.$FareNegotiationPayload, S>

  type FareNegotiationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FareNegotiationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FareNegotiationCountAggregateInputType | true
    }

  export interface FareNegotiationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FareNegotiation'], meta: { name: 'FareNegotiation' } }
    /**
     * Find zero or one FareNegotiation that matches the filter.
     * @param {FareNegotiationFindUniqueArgs} args - Arguments to find a FareNegotiation
     * @example
     * // Get one FareNegotiation
     * const fareNegotiation = await prisma.fareNegotiation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FareNegotiationFindUniqueArgs>(args: SelectSubset<T, FareNegotiationFindUniqueArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FareNegotiation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FareNegotiationFindUniqueOrThrowArgs} args - Arguments to find a FareNegotiation
     * @example
     * // Get one FareNegotiation
     * const fareNegotiation = await prisma.fareNegotiation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FareNegotiationFindUniqueOrThrowArgs>(args: SelectSubset<T, FareNegotiationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FareNegotiation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareNegotiationFindFirstArgs} args - Arguments to find a FareNegotiation
     * @example
     * // Get one FareNegotiation
     * const fareNegotiation = await prisma.fareNegotiation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FareNegotiationFindFirstArgs>(args?: SelectSubset<T, FareNegotiationFindFirstArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FareNegotiation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareNegotiationFindFirstOrThrowArgs} args - Arguments to find a FareNegotiation
     * @example
     * // Get one FareNegotiation
     * const fareNegotiation = await prisma.fareNegotiation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FareNegotiationFindFirstOrThrowArgs>(args?: SelectSubset<T, FareNegotiationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FareNegotiations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareNegotiationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FareNegotiations
     * const fareNegotiations = await prisma.fareNegotiation.findMany()
     * 
     * // Get first 10 FareNegotiations
     * const fareNegotiations = await prisma.fareNegotiation.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const fareNegotiationWithIdOnly = await prisma.fareNegotiation.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends FareNegotiationFindManyArgs>(args?: SelectSubset<T, FareNegotiationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FareNegotiation.
     * @param {FareNegotiationCreateArgs} args - Arguments to create a FareNegotiation.
     * @example
     * // Create one FareNegotiation
     * const FareNegotiation = await prisma.fareNegotiation.create({
     *   data: {
     *     // ... data to create a FareNegotiation
     *   }
     * })
     * 
     */
    create<T extends FareNegotiationCreateArgs>(args: SelectSubset<T, FareNegotiationCreateArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FareNegotiations.
     * @param {FareNegotiationCreateManyArgs} args - Arguments to create many FareNegotiations.
     * @example
     * // Create many FareNegotiations
     * const fareNegotiation = await prisma.fareNegotiation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FareNegotiationCreateManyArgs>(args?: SelectSubset<T, FareNegotiationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FareNegotiations and returns the data saved in the database.
     * @param {FareNegotiationCreateManyAndReturnArgs} args - Arguments to create many FareNegotiations.
     * @example
     * // Create many FareNegotiations
     * const fareNegotiation = await prisma.fareNegotiation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FareNegotiations and only return the `Id`
     * const fareNegotiationWithIdOnly = await prisma.fareNegotiation.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FareNegotiationCreateManyAndReturnArgs>(args?: SelectSubset<T, FareNegotiationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FareNegotiation.
     * @param {FareNegotiationDeleteArgs} args - Arguments to delete one FareNegotiation.
     * @example
     * // Delete one FareNegotiation
     * const FareNegotiation = await prisma.fareNegotiation.delete({
     *   where: {
     *     // ... filter to delete one FareNegotiation
     *   }
     * })
     * 
     */
    delete<T extends FareNegotiationDeleteArgs>(args: SelectSubset<T, FareNegotiationDeleteArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FareNegotiation.
     * @param {FareNegotiationUpdateArgs} args - Arguments to update one FareNegotiation.
     * @example
     * // Update one FareNegotiation
     * const fareNegotiation = await prisma.fareNegotiation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FareNegotiationUpdateArgs>(args: SelectSubset<T, FareNegotiationUpdateArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FareNegotiations.
     * @param {FareNegotiationDeleteManyArgs} args - Arguments to filter FareNegotiations to delete.
     * @example
     * // Delete a few FareNegotiations
     * const { count } = await prisma.fareNegotiation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FareNegotiationDeleteManyArgs>(args?: SelectSubset<T, FareNegotiationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FareNegotiations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareNegotiationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FareNegotiations
     * const fareNegotiation = await prisma.fareNegotiation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FareNegotiationUpdateManyArgs>(args: SelectSubset<T, FareNegotiationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FareNegotiations and returns the data updated in the database.
     * @param {FareNegotiationUpdateManyAndReturnArgs} args - Arguments to update many FareNegotiations.
     * @example
     * // Update many FareNegotiations
     * const fareNegotiation = await prisma.fareNegotiation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FareNegotiations and only return the `Id`
     * const fareNegotiationWithIdOnly = await prisma.fareNegotiation.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FareNegotiationUpdateManyAndReturnArgs>(args: SelectSubset<T, FareNegotiationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FareNegotiation.
     * @param {FareNegotiationUpsertArgs} args - Arguments to update or create a FareNegotiation.
     * @example
     * // Update or create a FareNegotiation
     * const fareNegotiation = await prisma.fareNegotiation.upsert({
     *   create: {
     *     // ... data to create a FareNegotiation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FareNegotiation we want to update
     *   }
     * })
     */
    upsert<T extends FareNegotiationUpsertArgs>(args: SelectSubset<T, FareNegotiationUpsertArgs<ExtArgs>>): Prisma__FareNegotiationClient<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FareNegotiations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareNegotiationCountArgs} args - Arguments to filter FareNegotiations to count.
     * @example
     * // Count the number of FareNegotiations
     * const count = await prisma.fareNegotiation.count({
     *   where: {
     *     // ... the filter for the FareNegotiations we want to count
     *   }
     * })
    **/
    count<T extends FareNegotiationCountArgs>(
      args?: Subset<T, FareNegotiationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FareNegotiationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FareNegotiation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareNegotiationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FareNegotiationAggregateArgs>(args: Subset<T, FareNegotiationAggregateArgs>): Prisma.PrismaPromise<GetFareNegotiationAggregateType<T>>

    /**
     * Group by FareNegotiation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareNegotiationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FareNegotiationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FareNegotiationGroupByArgs['orderBy'] }
        : { orderBy?: FareNegotiationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FareNegotiationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFareNegotiationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FareNegotiation model
   */
  readonly fields: FareNegotiationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FareNegotiation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FareNegotiationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bookings<T extends BookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingsDefaultArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FareNegotiation model
   */
  interface FareNegotiationFieldRefs {
    readonly Id: FieldRef<"FareNegotiation", 'Int'>
    readonly BookingId: FieldRef<"FareNegotiation", 'Int'>
    readonly DriverId: FieldRef<"FareNegotiation", 'Int'>
    readonly OwnerId: FieldRef<"FareNegotiation", 'Int'>
    readonly NegotiatedFare: FieldRef<"FareNegotiation", 'String'>
    readonly NegotiatedTime: FieldRef<"FareNegotiation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FareNegotiation findUnique
   */
  export type FareNegotiationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * Filter, which FareNegotiation to fetch.
     */
    where: FareNegotiationWhereUniqueInput
  }

  /**
   * FareNegotiation findUniqueOrThrow
   */
  export type FareNegotiationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * Filter, which FareNegotiation to fetch.
     */
    where: FareNegotiationWhereUniqueInput
  }

  /**
   * FareNegotiation findFirst
   */
  export type FareNegotiationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * Filter, which FareNegotiation to fetch.
     */
    where?: FareNegotiationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareNegotiations to fetch.
     */
    orderBy?: FareNegotiationOrderByWithRelationInput | FareNegotiationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FareNegotiations.
     */
    cursor?: FareNegotiationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareNegotiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareNegotiations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FareNegotiations.
     */
    distinct?: FareNegotiationScalarFieldEnum | FareNegotiationScalarFieldEnum[]
  }

  /**
   * FareNegotiation findFirstOrThrow
   */
  export type FareNegotiationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * Filter, which FareNegotiation to fetch.
     */
    where?: FareNegotiationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareNegotiations to fetch.
     */
    orderBy?: FareNegotiationOrderByWithRelationInput | FareNegotiationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FareNegotiations.
     */
    cursor?: FareNegotiationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareNegotiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareNegotiations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FareNegotiations.
     */
    distinct?: FareNegotiationScalarFieldEnum | FareNegotiationScalarFieldEnum[]
  }

  /**
   * FareNegotiation findMany
   */
  export type FareNegotiationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * Filter, which FareNegotiations to fetch.
     */
    where?: FareNegotiationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareNegotiations to fetch.
     */
    orderBy?: FareNegotiationOrderByWithRelationInput | FareNegotiationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FareNegotiations.
     */
    cursor?: FareNegotiationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareNegotiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareNegotiations.
     */
    skip?: number
    distinct?: FareNegotiationScalarFieldEnum | FareNegotiationScalarFieldEnum[]
  }

  /**
   * FareNegotiation create
   */
  export type FareNegotiationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * The data needed to create a FareNegotiation.
     */
    data: XOR<FareNegotiationCreateInput, FareNegotiationUncheckedCreateInput>
  }

  /**
   * FareNegotiation createMany
   */
  export type FareNegotiationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FareNegotiations.
     */
    data: FareNegotiationCreateManyInput | FareNegotiationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FareNegotiation createManyAndReturn
   */
  export type FareNegotiationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * The data used to create many FareNegotiations.
     */
    data: FareNegotiationCreateManyInput | FareNegotiationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FareNegotiation update
   */
  export type FareNegotiationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * The data needed to update a FareNegotiation.
     */
    data: XOR<FareNegotiationUpdateInput, FareNegotiationUncheckedUpdateInput>
    /**
     * Choose, which FareNegotiation to update.
     */
    where: FareNegotiationWhereUniqueInput
  }

  /**
   * FareNegotiation updateMany
   */
  export type FareNegotiationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FareNegotiations.
     */
    data: XOR<FareNegotiationUpdateManyMutationInput, FareNegotiationUncheckedUpdateManyInput>
    /**
     * Filter which FareNegotiations to update
     */
    where?: FareNegotiationWhereInput
    /**
     * Limit how many FareNegotiations to update.
     */
    limit?: number
  }

  /**
   * FareNegotiation updateManyAndReturn
   */
  export type FareNegotiationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * The data used to update FareNegotiations.
     */
    data: XOR<FareNegotiationUpdateManyMutationInput, FareNegotiationUncheckedUpdateManyInput>
    /**
     * Filter which FareNegotiations to update
     */
    where?: FareNegotiationWhereInput
    /**
     * Limit how many FareNegotiations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FareNegotiation upsert
   */
  export type FareNegotiationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * The filter to search for the FareNegotiation to update in case it exists.
     */
    where: FareNegotiationWhereUniqueInput
    /**
     * In case the FareNegotiation found by the `where` argument doesn't exist, create a new FareNegotiation with this data.
     */
    create: XOR<FareNegotiationCreateInput, FareNegotiationUncheckedCreateInput>
    /**
     * In case the FareNegotiation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FareNegotiationUpdateInput, FareNegotiationUncheckedUpdateInput>
  }

  /**
   * FareNegotiation delete
   */
  export type FareNegotiationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    /**
     * Filter which FareNegotiation to delete.
     */
    where: FareNegotiationWhereUniqueInput
  }

  /**
   * FareNegotiation deleteMany
   */
  export type FareNegotiationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FareNegotiations to delete
     */
    where?: FareNegotiationWhereInput
    /**
     * Limit how many FareNegotiations to delete.
     */
    limit?: number
  }

  /**
   * FareNegotiation without action
   */
  export type FareNegotiationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
  }


  /**
   * Model Owner
   */

  export type AggregateOwner = {
    _count: OwnerCountAggregateOutputType | null
    _avg: OwnerAvgAggregateOutputType | null
    _sum: OwnerSumAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  export type OwnerAvgAggregateOutputType = {
    Id: number | null
  }

  export type OwnerSumAggregateOutputType = {
    Id: number | null
  }

  export type OwnerMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    Password: string | null
    MobileNumber: string | null
    DOB: Date | null
    Email: string | null
    Gender: $Enums.Gender | null
    AdhaarCardNumber: string | null
    FrontSideAdhaarImage: string | null
    BackSideAdhaarImage: string | null
    PanNumber: string | null
    PanImage: string | null
    LastLoggedIn: Date | null
    CreatedDate: Date | null
  }

  export type OwnerMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    Password: string | null
    MobileNumber: string | null
    DOB: Date | null
    Email: string | null
    Gender: $Enums.Gender | null
    AdhaarCardNumber: string | null
    FrontSideAdhaarImage: string | null
    BackSideAdhaarImage: string | null
    PanNumber: string | null
    PanImage: string | null
    LastLoggedIn: Date | null
    CreatedDate: Date | null
  }

  export type OwnerCountAggregateOutputType = {
    Id: number
    Name: number
    Password: number
    MobileNumber: number
    DOB: number
    Email: number
    Gender: number
    AdhaarCardNumber: number
    FrontSideAdhaarImage: number
    BackSideAdhaarImage: number
    PanNumber: number
    PanImage: number
    LastLoggedIn: number
    CreatedDate: number
    _all: number
  }


  export type OwnerAvgAggregateInputType = {
    Id?: true
  }

  export type OwnerSumAggregateInputType = {
    Id?: true
  }

  export type OwnerMinAggregateInputType = {
    Id?: true
    Name?: true
    Password?: true
    MobileNumber?: true
    DOB?: true
    Email?: true
    Gender?: true
    AdhaarCardNumber?: true
    FrontSideAdhaarImage?: true
    BackSideAdhaarImage?: true
    PanNumber?: true
    PanImage?: true
    LastLoggedIn?: true
    CreatedDate?: true
  }

  export type OwnerMaxAggregateInputType = {
    Id?: true
    Name?: true
    Password?: true
    MobileNumber?: true
    DOB?: true
    Email?: true
    Gender?: true
    AdhaarCardNumber?: true
    FrontSideAdhaarImage?: true
    BackSideAdhaarImage?: true
    PanNumber?: true
    PanImage?: true
    LastLoggedIn?: true
    CreatedDate?: true
  }

  export type OwnerCountAggregateInputType = {
    Id?: true
    Name?: true
    Password?: true
    MobileNumber?: true
    DOB?: true
    Email?: true
    Gender?: true
    AdhaarCardNumber?: true
    FrontSideAdhaarImage?: true
    BackSideAdhaarImage?: true
    PanNumber?: true
    PanImage?: true
    LastLoggedIn?: true
    CreatedDate?: true
    _all?: true
  }

  export type OwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owner to aggregate.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Owners
    **/
    _count?: true | OwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerMaxAggregateInputType
  }

  export type GetOwnerAggregateType<T extends OwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwner[P]>
      : GetScalarType<T[P], AggregateOwner[P]>
  }




  export type OwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithAggregationInput | OwnerOrderByWithAggregationInput[]
    by: OwnerScalarFieldEnum[] | OwnerScalarFieldEnum
    having?: OwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerCountAggregateInputType | true
    _avg?: OwnerAvgAggregateInputType
    _sum?: OwnerSumAggregateInputType
    _min?: OwnerMinAggregateInputType
    _max?: OwnerMaxAggregateInputType
  }

  export type OwnerGroupByOutputType = {
    Id: number
    Name: string
    Password: string
    MobileNumber: string
    DOB: Date | null
    Email: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber: string | null
    FrontSideAdhaarImage: string | null
    BackSideAdhaarImage: string | null
    PanNumber: string | null
    PanImage: string | null
    LastLoggedIn: Date
    CreatedDate: Date
    _count: OwnerCountAggregateOutputType | null
    _avg: OwnerAvgAggregateOutputType | null
    _sum: OwnerSumAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  type GetOwnerGroupByPayload<T extends OwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerGroupByOutputType[P]>
        }
      >
    >


  export type OwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    Email?: boolean
    Gender?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
    FareNegotiation?: boolean | Owner$FareNegotiationArgs<ExtArgs>
    OwnerDriver?: boolean | Owner$OwnerDriverArgs<ExtArgs>
    OwnerVehicle?: boolean | Owner$OwnerVehicleArgs<ExtArgs>
    OwnerWallet?: boolean | Owner$OwnerWalletArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    Email?: boolean
    Gender?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    Email?: boolean
    Gender?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectScalar = {
    Id?: boolean
    Name?: boolean
    Password?: boolean
    MobileNumber?: boolean
    DOB?: boolean
    Email?: boolean
    Gender?: boolean
    AdhaarCardNumber?: boolean
    FrontSideAdhaarImage?: boolean
    BackSideAdhaarImage?: boolean
    PanNumber?: boolean
    PanImage?: boolean
    LastLoggedIn?: boolean
    CreatedDate?: boolean
  }

  export type OwnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Name" | "Password" | "MobileNumber" | "DOB" | "Email" | "Gender" | "AdhaarCardNumber" | "FrontSideAdhaarImage" | "BackSideAdhaarImage" | "PanNumber" | "PanImage" | "LastLoggedIn" | "CreatedDate", ExtArgs["result"]["owner"]>
  export type OwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FareNegotiation?: boolean | Owner$FareNegotiationArgs<ExtArgs>
    OwnerDriver?: boolean | Owner$OwnerDriverArgs<ExtArgs>
    OwnerVehicle?: boolean | Owner$OwnerVehicleArgs<ExtArgs>
    OwnerWallet?: boolean | Owner$OwnerWalletArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OwnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Owner"
    objects: {
      FareNegotiation: Prisma.$FareNegotiationPayload<ExtArgs>[]
      OwnerDriver: Prisma.$OwnerDriverPayload<ExtArgs>[]
      OwnerVehicle: Prisma.$OwnerVehiclePayload<ExtArgs>[]
      OwnerWallet: Prisma.$OwnerWalletPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Name: string
      Password: string
      MobileNumber: string
      DOB: Date | null
      Email: string | null
      Gender: $Enums.Gender
      AdhaarCardNumber: string | null
      FrontSideAdhaarImage: string | null
      BackSideAdhaarImage: string | null
      PanNumber: string | null
      PanImage: string | null
      LastLoggedIn: Date
      CreatedDate: Date
    }, ExtArgs["result"]["owner"]>
    composites: {}
  }

  type OwnerGetPayload<S extends boolean | null | undefined | OwnerDefaultArgs> = $Result.GetResult<Prisma.$OwnerPayload, S>

  type OwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnerCountAggregateInputType | true
    }

  export interface OwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Owner'], meta: { name: 'Owner' } }
    /**
     * Find zero or one Owner that matches the filter.
     * @param {OwnerFindUniqueArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerFindUniqueArgs>(args: SelectSubset<T, OwnerFindUniqueArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Owner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnerFindUniqueOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerFindFirstArgs>(args?: SelectSubset<T, OwnerFindFirstArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners
     * const owners = await prisma.owner.findMany()
     * 
     * // Get first 10 Owners
     * const owners = await prisma.owner.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const ownerWithIdOnly = await prisma.owner.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends OwnerFindManyArgs>(args?: SelectSubset<T, OwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Owner.
     * @param {OwnerCreateArgs} args - Arguments to create a Owner.
     * @example
     * // Create one Owner
     * const Owner = await prisma.owner.create({
     *   data: {
     *     // ... data to create a Owner
     *   }
     * })
     * 
     */
    create<T extends OwnerCreateArgs>(args: SelectSubset<T, OwnerCreateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Owners.
     * @param {OwnerCreateManyArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerCreateManyArgs>(args?: SelectSubset<T, OwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Owners and returns the data saved in the database.
     * @param {OwnerCreateManyAndReturnArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Owners and only return the `Id`
     * const ownerWithIdOnly = await prisma.owner.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Owner.
     * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
     * @example
     * // Delete one Owner
     * const Owner = await prisma.owner.delete({
     *   where: {
     *     // ... filter to delete one Owner
     *   }
     * })
     * 
     */
    delete<T extends OwnerDeleteArgs>(args: SelectSubset<T, OwnerDeleteArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Owner.
     * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
     * @example
     * // Update one Owner
     * const owner = await prisma.owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerUpdateArgs>(args: SelectSubset<T, OwnerUpdateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Owners.
     * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
     * @example
     * // Delete a few Owners
     * const { count } = await prisma.owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDeleteManyArgs>(args?: SelectSubset<T, OwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerUpdateManyArgs>(args: SelectSubset<T, OwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners and returns the data updated in the database.
     * @param {OwnerUpdateManyAndReturnArgs} args - Arguments to update many Owners.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Owners and only return the `Id`
     * const ownerWithIdOnly = await prisma.owner.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnerUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Owner.
     * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
     * @example
     * // Update or create a Owner
     * const owner = await prisma.owner.upsert({
     *   create: {
     *     // ... data to create a Owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owner we want to update
     *   }
     * })
     */
    upsert<T extends OwnerUpsertArgs>(args: SelectSubset<T, OwnerUpsertArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCountArgs} args - Arguments to filter Owners to count.
     * @example
     * // Count the number of Owners
     * const count = await prisma.owner.count({
     *   where: {
     *     // ... the filter for the Owners we want to count
     *   }
     * })
    **/
    count<T extends OwnerCountArgs>(
      args?: Subset<T, OwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerAggregateArgs>(args: Subset<T, OwnerAggregateArgs>): Prisma.PrismaPromise<GetOwnerAggregateType<T>>

    /**
     * Group by Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerGroupByArgs['orderBy'] }
        : { orderBy?: OwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Owner model
   */
  readonly fields: OwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FareNegotiation<T extends Owner$FareNegotiationArgs<ExtArgs> = {}>(args?: Subset<T, Owner$FareNegotiationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareNegotiationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OwnerDriver<T extends Owner$OwnerDriverArgs<ExtArgs> = {}>(args?: Subset<T, Owner$OwnerDriverArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OwnerVehicle<T extends Owner$OwnerVehicleArgs<ExtArgs> = {}>(args?: Subset<T, Owner$OwnerVehicleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OwnerWallet<T extends Owner$OwnerWalletArgs<ExtArgs> = {}>(args?: Subset<T, Owner$OwnerWalletArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Owner model
   */
  interface OwnerFieldRefs {
    readonly Id: FieldRef<"Owner", 'Int'>
    readonly Name: FieldRef<"Owner", 'String'>
    readonly Password: FieldRef<"Owner", 'String'>
    readonly MobileNumber: FieldRef<"Owner", 'String'>
    readonly DOB: FieldRef<"Owner", 'DateTime'>
    readonly Email: FieldRef<"Owner", 'String'>
    readonly Gender: FieldRef<"Owner", 'Gender'>
    readonly AdhaarCardNumber: FieldRef<"Owner", 'String'>
    readonly FrontSideAdhaarImage: FieldRef<"Owner", 'String'>
    readonly BackSideAdhaarImage: FieldRef<"Owner", 'String'>
    readonly PanNumber: FieldRef<"Owner", 'String'>
    readonly PanImage: FieldRef<"Owner", 'String'>
    readonly LastLoggedIn: FieldRef<"Owner", 'DateTime'>
    readonly CreatedDate: FieldRef<"Owner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Owner findUnique
   */
  export type OwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findUniqueOrThrow
   */
  export type OwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findFirst
   */
  export type OwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findFirstOrThrow
   */
  export type OwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findMany
   */
  export type OwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owners to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner create
   */
  export type OwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Owner.
     */
    data: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
  }

  /**
   * Owner createMany
   */
  export type OwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner createManyAndReturn
   */
  export type OwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner update
   */
  export type OwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Owner.
     */
    data: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
    /**
     * Choose, which Owner to update.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner updateMany
   */
  export type OwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
    /**
     * Limit how many Owners to update.
     */
    limit?: number
  }

  /**
   * Owner updateManyAndReturn
   */
  export type OwnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
    /**
     * Limit how many Owners to update.
     */
    limit?: number
  }

  /**
   * Owner upsert
   */
  export type OwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Owner to update in case it exists.
     */
    where: OwnerWhereUniqueInput
    /**
     * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
     */
    create: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
    /**
     * In case the Owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
  }

  /**
   * Owner delete
   */
  export type OwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter which Owner to delete.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner deleteMany
   */
  export type OwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners to delete
     */
    where?: OwnerWhereInput
    /**
     * Limit how many Owners to delete.
     */
    limit?: number
  }

  /**
   * Owner.FareNegotiation
   */
  export type Owner$FareNegotiationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareNegotiation
     */
    select?: FareNegotiationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareNegotiation
     */
    omit?: FareNegotiationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareNegotiationInclude<ExtArgs> | null
    where?: FareNegotiationWhereInput
    orderBy?: FareNegotiationOrderByWithRelationInput | FareNegotiationOrderByWithRelationInput[]
    cursor?: FareNegotiationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareNegotiationScalarFieldEnum | FareNegotiationScalarFieldEnum[]
  }

  /**
   * Owner.OwnerDriver
   */
  export type Owner$OwnerDriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    where?: OwnerDriverWhereInput
    orderBy?: OwnerDriverOrderByWithRelationInput | OwnerDriverOrderByWithRelationInput[]
    cursor?: OwnerDriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerDriverScalarFieldEnum | OwnerDriverScalarFieldEnum[]
  }

  /**
   * Owner.OwnerVehicle
   */
  export type Owner$OwnerVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    where?: OwnerVehicleWhereInput
    orderBy?: OwnerVehicleOrderByWithRelationInput | OwnerVehicleOrderByWithRelationInput[]
    cursor?: OwnerVehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerVehicleScalarFieldEnum | OwnerVehicleScalarFieldEnum[]
  }

  /**
   * Owner.OwnerWallet
   */
  export type Owner$OwnerWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    where?: OwnerWalletWhereInput
  }

  /**
   * Owner without action
   */
  export type OwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Owner
     */
    omit?: OwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
  }


  /**
   * Model OwnerDriver
   */

  export type AggregateOwnerDriver = {
    _count: OwnerDriverCountAggregateOutputType | null
    _avg: OwnerDriverAvgAggregateOutputType | null
    _sum: OwnerDriverSumAggregateOutputType | null
    _min: OwnerDriverMinAggregateOutputType | null
    _max: OwnerDriverMaxAggregateOutputType | null
  }

  export type OwnerDriverAvgAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    DriverId: number | null
  }

  export type OwnerDriverSumAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    DriverId: number | null
  }

  export type OwnerDriverMinAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    DriverId: number | null
  }

  export type OwnerDriverMaxAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    DriverId: number | null
  }

  export type OwnerDriverCountAggregateOutputType = {
    Id: number
    OwnerId: number
    DriverId: number
    _all: number
  }


  export type OwnerDriverAvgAggregateInputType = {
    Id?: true
    OwnerId?: true
    DriverId?: true
  }

  export type OwnerDriverSumAggregateInputType = {
    Id?: true
    OwnerId?: true
    DriverId?: true
  }

  export type OwnerDriverMinAggregateInputType = {
    Id?: true
    OwnerId?: true
    DriverId?: true
  }

  export type OwnerDriverMaxAggregateInputType = {
    Id?: true
    OwnerId?: true
    DriverId?: true
  }

  export type OwnerDriverCountAggregateInputType = {
    Id?: true
    OwnerId?: true
    DriverId?: true
    _all?: true
  }

  export type OwnerDriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDriver to aggregate.
     */
    where?: OwnerDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDrivers to fetch.
     */
    orderBy?: OwnerDriverOrderByWithRelationInput | OwnerDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDrivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerDrivers
    **/
    _count?: true | OwnerDriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerDriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerDriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerDriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerDriverMaxAggregateInputType
  }

  export type GetOwnerDriverAggregateType<T extends OwnerDriverAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerDriver[P]>
      : GetScalarType<T[P], AggregateOwnerDriver[P]>
  }




  export type OwnerDriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDriverWhereInput
    orderBy?: OwnerDriverOrderByWithAggregationInput | OwnerDriverOrderByWithAggregationInput[]
    by: OwnerDriverScalarFieldEnum[] | OwnerDriverScalarFieldEnum
    having?: OwnerDriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerDriverCountAggregateInputType | true
    _avg?: OwnerDriverAvgAggregateInputType
    _sum?: OwnerDriverSumAggregateInputType
    _min?: OwnerDriverMinAggregateInputType
    _max?: OwnerDriverMaxAggregateInputType
  }

  export type OwnerDriverGroupByOutputType = {
    Id: number
    OwnerId: number
    DriverId: number
    _count: OwnerDriverCountAggregateOutputType | null
    _avg: OwnerDriverAvgAggregateOutputType | null
    _sum: OwnerDriverSumAggregateOutputType | null
    _min: OwnerDriverMinAggregateOutputType | null
    _max: OwnerDriverMaxAggregateOutputType | null
  }

  type GetOwnerDriverGroupByPayload<T extends OwnerDriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerDriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerDriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerDriverGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerDriverGroupByOutputType[P]>
        }
      >
    >


  export type OwnerDriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    DriverId?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDriver"]>

  export type OwnerDriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    DriverId?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDriver"]>

  export type OwnerDriverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    DriverId?: boolean
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDriver"]>

  export type OwnerDriverSelectScalar = {
    Id?: boolean
    OwnerId?: boolean
    DriverId?: boolean
  }

  export type OwnerDriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "OwnerId" | "DriverId", ExtArgs["result"]["ownerDriver"]>
  export type OwnerDriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type OwnerDriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type OwnerDriverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Driver?: boolean | DriverDefaultArgs<ExtArgs>
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $OwnerDriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerDriver"
    objects: {
      Driver: Prisma.$DriverPayload<ExtArgs>
      Owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      OwnerId: number
      DriverId: number
    }, ExtArgs["result"]["ownerDriver"]>
    composites: {}
  }

  type OwnerDriverGetPayload<S extends boolean | null | undefined | OwnerDriverDefaultArgs> = $Result.GetResult<Prisma.$OwnerDriverPayload, S>

  type OwnerDriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnerDriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnerDriverCountAggregateInputType | true
    }

  export interface OwnerDriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerDriver'], meta: { name: 'OwnerDriver' } }
    /**
     * Find zero or one OwnerDriver that matches the filter.
     * @param {OwnerDriverFindUniqueArgs} args - Arguments to find a OwnerDriver
     * @example
     * // Get one OwnerDriver
     * const ownerDriver = await prisma.ownerDriver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerDriverFindUniqueArgs>(args: SelectSubset<T, OwnerDriverFindUniqueArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OwnerDriver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnerDriverFindUniqueOrThrowArgs} args - Arguments to find a OwnerDriver
     * @example
     * // Get one OwnerDriver
     * const ownerDriver = await prisma.ownerDriver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerDriverFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerDriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerDriver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDriverFindFirstArgs} args - Arguments to find a OwnerDriver
     * @example
     * // Get one OwnerDriver
     * const ownerDriver = await prisma.ownerDriver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerDriverFindFirstArgs>(args?: SelectSubset<T, OwnerDriverFindFirstArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerDriver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDriverFindFirstOrThrowArgs} args - Arguments to find a OwnerDriver
     * @example
     * // Get one OwnerDriver
     * const ownerDriver = await prisma.ownerDriver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerDriverFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerDriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OwnerDrivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerDrivers
     * const ownerDrivers = await prisma.ownerDriver.findMany()
     * 
     * // Get first 10 OwnerDrivers
     * const ownerDrivers = await prisma.ownerDriver.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const ownerDriverWithIdOnly = await prisma.ownerDriver.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends OwnerDriverFindManyArgs>(args?: SelectSubset<T, OwnerDriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OwnerDriver.
     * @param {OwnerDriverCreateArgs} args - Arguments to create a OwnerDriver.
     * @example
     * // Create one OwnerDriver
     * const OwnerDriver = await prisma.ownerDriver.create({
     *   data: {
     *     // ... data to create a OwnerDriver
     *   }
     * })
     * 
     */
    create<T extends OwnerDriverCreateArgs>(args: SelectSubset<T, OwnerDriverCreateArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OwnerDrivers.
     * @param {OwnerDriverCreateManyArgs} args - Arguments to create many OwnerDrivers.
     * @example
     * // Create many OwnerDrivers
     * const ownerDriver = await prisma.ownerDriver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerDriverCreateManyArgs>(args?: SelectSubset<T, OwnerDriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnerDrivers and returns the data saved in the database.
     * @param {OwnerDriverCreateManyAndReturnArgs} args - Arguments to create many OwnerDrivers.
     * @example
     * // Create many OwnerDrivers
     * const ownerDriver = await prisma.ownerDriver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnerDrivers and only return the `Id`
     * const ownerDriverWithIdOnly = await prisma.ownerDriver.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerDriverCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerDriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OwnerDriver.
     * @param {OwnerDriverDeleteArgs} args - Arguments to delete one OwnerDriver.
     * @example
     * // Delete one OwnerDriver
     * const OwnerDriver = await prisma.ownerDriver.delete({
     *   where: {
     *     // ... filter to delete one OwnerDriver
     *   }
     * })
     * 
     */
    delete<T extends OwnerDriverDeleteArgs>(args: SelectSubset<T, OwnerDriverDeleteArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OwnerDriver.
     * @param {OwnerDriverUpdateArgs} args - Arguments to update one OwnerDriver.
     * @example
     * // Update one OwnerDriver
     * const ownerDriver = await prisma.ownerDriver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerDriverUpdateArgs>(args: SelectSubset<T, OwnerDriverUpdateArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OwnerDrivers.
     * @param {OwnerDriverDeleteManyArgs} args - Arguments to filter OwnerDrivers to delete.
     * @example
     * // Delete a few OwnerDrivers
     * const { count } = await prisma.ownerDriver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDriverDeleteManyArgs>(args?: SelectSubset<T, OwnerDriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerDrivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerDrivers
     * const ownerDriver = await prisma.ownerDriver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerDriverUpdateManyArgs>(args: SelectSubset<T, OwnerDriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerDrivers and returns the data updated in the database.
     * @param {OwnerDriverUpdateManyAndReturnArgs} args - Arguments to update many OwnerDrivers.
     * @example
     * // Update many OwnerDrivers
     * const ownerDriver = await prisma.ownerDriver.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OwnerDrivers and only return the `Id`
     * const ownerDriverWithIdOnly = await prisma.ownerDriver.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnerDriverUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnerDriverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OwnerDriver.
     * @param {OwnerDriverUpsertArgs} args - Arguments to update or create a OwnerDriver.
     * @example
     * // Update or create a OwnerDriver
     * const ownerDriver = await prisma.ownerDriver.upsert({
     *   create: {
     *     // ... data to create a OwnerDriver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerDriver we want to update
     *   }
     * })
     */
    upsert<T extends OwnerDriverUpsertArgs>(args: SelectSubset<T, OwnerDriverUpsertArgs<ExtArgs>>): Prisma__OwnerDriverClient<$Result.GetResult<Prisma.$OwnerDriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OwnerDrivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDriverCountArgs} args - Arguments to filter OwnerDrivers to count.
     * @example
     * // Count the number of OwnerDrivers
     * const count = await prisma.ownerDriver.count({
     *   where: {
     *     // ... the filter for the OwnerDrivers we want to count
     *   }
     * })
    **/
    count<T extends OwnerDriverCountArgs>(
      args?: Subset<T, OwnerDriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerDriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerDriver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerDriverAggregateArgs>(args: Subset<T, OwnerDriverAggregateArgs>): Prisma.PrismaPromise<GetOwnerDriverAggregateType<T>>

    /**
     * Group by OwnerDriver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerDriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerDriverGroupByArgs['orderBy'] }
        : { orderBy?: OwnerDriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerDriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerDriver model
   */
  readonly fields: OwnerDriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerDriver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerDriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerDriver model
   */
  interface OwnerDriverFieldRefs {
    readonly Id: FieldRef<"OwnerDriver", 'Int'>
    readonly OwnerId: FieldRef<"OwnerDriver", 'Int'>
    readonly DriverId: FieldRef<"OwnerDriver", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OwnerDriver findUnique
   */
  export type OwnerDriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDriver to fetch.
     */
    where: OwnerDriverWhereUniqueInput
  }

  /**
   * OwnerDriver findUniqueOrThrow
   */
  export type OwnerDriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDriver to fetch.
     */
    where: OwnerDriverWhereUniqueInput
  }

  /**
   * OwnerDriver findFirst
   */
  export type OwnerDriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDriver to fetch.
     */
    where?: OwnerDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDrivers to fetch.
     */
    orderBy?: OwnerDriverOrderByWithRelationInput | OwnerDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDrivers.
     */
    cursor?: OwnerDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDrivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDrivers.
     */
    distinct?: OwnerDriverScalarFieldEnum | OwnerDriverScalarFieldEnum[]
  }

  /**
   * OwnerDriver findFirstOrThrow
   */
  export type OwnerDriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDriver to fetch.
     */
    where?: OwnerDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDrivers to fetch.
     */
    orderBy?: OwnerDriverOrderByWithRelationInput | OwnerDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDrivers.
     */
    cursor?: OwnerDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDrivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDrivers.
     */
    distinct?: OwnerDriverScalarFieldEnum | OwnerDriverScalarFieldEnum[]
  }

  /**
   * OwnerDriver findMany
   */
  export type OwnerDriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDrivers to fetch.
     */
    where?: OwnerDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDrivers to fetch.
     */
    orderBy?: OwnerDriverOrderByWithRelationInput | OwnerDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerDrivers.
     */
    cursor?: OwnerDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDrivers.
     */
    skip?: number
    distinct?: OwnerDriverScalarFieldEnum | OwnerDriverScalarFieldEnum[]
  }

  /**
   * OwnerDriver create
   */
  export type OwnerDriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerDriver.
     */
    data: XOR<OwnerDriverCreateInput, OwnerDriverUncheckedCreateInput>
  }

  /**
   * OwnerDriver createMany
   */
  export type OwnerDriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerDrivers.
     */
    data: OwnerDriverCreateManyInput | OwnerDriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerDriver createManyAndReturn
   */
  export type OwnerDriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * The data used to create many OwnerDrivers.
     */
    data: OwnerDriverCreateManyInput | OwnerDriverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerDriver update
   */
  export type OwnerDriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerDriver.
     */
    data: XOR<OwnerDriverUpdateInput, OwnerDriverUncheckedUpdateInput>
    /**
     * Choose, which OwnerDriver to update.
     */
    where: OwnerDriverWhereUniqueInput
  }

  /**
   * OwnerDriver updateMany
   */
  export type OwnerDriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerDrivers.
     */
    data: XOR<OwnerDriverUpdateManyMutationInput, OwnerDriverUncheckedUpdateManyInput>
    /**
     * Filter which OwnerDrivers to update
     */
    where?: OwnerDriverWhereInput
    /**
     * Limit how many OwnerDrivers to update.
     */
    limit?: number
  }

  /**
   * OwnerDriver updateManyAndReturn
   */
  export type OwnerDriverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * The data used to update OwnerDrivers.
     */
    data: XOR<OwnerDriverUpdateManyMutationInput, OwnerDriverUncheckedUpdateManyInput>
    /**
     * Filter which OwnerDrivers to update
     */
    where?: OwnerDriverWhereInput
    /**
     * Limit how many OwnerDrivers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerDriver upsert
   */
  export type OwnerDriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerDriver to update in case it exists.
     */
    where: OwnerDriverWhereUniqueInput
    /**
     * In case the OwnerDriver found by the `where` argument doesn't exist, create a new OwnerDriver with this data.
     */
    create: XOR<OwnerDriverCreateInput, OwnerDriverUncheckedCreateInput>
    /**
     * In case the OwnerDriver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerDriverUpdateInput, OwnerDriverUncheckedUpdateInput>
  }

  /**
   * OwnerDriver delete
   */
  export type OwnerDriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
    /**
     * Filter which OwnerDriver to delete.
     */
    where: OwnerDriverWhereUniqueInput
  }

  /**
   * OwnerDriver deleteMany
   */
  export type OwnerDriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDrivers to delete
     */
    where?: OwnerDriverWhereInput
    /**
     * Limit how many OwnerDrivers to delete.
     */
    limit?: number
  }

  /**
   * OwnerDriver without action
   */
  export type OwnerDriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDriver
     */
    select?: OwnerDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDriver
     */
    omit?: OwnerDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDriverInclude<ExtArgs> | null
  }


  /**
   * Model OwnerVehicle
   */

  export type AggregateOwnerVehicle = {
    _count: OwnerVehicleCountAggregateOutputType | null
    _avg: OwnerVehicleAvgAggregateOutputType | null
    _sum: OwnerVehicleSumAggregateOutputType | null
    _min: OwnerVehicleMinAggregateOutputType | null
    _max: OwnerVehicleMaxAggregateOutputType | null
  }

  export type OwnerVehicleAvgAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    VehicleId: number | null
  }

  export type OwnerVehicleSumAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    VehicleId: number | null
  }

  export type OwnerVehicleMinAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    VehicleId: number | null
  }

  export type OwnerVehicleMaxAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    VehicleId: number | null
  }

  export type OwnerVehicleCountAggregateOutputType = {
    Id: number
    OwnerId: number
    VehicleId: number
    _all: number
  }


  export type OwnerVehicleAvgAggregateInputType = {
    Id?: true
    OwnerId?: true
    VehicleId?: true
  }

  export type OwnerVehicleSumAggregateInputType = {
    Id?: true
    OwnerId?: true
    VehicleId?: true
  }

  export type OwnerVehicleMinAggregateInputType = {
    Id?: true
    OwnerId?: true
    VehicleId?: true
  }

  export type OwnerVehicleMaxAggregateInputType = {
    Id?: true
    OwnerId?: true
    VehicleId?: true
  }

  export type OwnerVehicleCountAggregateInputType = {
    Id?: true
    OwnerId?: true
    VehicleId?: true
    _all?: true
  }

  export type OwnerVehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerVehicle to aggregate.
     */
    where?: OwnerVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVehicles to fetch.
     */
    orderBy?: OwnerVehicleOrderByWithRelationInput | OwnerVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerVehicles
    **/
    _count?: true | OwnerVehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerVehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerVehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerVehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerVehicleMaxAggregateInputType
  }

  export type GetOwnerVehicleAggregateType<T extends OwnerVehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerVehicle[P]>
      : GetScalarType<T[P], AggregateOwnerVehicle[P]>
  }




  export type OwnerVehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerVehicleWhereInput
    orderBy?: OwnerVehicleOrderByWithAggregationInput | OwnerVehicleOrderByWithAggregationInput[]
    by: OwnerVehicleScalarFieldEnum[] | OwnerVehicleScalarFieldEnum
    having?: OwnerVehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerVehicleCountAggregateInputType | true
    _avg?: OwnerVehicleAvgAggregateInputType
    _sum?: OwnerVehicleSumAggregateInputType
    _min?: OwnerVehicleMinAggregateInputType
    _max?: OwnerVehicleMaxAggregateInputType
  }

  export type OwnerVehicleGroupByOutputType = {
    Id: number
    OwnerId: number
    VehicleId: number
    _count: OwnerVehicleCountAggregateOutputType | null
    _avg: OwnerVehicleAvgAggregateOutputType | null
    _sum: OwnerVehicleSumAggregateOutputType | null
    _min: OwnerVehicleMinAggregateOutputType | null
    _max: OwnerVehicleMaxAggregateOutputType | null
  }

  type GetOwnerVehicleGroupByPayload<T extends OwnerVehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerVehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerVehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerVehicleGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerVehicleGroupByOutputType[P]>
        }
      >
    >


  export type OwnerVehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    VehicleId?: boolean
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerVehicle"]>

  export type OwnerVehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    VehicleId?: boolean
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerVehicle"]>

  export type OwnerVehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    VehicleId?: boolean
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerVehicle"]>

  export type OwnerVehicleSelectScalar = {
    Id?: boolean
    OwnerId?: boolean
    VehicleId?: boolean
  }

  export type OwnerVehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "OwnerId" | "VehicleId", ExtArgs["result"]["ownerVehicle"]>
  export type OwnerVehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type OwnerVehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type OwnerVehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
    Vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $OwnerVehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerVehicle"
    objects: {
      Owner: Prisma.$OwnerPayload<ExtArgs>
      Vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      OwnerId: number
      VehicleId: number
    }, ExtArgs["result"]["ownerVehicle"]>
    composites: {}
  }

  type OwnerVehicleGetPayload<S extends boolean | null | undefined | OwnerVehicleDefaultArgs> = $Result.GetResult<Prisma.$OwnerVehiclePayload, S>

  type OwnerVehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnerVehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnerVehicleCountAggregateInputType | true
    }

  export interface OwnerVehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerVehicle'], meta: { name: 'OwnerVehicle' } }
    /**
     * Find zero or one OwnerVehicle that matches the filter.
     * @param {OwnerVehicleFindUniqueArgs} args - Arguments to find a OwnerVehicle
     * @example
     * // Get one OwnerVehicle
     * const ownerVehicle = await prisma.ownerVehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerVehicleFindUniqueArgs>(args: SelectSubset<T, OwnerVehicleFindUniqueArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OwnerVehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnerVehicleFindUniqueOrThrowArgs} args - Arguments to find a OwnerVehicle
     * @example
     * // Get one OwnerVehicle
     * const ownerVehicle = await prisma.ownerVehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerVehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerVehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerVehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVehicleFindFirstArgs} args - Arguments to find a OwnerVehicle
     * @example
     * // Get one OwnerVehicle
     * const ownerVehicle = await prisma.ownerVehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerVehicleFindFirstArgs>(args?: SelectSubset<T, OwnerVehicleFindFirstArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerVehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVehicleFindFirstOrThrowArgs} args - Arguments to find a OwnerVehicle
     * @example
     * // Get one OwnerVehicle
     * const ownerVehicle = await prisma.ownerVehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerVehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerVehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OwnerVehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerVehicles
     * const ownerVehicles = await prisma.ownerVehicle.findMany()
     * 
     * // Get first 10 OwnerVehicles
     * const ownerVehicles = await prisma.ownerVehicle.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const ownerVehicleWithIdOnly = await prisma.ownerVehicle.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends OwnerVehicleFindManyArgs>(args?: SelectSubset<T, OwnerVehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OwnerVehicle.
     * @param {OwnerVehicleCreateArgs} args - Arguments to create a OwnerVehicle.
     * @example
     * // Create one OwnerVehicle
     * const OwnerVehicle = await prisma.ownerVehicle.create({
     *   data: {
     *     // ... data to create a OwnerVehicle
     *   }
     * })
     * 
     */
    create<T extends OwnerVehicleCreateArgs>(args: SelectSubset<T, OwnerVehicleCreateArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OwnerVehicles.
     * @param {OwnerVehicleCreateManyArgs} args - Arguments to create many OwnerVehicles.
     * @example
     * // Create many OwnerVehicles
     * const ownerVehicle = await prisma.ownerVehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerVehicleCreateManyArgs>(args?: SelectSubset<T, OwnerVehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnerVehicles and returns the data saved in the database.
     * @param {OwnerVehicleCreateManyAndReturnArgs} args - Arguments to create many OwnerVehicles.
     * @example
     * // Create many OwnerVehicles
     * const ownerVehicle = await prisma.ownerVehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnerVehicles and only return the `Id`
     * const ownerVehicleWithIdOnly = await prisma.ownerVehicle.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerVehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerVehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OwnerVehicle.
     * @param {OwnerVehicleDeleteArgs} args - Arguments to delete one OwnerVehicle.
     * @example
     * // Delete one OwnerVehicle
     * const OwnerVehicle = await prisma.ownerVehicle.delete({
     *   where: {
     *     // ... filter to delete one OwnerVehicle
     *   }
     * })
     * 
     */
    delete<T extends OwnerVehicleDeleteArgs>(args: SelectSubset<T, OwnerVehicleDeleteArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OwnerVehicle.
     * @param {OwnerVehicleUpdateArgs} args - Arguments to update one OwnerVehicle.
     * @example
     * // Update one OwnerVehicle
     * const ownerVehicle = await prisma.ownerVehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerVehicleUpdateArgs>(args: SelectSubset<T, OwnerVehicleUpdateArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OwnerVehicles.
     * @param {OwnerVehicleDeleteManyArgs} args - Arguments to filter OwnerVehicles to delete.
     * @example
     * // Delete a few OwnerVehicles
     * const { count } = await prisma.ownerVehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerVehicleDeleteManyArgs>(args?: SelectSubset<T, OwnerVehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerVehicles
     * const ownerVehicle = await prisma.ownerVehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerVehicleUpdateManyArgs>(args: SelectSubset<T, OwnerVehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerVehicles and returns the data updated in the database.
     * @param {OwnerVehicleUpdateManyAndReturnArgs} args - Arguments to update many OwnerVehicles.
     * @example
     * // Update many OwnerVehicles
     * const ownerVehicle = await prisma.ownerVehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OwnerVehicles and only return the `Id`
     * const ownerVehicleWithIdOnly = await prisma.ownerVehicle.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnerVehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnerVehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OwnerVehicle.
     * @param {OwnerVehicleUpsertArgs} args - Arguments to update or create a OwnerVehicle.
     * @example
     * // Update or create a OwnerVehicle
     * const ownerVehicle = await prisma.ownerVehicle.upsert({
     *   create: {
     *     // ... data to create a OwnerVehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerVehicle we want to update
     *   }
     * })
     */
    upsert<T extends OwnerVehicleUpsertArgs>(args: SelectSubset<T, OwnerVehicleUpsertArgs<ExtArgs>>): Prisma__OwnerVehicleClient<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OwnerVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVehicleCountArgs} args - Arguments to filter OwnerVehicles to count.
     * @example
     * // Count the number of OwnerVehicles
     * const count = await prisma.ownerVehicle.count({
     *   where: {
     *     // ... the filter for the OwnerVehicles we want to count
     *   }
     * })
    **/
    count<T extends OwnerVehicleCountArgs>(
      args?: Subset<T, OwnerVehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerVehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerVehicleAggregateArgs>(args: Subset<T, OwnerVehicleAggregateArgs>): Prisma.PrismaPromise<GetOwnerVehicleAggregateType<T>>

    /**
     * Group by OwnerVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerVehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerVehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerVehicleGroupByArgs['orderBy'] }
        : { orderBy?: OwnerVehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerVehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerVehicle model
   */
  readonly fields: OwnerVehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerVehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerVehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerVehicle model
   */
  interface OwnerVehicleFieldRefs {
    readonly Id: FieldRef<"OwnerVehicle", 'Int'>
    readonly OwnerId: FieldRef<"OwnerVehicle", 'Int'>
    readonly VehicleId: FieldRef<"OwnerVehicle", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OwnerVehicle findUnique
   */
  export type OwnerVehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVehicle to fetch.
     */
    where: OwnerVehicleWhereUniqueInput
  }

  /**
   * OwnerVehicle findUniqueOrThrow
   */
  export type OwnerVehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVehicle to fetch.
     */
    where: OwnerVehicleWhereUniqueInput
  }

  /**
   * OwnerVehicle findFirst
   */
  export type OwnerVehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVehicle to fetch.
     */
    where?: OwnerVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVehicles to fetch.
     */
    orderBy?: OwnerVehicleOrderByWithRelationInput | OwnerVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerVehicles.
     */
    cursor?: OwnerVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerVehicles.
     */
    distinct?: OwnerVehicleScalarFieldEnum | OwnerVehicleScalarFieldEnum[]
  }

  /**
   * OwnerVehicle findFirstOrThrow
   */
  export type OwnerVehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVehicle to fetch.
     */
    where?: OwnerVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVehicles to fetch.
     */
    orderBy?: OwnerVehicleOrderByWithRelationInput | OwnerVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerVehicles.
     */
    cursor?: OwnerVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerVehicles.
     */
    distinct?: OwnerVehicleScalarFieldEnum | OwnerVehicleScalarFieldEnum[]
  }

  /**
   * OwnerVehicle findMany
   */
  export type OwnerVehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * Filter, which OwnerVehicles to fetch.
     */
    where?: OwnerVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerVehicles to fetch.
     */
    orderBy?: OwnerVehicleOrderByWithRelationInput | OwnerVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerVehicles.
     */
    cursor?: OwnerVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerVehicles.
     */
    skip?: number
    distinct?: OwnerVehicleScalarFieldEnum | OwnerVehicleScalarFieldEnum[]
  }

  /**
   * OwnerVehicle create
   */
  export type OwnerVehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerVehicle.
     */
    data: XOR<OwnerVehicleCreateInput, OwnerVehicleUncheckedCreateInput>
  }

  /**
   * OwnerVehicle createMany
   */
  export type OwnerVehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerVehicles.
     */
    data: OwnerVehicleCreateManyInput | OwnerVehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerVehicle createManyAndReturn
   */
  export type OwnerVehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * The data used to create many OwnerVehicles.
     */
    data: OwnerVehicleCreateManyInput | OwnerVehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerVehicle update
   */
  export type OwnerVehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerVehicle.
     */
    data: XOR<OwnerVehicleUpdateInput, OwnerVehicleUncheckedUpdateInput>
    /**
     * Choose, which OwnerVehicle to update.
     */
    where: OwnerVehicleWhereUniqueInput
  }

  /**
   * OwnerVehicle updateMany
   */
  export type OwnerVehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerVehicles.
     */
    data: XOR<OwnerVehicleUpdateManyMutationInput, OwnerVehicleUncheckedUpdateManyInput>
    /**
     * Filter which OwnerVehicles to update
     */
    where?: OwnerVehicleWhereInput
    /**
     * Limit how many OwnerVehicles to update.
     */
    limit?: number
  }

  /**
   * OwnerVehicle updateManyAndReturn
   */
  export type OwnerVehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * The data used to update OwnerVehicles.
     */
    data: XOR<OwnerVehicleUpdateManyMutationInput, OwnerVehicleUncheckedUpdateManyInput>
    /**
     * Filter which OwnerVehicles to update
     */
    where?: OwnerVehicleWhereInput
    /**
     * Limit how many OwnerVehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerVehicle upsert
   */
  export type OwnerVehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerVehicle to update in case it exists.
     */
    where: OwnerVehicleWhereUniqueInput
    /**
     * In case the OwnerVehicle found by the `where` argument doesn't exist, create a new OwnerVehicle with this data.
     */
    create: XOR<OwnerVehicleCreateInput, OwnerVehicleUncheckedCreateInput>
    /**
     * In case the OwnerVehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerVehicleUpdateInput, OwnerVehicleUncheckedUpdateInput>
  }

  /**
   * OwnerVehicle delete
   */
  export type OwnerVehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    /**
     * Filter which OwnerVehicle to delete.
     */
    where: OwnerVehicleWhereUniqueInput
  }

  /**
   * OwnerVehicle deleteMany
   */
  export type OwnerVehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerVehicles to delete
     */
    where?: OwnerVehicleWhereInput
    /**
     * Limit how many OwnerVehicles to delete.
     */
    limit?: number
  }

  /**
   * OwnerVehicle without action
   */
  export type OwnerVehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
  }


  /**
   * Model OwnerWallet
   */

  export type AggregateOwnerWallet = {
    _count: OwnerWalletCountAggregateOutputType | null
    _avg: OwnerWalletAvgAggregateOutputType | null
    _sum: OwnerWalletSumAggregateOutputType | null
    _min: OwnerWalletMinAggregateOutputType | null
    _max: OwnerWalletMaxAggregateOutputType | null
  }

  export type OwnerWalletAvgAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    Amount: number | null
  }

  export type OwnerWalletSumAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    Amount: number | null
  }

  export type OwnerWalletMinAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    Amount: number | null
    LastUpdated: Date | null
  }

  export type OwnerWalletMaxAggregateOutputType = {
    Id: number | null
    OwnerId: number | null
    Amount: number | null
    LastUpdated: Date | null
  }

  export type OwnerWalletCountAggregateOutputType = {
    Id: number
    OwnerId: number
    Amount: number
    LastUpdated: number
    _all: number
  }


  export type OwnerWalletAvgAggregateInputType = {
    Id?: true
    OwnerId?: true
    Amount?: true
  }

  export type OwnerWalletSumAggregateInputType = {
    Id?: true
    OwnerId?: true
    Amount?: true
  }

  export type OwnerWalletMinAggregateInputType = {
    Id?: true
    OwnerId?: true
    Amount?: true
    LastUpdated?: true
  }

  export type OwnerWalletMaxAggregateInputType = {
    Id?: true
    OwnerId?: true
    Amount?: true
    LastUpdated?: true
  }

  export type OwnerWalletCountAggregateInputType = {
    Id?: true
    OwnerId?: true
    Amount?: true
    LastUpdated?: true
    _all?: true
  }

  export type OwnerWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerWallet to aggregate.
     */
    where?: OwnerWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerWallets to fetch.
     */
    orderBy?: OwnerWalletOrderByWithRelationInput | OwnerWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerWallets
    **/
    _count?: true | OwnerWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerWalletMaxAggregateInputType
  }

  export type GetOwnerWalletAggregateType<T extends OwnerWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerWallet[P]>
      : GetScalarType<T[P], AggregateOwnerWallet[P]>
  }




  export type OwnerWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWalletWhereInput
    orderBy?: OwnerWalletOrderByWithAggregationInput | OwnerWalletOrderByWithAggregationInput[]
    by: OwnerWalletScalarFieldEnum[] | OwnerWalletScalarFieldEnum
    having?: OwnerWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerWalletCountAggregateInputType | true
    _avg?: OwnerWalletAvgAggregateInputType
    _sum?: OwnerWalletSumAggregateInputType
    _min?: OwnerWalletMinAggregateInputType
    _max?: OwnerWalletMaxAggregateInputType
  }

  export type OwnerWalletGroupByOutputType = {
    Id: number
    OwnerId: number
    Amount: number
    LastUpdated: Date
    _count: OwnerWalletCountAggregateOutputType | null
    _avg: OwnerWalletAvgAggregateOutputType | null
    _sum: OwnerWalletSumAggregateOutputType | null
    _min: OwnerWalletMinAggregateOutputType | null
    _max: OwnerWalletMaxAggregateOutputType | null
  }

  type GetOwnerWalletGroupByPayload<T extends OwnerWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerWalletGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerWalletGroupByOutputType[P]>
        }
      >
    >


  export type OwnerWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerWallet"]>

  export type OwnerWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerWallet"]>

  export type OwnerWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    OwnerId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerWallet"]>

  export type OwnerWalletSelectScalar = {
    Id?: boolean
    OwnerId?: boolean
    Amount?: boolean
    LastUpdated?: boolean
  }

  export type OwnerWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "OwnerId" | "Amount" | "LastUpdated", ExtArgs["result"]["ownerWallet"]>
  export type OwnerWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type OwnerWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }
  export type OwnerWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Owner?: boolean | OwnerDefaultArgs<ExtArgs>
  }

  export type $OwnerWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerWallet"
    objects: {
      Owner: Prisma.$OwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      OwnerId: number
      Amount: number
      LastUpdated: Date
    }, ExtArgs["result"]["ownerWallet"]>
    composites: {}
  }

  type OwnerWalletGetPayload<S extends boolean | null | undefined | OwnerWalletDefaultArgs> = $Result.GetResult<Prisma.$OwnerWalletPayload, S>

  type OwnerWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnerWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnerWalletCountAggregateInputType | true
    }

  export interface OwnerWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerWallet'], meta: { name: 'OwnerWallet' } }
    /**
     * Find zero or one OwnerWallet that matches the filter.
     * @param {OwnerWalletFindUniqueArgs} args - Arguments to find a OwnerWallet
     * @example
     * // Get one OwnerWallet
     * const ownerWallet = await prisma.ownerWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerWalletFindUniqueArgs>(args: SelectSubset<T, OwnerWalletFindUniqueArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OwnerWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnerWalletFindUniqueOrThrowArgs} args - Arguments to find a OwnerWallet
     * @example
     * // Get one OwnerWallet
     * const ownerWallet = await prisma.ownerWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerWalletFindFirstArgs} args - Arguments to find a OwnerWallet
     * @example
     * // Get one OwnerWallet
     * const ownerWallet = await prisma.ownerWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerWalletFindFirstArgs>(args?: SelectSubset<T, OwnerWalletFindFirstArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerWalletFindFirstOrThrowArgs} args - Arguments to find a OwnerWallet
     * @example
     * // Get one OwnerWallet
     * const ownerWallet = await prisma.ownerWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OwnerWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerWallets
     * const ownerWallets = await prisma.ownerWallet.findMany()
     * 
     * // Get first 10 OwnerWallets
     * const ownerWallets = await prisma.ownerWallet.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const ownerWalletWithIdOnly = await prisma.ownerWallet.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends OwnerWalletFindManyArgs>(args?: SelectSubset<T, OwnerWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OwnerWallet.
     * @param {OwnerWalletCreateArgs} args - Arguments to create a OwnerWallet.
     * @example
     * // Create one OwnerWallet
     * const OwnerWallet = await prisma.ownerWallet.create({
     *   data: {
     *     // ... data to create a OwnerWallet
     *   }
     * })
     * 
     */
    create<T extends OwnerWalletCreateArgs>(args: SelectSubset<T, OwnerWalletCreateArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OwnerWallets.
     * @param {OwnerWalletCreateManyArgs} args - Arguments to create many OwnerWallets.
     * @example
     * // Create many OwnerWallets
     * const ownerWallet = await prisma.ownerWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerWalletCreateManyArgs>(args?: SelectSubset<T, OwnerWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnerWallets and returns the data saved in the database.
     * @param {OwnerWalletCreateManyAndReturnArgs} args - Arguments to create many OwnerWallets.
     * @example
     * // Create many OwnerWallets
     * const ownerWallet = await prisma.ownerWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnerWallets and only return the `Id`
     * const ownerWalletWithIdOnly = await prisma.ownerWallet.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OwnerWallet.
     * @param {OwnerWalletDeleteArgs} args - Arguments to delete one OwnerWallet.
     * @example
     * // Delete one OwnerWallet
     * const OwnerWallet = await prisma.ownerWallet.delete({
     *   where: {
     *     // ... filter to delete one OwnerWallet
     *   }
     * })
     * 
     */
    delete<T extends OwnerWalletDeleteArgs>(args: SelectSubset<T, OwnerWalletDeleteArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OwnerWallet.
     * @param {OwnerWalletUpdateArgs} args - Arguments to update one OwnerWallet.
     * @example
     * // Update one OwnerWallet
     * const ownerWallet = await prisma.ownerWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerWalletUpdateArgs>(args: SelectSubset<T, OwnerWalletUpdateArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OwnerWallets.
     * @param {OwnerWalletDeleteManyArgs} args - Arguments to filter OwnerWallets to delete.
     * @example
     * // Delete a few OwnerWallets
     * const { count } = await prisma.ownerWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerWalletDeleteManyArgs>(args?: SelectSubset<T, OwnerWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerWallets
     * const ownerWallet = await prisma.ownerWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerWalletUpdateManyArgs>(args: SelectSubset<T, OwnerWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerWallets and returns the data updated in the database.
     * @param {OwnerWalletUpdateManyAndReturnArgs} args - Arguments to update many OwnerWallets.
     * @example
     * // Update many OwnerWallets
     * const ownerWallet = await prisma.ownerWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OwnerWallets and only return the `Id`
     * const ownerWalletWithIdOnly = await prisma.ownerWallet.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnerWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnerWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OwnerWallet.
     * @param {OwnerWalletUpsertArgs} args - Arguments to update or create a OwnerWallet.
     * @example
     * // Update or create a OwnerWallet
     * const ownerWallet = await prisma.ownerWallet.upsert({
     *   create: {
     *     // ... data to create a OwnerWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerWallet we want to update
     *   }
     * })
     */
    upsert<T extends OwnerWalletUpsertArgs>(args: SelectSubset<T, OwnerWalletUpsertArgs<ExtArgs>>): Prisma__OwnerWalletClient<$Result.GetResult<Prisma.$OwnerWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OwnerWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerWalletCountArgs} args - Arguments to filter OwnerWallets to count.
     * @example
     * // Count the number of OwnerWallets
     * const count = await prisma.ownerWallet.count({
     *   where: {
     *     // ... the filter for the OwnerWallets we want to count
     *   }
     * })
    **/
    count<T extends OwnerWalletCountArgs>(
      args?: Subset<T, OwnerWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerWalletAggregateArgs>(args: Subset<T, OwnerWalletAggregateArgs>): Prisma.PrismaPromise<GetOwnerWalletAggregateType<T>>

    /**
     * Group by OwnerWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerWalletGroupByArgs['orderBy'] }
        : { orderBy?: OwnerWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerWallet model
   */
  readonly fields: OwnerWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerWallet model
   */
  interface OwnerWalletFieldRefs {
    readonly Id: FieldRef<"OwnerWallet", 'Int'>
    readonly OwnerId: FieldRef<"OwnerWallet", 'Int'>
    readonly Amount: FieldRef<"OwnerWallet", 'Int'>
    readonly LastUpdated: FieldRef<"OwnerWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OwnerWallet findUnique
   */
  export type OwnerWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * Filter, which OwnerWallet to fetch.
     */
    where: OwnerWalletWhereUniqueInput
  }

  /**
   * OwnerWallet findUniqueOrThrow
   */
  export type OwnerWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * Filter, which OwnerWallet to fetch.
     */
    where: OwnerWalletWhereUniqueInput
  }

  /**
   * OwnerWallet findFirst
   */
  export type OwnerWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * Filter, which OwnerWallet to fetch.
     */
    where?: OwnerWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerWallets to fetch.
     */
    orderBy?: OwnerWalletOrderByWithRelationInput | OwnerWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerWallets.
     */
    cursor?: OwnerWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerWallets.
     */
    distinct?: OwnerWalletScalarFieldEnum | OwnerWalletScalarFieldEnum[]
  }

  /**
   * OwnerWallet findFirstOrThrow
   */
  export type OwnerWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * Filter, which OwnerWallet to fetch.
     */
    where?: OwnerWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerWallets to fetch.
     */
    orderBy?: OwnerWalletOrderByWithRelationInput | OwnerWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerWallets.
     */
    cursor?: OwnerWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerWallets.
     */
    distinct?: OwnerWalletScalarFieldEnum | OwnerWalletScalarFieldEnum[]
  }

  /**
   * OwnerWallet findMany
   */
  export type OwnerWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * Filter, which OwnerWallets to fetch.
     */
    where?: OwnerWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerWallets to fetch.
     */
    orderBy?: OwnerWalletOrderByWithRelationInput | OwnerWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerWallets.
     */
    cursor?: OwnerWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerWallets.
     */
    skip?: number
    distinct?: OwnerWalletScalarFieldEnum | OwnerWalletScalarFieldEnum[]
  }

  /**
   * OwnerWallet create
   */
  export type OwnerWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerWallet.
     */
    data: XOR<OwnerWalletCreateInput, OwnerWalletUncheckedCreateInput>
  }

  /**
   * OwnerWallet createMany
   */
  export type OwnerWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerWallets.
     */
    data: OwnerWalletCreateManyInput | OwnerWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerWallet createManyAndReturn
   */
  export type OwnerWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * The data used to create many OwnerWallets.
     */
    data: OwnerWalletCreateManyInput | OwnerWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerWallet update
   */
  export type OwnerWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerWallet.
     */
    data: XOR<OwnerWalletUpdateInput, OwnerWalletUncheckedUpdateInput>
    /**
     * Choose, which OwnerWallet to update.
     */
    where: OwnerWalletWhereUniqueInput
  }

  /**
   * OwnerWallet updateMany
   */
  export type OwnerWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerWallets.
     */
    data: XOR<OwnerWalletUpdateManyMutationInput, OwnerWalletUncheckedUpdateManyInput>
    /**
     * Filter which OwnerWallets to update
     */
    where?: OwnerWalletWhereInput
    /**
     * Limit how many OwnerWallets to update.
     */
    limit?: number
  }

  /**
   * OwnerWallet updateManyAndReturn
   */
  export type OwnerWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * The data used to update OwnerWallets.
     */
    data: XOR<OwnerWalletUpdateManyMutationInput, OwnerWalletUncheckedUpdateManyInput>
    /**
     * Filter which OwnerWallets to update
     */
    where?: OwnerWalletWhereInput
    /**
     * Limit how many OwnerWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerWallet upsert
   */
  export type OwnerWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerWallet to update in case it exists.
     */
    where: OwnerWalletWhereUniqueInput
    /**
     * In case the OwnerWallet found by the `where` argument doesn't exist, create a new OwnerWallet with this data.
     */
    create: XOR<OwnerWalletCreateInput, OwnerWalletUncheckedCreateInput>
    /**
     * In case the OwnerWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerWalletUpdateInput, OwnerWalletUncheckedUpdateInput>
  }

  /**
   * OwnerWallet delete
   */
  export type OwnerWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
    /**
     * Filter which OwnerWallet to delete.
     */
    where: OwnerWalletWhereUniqueInput
  }

  /**
   * OwnerWallet deleteMany
   */
  export type OwnerWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerWallets to delete
     */
    where?: OwnerWalletWhereInput
    /**
     * Limit how many OwnerWallets to delete.
     */
    limit?: number
  }

  /**
   * OwnerWallet without action
   */
  export type OwnerWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerWallet
     */
    select?: OwnerWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerWallet
     */
    omit?: OwnerWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerWalletInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    Id: number | null
  }

  export type UserSumAggregateOutputType = {
    Id: number | null
  }

  export type UserMinAggregateOutputType = {
    Id: number | null
    MobileNumber: string | null
    CreatedDate: Date | null
    LastLoggedIn: Date | null
    Gender: $Enums.Gender | null
    Name: string | null
  }

  export type UserMaxAggregateOutputType = {
    Id: number | null
    MobileNumber: string | null
    CreatedDate: Date | null
    LastLoggedIn: Date | null
    Gender: $Enums.Gender | null
    Name: string | null
  }

  export type UserCountAggregateOutputType = {
    Id: number
    MobileNumber: number
    CreatedDate: number
    LastLoggedIn: number
    Gender: number
    Name: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    Id?: true
  }

  export type UserSumAggregateInputType = {
    Id?: true
  }

  export type UserMinAggregateInputType = {
    Id?: true
    MobileNumber?: true
    CreatedDate?: true
    LastLoggedIn?: true
    Gender?: true
    Name?: true
  }

  export type UserMaxAggregateInputType = {
    Id?: true
    MobileNumber?: true
    CreatedDate?: true
    LastLoggedIn?: true
    Gender?: true
    Name?: true
  }

  export type UserCountAggregateInputType = {
    Id?: true
    MobileNumber?: true
    CreatedDate?: true
    LastLoggedIn?: true
    Gender?: true
    Name?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    Id: number
    MobileNumber: string
    CreatedDate: Date
    LastLoggedIn: Date
    Gender: $Enums.Gender
    Name: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    MobileNumber?: boolean
    CreatedDate?: boolean
    LastLoggedIn?: boolean
    Gender?: boolean
    Name?: boolean
    Bookings?: boolean | User$BookingsArgs<ExtArgs>
    UserWallet?: boolean | User$UserWalletArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    MobileNumber?: boolean
    CreatedDate?: boolean
    LastLoggedIn?: boolean
    Gender?: boolean
    Name?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    MobileNumber?: boolean
    CreatedDate?: boolean
    LastLoggedIn?: boolean
    Gender?: boolean
    Name?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    Id?: boolean
    MobileNumber?: boolean
    CreatedDate?: boolean
    LastLoggedIn?: boolean
    Gender?: boolean
    Name?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "MobileNumber" | "CreatedDate" | "LastLoggedIn" | "Gender" | "Name", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | User$BookingsArgs<ExtArgs>
    UserWallet?: boolean | User$UserWalletArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Bookings: Prisma.$BookingsPayload<ExtArgs>[]
      UserWallet: Prisma.$UserWalletPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      MobileNumber: string
      CreatedDate: Date
      LastLoggedIn: Date
      Gender: $Enums.Gender
      Name: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `Id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `Id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bookings<T extends User$BookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$BookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserWallet<T extends User$UserWalletArgs<ExtArgs> = {}>(args?: Subset<T, User$UserWalletArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly Id: FieldRef<"User", 'Int'>
    readonly MobileNumber: FieldRef<"User", 'String'>
    readonly CreatedDate: FieldRef<"User", 'DateTime'>
    readonly LastLoggedIn: FieldRef<"User", 'DateTime'>
    readonly Gender: FieldRef<"User", 'Gender'>
    readonly Name: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Bookings
   */
  export type User$BookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    where?: BookingsWhereInput
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    cursor?: BookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * User.UserWallet
   */
  export type User$UserWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    where?: UserWalletWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserWallet
   */

  export type AggregateUserWallet = {
    _count: UserWalletCountAggregateOutputType | null
    _avg: UserWalletAvgAggregateOutputType | null
    _sum: UserWalletSumAggregateOutputType | null
    _min: UserWalletMinAggregateOutputType | null
    _max: UserWalletMaxAggregateOutputType | null
  }

  export type UserWalletAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
    Amount: number | null
  }

  export type UserWalletSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
    Amount: number | null
  }

  export type UserWalletMinAggregateOutputType = {
    Id: number | null
    UserId: number | null
    Amount: number | null
  }

  export type UserWalletMaxAggregateOutputType = {
    Id: number | null
    UserId: number | null
    Amount: number | null
  }

  export type UserWalletCountAggregateOutputType = {
    Id: number
    UserId: number
    Amount: number
    _all: number
  }


  export type UserWalletAvgAggregateInputType = {
    Id?: true
    UserId?: true
    Amount?: true
  }

  export type UserWalletSumAggregateInputType = {
    Id?: true
    UserId?: true
    Amount?: true
  }

  export type UserWalletMinAggregateInputType = {
    Id?: true
    UserId?: true
    Amount?: true
  }

  export type UserWalletMaxAggregateInputType = {
    Id?: true
    UserId?: true
    Amount?: true
  }

  export type UserWalletCountAggregateInputType = {
    Id?: true
    UserId?: true
    Amount?: true
    _all?: true
  }

  export type UserWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWallet to aggregate.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserWallets
    **/
    _count?: true | UserWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserWalletMaxAggregateInputType
  }

  export type GetUserWalletAggregateType<T extends UserWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateUserWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserWallet[P]>
      : GetScalarType<T[P], AggregateUserWallet[P]>
  }




  export type UserWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWalletWhereInput
    orderBy?: UserWalletOrderByWithAggregationInput | UserWalletOrderByWithAggregationInput[]
    by: UserWalletScalarFieldEnum[] | UserWalletScalarFieldEnum
    having?: UserWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserWalletCountAggregateInputType | true
    _avg?: UserWalletAvgAggregateInputType
    _sum?: UserWalletSumAggregateInputType
    _min?: UserWalletMinAggregateInputType
    _max?: UserWalletMaxAggregateInputType
  }

  export type UserWalletGroupByOutputType = {
    Id: number
    UserId: number
    Amount: number
    _count: UserWalletCountAggregateOutputType | null
    _avg: UserWalletAvgAggregateOutputType | null
    _sum: UserWalletSumAggregateOutputType | null
    _min: UserWalletMinAggregateOutputType | null
    _max: UserWalletMaxAggregateOutputType | null
  }

  type GetUserWalletGroupByPayload<T extends UserWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserWalletGroupByOutputType[P]>
            : GetScalarType<T[P], UserWalletGroupByOutputType[P]>
        }
      >
    >


  export type UserWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    Amount?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWallet"]>

  export type UserWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    Amount?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWallet"]>

  export type UserWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    Amount?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWallet"]>

  export type UserWalletSelectScalar = {
    Id?: boolean
    UserId?: boolean
    Amount?: boolean
  }

  export type UserWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UserId" | "Amount", ExtArgs["result"]["userWallet"]>
  export type UserWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserWallet"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UserId: number
      Amount: number
    }, ExtArgs["result"]["userWallet"]>
    composites: {}
  }

  type UserWalletGetPayload<S extends boolean | null | undefined | UserWalletDefaultArgs> = $Result.GetResult<Prisma.$UserWalletPayload, S>

  type UserWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserWalletCountAggregateInputType | true
    }

  export interface UserWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserWallet'], meta: { name: 'UserWallet' } }
    /**
     * Find zero or one UserWallet that matches the filter.
     * @param {UserWalletFindUniqueArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserWalletFindUniqueArgs>(args: SelectSubset<T, UserWalletFindUniqueArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserWalletFindUniqueOrThrowArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, UserWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletFindFirstArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserWalletFindFirstArgs>(args?: SelectSubset<T, UserWalletFindFirstArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletFindFirstOrThrowArgs} args - Arguments to find a UserWallet
     * @example
     * // Get one UserWallet
     * const userWallet = await prisma.userWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, UserWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserWallets
     * const userWallets = await prisma.userWallet.findMany()
     * 
     * // Get first 10 UserWallets
     * const userWallets = await prisma.userWallet.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const userWalletWithIdOnly = await prisma.userWallet.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends UserWalletFindManyArgs>(args?: SelectSubset<T, UserWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserWallet.
     * @param {UserWalletCreateArgs} args - Arguments to create a UserWallet.
     * @example
     * // Create one UserWallet
     * const UserWallet = await prisma.userWallet.create({
     *   data: {
     *     // ... data to create a UserWallet
     *   }
     * })
     * 
     */
    create<T extends UserWalletCreateArgs>(args: SelectSubset<T, UserWalletCreateArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserWallets.
     * @param {UserWalletCreateManyArgs} args - Arguments to create many UserWallets.
     * @example
     * // Create many UserWallets
     * const userWallet = await prisma.userWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserWalletCreateManyArgs>(args?: SelectSubset<T, UserWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserWallets and returns the data saved in the database.
     * @param {UserWalletCreateManyAndReturnArgs} args - Arguments to create many UserWallets.
     * @example
     * // Create many UserWallets
     * const userWallet = await prisma.userWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserWallets and only return the `Id`
     * const userWalletWithIdOnly = await prisma.userWallet.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, UserWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserWallet.
     * @param {UserWalletDeleteArgs} args - Arguments to delete one UserWallet.
     * @example
     * // Delete one UserWallet
     * const UserWallet = await prisma.userWallet.delete({
     *   where: {
     *     // ... filter to delete one UserWallet
     *   }
     * })
     * 
     */
    delete<T extends UserWalletDeleteArgs>(args: SelectSubset<T, UserWalletDeleteArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserWallet.
     * @param {UserWalletUpdateArgs} args - Arguments to update one UserWallet.
     * @example
     * // Update one UserWallet
     * const userWallet = await prisma.userWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserWalletUpdateArgs>(args: SelectSubset<T, UserWalletUpdateArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserWallets.
     * @param {UserWalletDeleteManyArgs} args - Arguments to filter UserWallets to delete.
     * @example
     * // Delete a few UserWallets
     * const { count } = await prisma.userWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserWalletDeleteManyArgs>(args?: SelectSubset<T, UserWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserWallets
     * const userWallet = await prisma.userWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserWalletUpdateManyArgs>(args: SelectSubset<T, UserWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWallets and returns the data updated in the database.
     * @param {UserWalletUpdateManyAndReturnArgs} args - Arguments to update many UserWallets.
     * @example
     * // Update many UserWallets
     * const userWallet = await prisma.userWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserWallets and only return the `Id`
     * const userWalletWithIdOnly = await prisma.userWallet.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, UserWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserWallet.
     * @param {UserWalletUpsertArgs} args - Arguments to update or create a UserWallet.
     * @example
     * // Update or create a UserWallet
     * const userWallet = await prisma.userWallet.upsert({
     *   create: {
     *     // ... data to create a UserWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserWallet we want to update
     *   }
     * })
     */
    upsert<T extends UserWalletUpsertArgs>(args: SelectSubset<T, UserWalletUpsertArgs<ExtArgs>>): Prisma__UserWalletClient<$Result.GetResult<Prisma.$UserWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletCountArgs} args - Arguments to filter UserWallets to count.
     * @example
     * // Count the number of UserWallets
     * const count = await prisma.userWallet.count({
     *   where: {
     *     // ... the filter for the UserWallets we want to count
     *   }
     * })
    **/
    count<T extends UserWalletCountArgs>(
      args?: Subset<T, UserWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserWalletAggregateArgs>(args: Subset<T, UserWalletAggregateArgs>): Prisma.PrismaPromise<GetUserWalletAggregateType<T>>

    /**
     * Group by UserWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserWalletGroupByArgs['orderBy'] }
        : { orderBy?: UserWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserWallet model
   */
  readonly fields: UserWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserWallet model
   */
  interface UserWalletFieldRefs {
    readonly Id: FieldRef<"UserWallet", 'Int'>
    readonly UserId: FieldRef<"UserWallet", 'Int'>
    readonly Amount: FieldRef<"UserWallet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserWallet findUnique
   */
  export type UserWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet findUniqueOrThrow
   */
  export type UserWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet findFirst
   */
  export type UserWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWallets.
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWallets.
     */
    distinct?: UserWalletScalarFieldEnum | UserWalletScalarFieldEnum[]
  }

  /**
   * UserWallet findFirstOrThrow
   */
  export type UserWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallet to fetch.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWallets.
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWallets.
     */
    distinct?: UserWalletScalarFieldEnum | UserWalletScalarFieldEnum[]
  }

  /**
   * UserWallet findMany
   */
  export type UserWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter, which UserWallets to fetch.
     */
    where?: UserWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWallets to fetch.
     */
    orderBy?: UserWalletOrderByWithRelationInput | UserWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserWallets.
     */
    cursor?: UserWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWallets.
     */
    skip?: number
    distinct?: UserWalletScalarFieldEnum | UserWalletScalarFieldEnum[]
  }

  /**
   * UserWallet create
   */
  export type UserWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a UserWallet.
     */
    data: XOR<UserWalletCreateInput, UserWalletUncheckedCreateInput>
  }

  /**
   * UserWallet createMany
   */
  export type UserWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserWallets.
     */
    data: UserWalletCreateManyInput | UserWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserWallet createManyAndReturn
   */
  export type UserWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * The data used to create many UserWallets.
     */
    data: UserWalletCreateManyInput | UserWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWallet update
   */
  export type UserWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a UserWallet.
     */
    data: XOR<UserWalletUpdateInput, UserWalletUncheckedUpdateInput>
    /**
     * Choose, which UserWallet to update.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet updateMany
   */
  export type UserWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserWallets.
     */
    data: XOR<UserWalletUpdateManyMutationInput, UserWalletUncheckedUpdateManyInput>
    /**
     * Filter which UserWallets to update
     */
    where?: UserWalletWhereInput
    /**
     * Limit how many UserWallets to update.
     */
    limit?: number
  }

  /**
   * UserWallet updateManyAndReturn
   */
  export type UserWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * The data used to update UserWallets.
     */
    data: XOR<UserWalletUpdateManyMutationInput, UserWalletUncheckedUpdateManyInput>
    /**
     * Filter which UserWallets to update
     */
    where?: UserWalletWhereInput
    /**
     * Limit how many UserWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWallet upsert
   */
  export type UserWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the UserWallet to update in case it exists.
     */
    where: UserWalletWhereUniqueInput
    /**
     * In case the UserWallet found by the `where` argument doesn't exist, create a new UserWallet with this data.
     */
    create: XOR<UserWalletCreateInput, UserWalletUncheckedCreateInput>
    /**
     * In case the UserWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserWalletUpdateInput, UserWalletUncheckedUpdateInput>
  }

  /**
   * UserWallet delete
   */
  export type UserWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
    /**
     * Filter which UserWallet to delete.
     */
    where: UserWalletWhereUniqueInput
  }

  /**
   * UserWallet deleteMany
   */
  export type UserWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWallets to delete
     */
    where?: UserWalletWhereInput
    /**
     * Limit how many UserWallets to delete.
     */
    limit?: number
  }

  /**
   * UserWallet without action
   */
  export type UserWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWallet
     */
    select?: UserWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWallet
     */
    omit?: UserWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWalletInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    Id: number | null
  }

  export type VehicleSumAggregateOutputType = {
    Id: number | null
  }

  export type VehicleMinAggregateOutputType = {
    Id: number | null
    Model: string | null
    Year: string | null
    Category: string | null
    VehicleImage: string | null
    VehicleInsuranceImage: string | null
    PermitImage: string | null
    VehicleNumber: string | null
  }

  export type VehicleMaxAggregateOutputType = {
    Id: number | null
    Model: string | null
    Year: string | null
    Category: string | null
    VehicleImage: string | null
    VehicleInsuranceImage: string | null
    PermitImage: string | null
    VehicleNumber: string | null
  }

  export type VehicleCountAggregateOutputType = {
    Id: number
    Model: number
    Year: number
    Category: number
    VehicleImage: number
    VehicleInsuranceImage: number
    PermitImage: number
    VehicleNumber: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    Id?: true
  }

  export type VehicleSumAggregateInputType = {
    Id?: true
  }

  export type VehicleMinAggregateInputType = {
    Id?: true
    Model?: true
    Year?: true
    Category?: true
    VehicleImage?: true
    VehicleInsuranceImage?: true
    PermitImage?: true
    VehicleNumber?: true
  }

  export type VehicleMaxAggregateInputType = {
    Id?: true
    Model?: true
    Year?: true
    Category?: true
    VehicleImage?: true
    VehicleInsuranceImage?: true
    PermitImage?: true
    VehicleNumber?: true
  }

  export type VehicleCountAggregateInputType = {
    Id?: true
    Model?: true
    Year?: true
    Category?: true
    VehicleImage?: true
    VehicleInsuranceImage?: true
    PermitImage?: true
    VehicleNumber?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    Id: number
    Model: string
    Year: string
    Category: string
    VehicleImage: string | null
    VehicleInsuranceImage: string | null
    PermitImage: string | null
    VehicleNumber: string
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Model?: boolean
    Year?: boolean
    Category?: boolean
    VehicleImage?: boolean
    VehicleInsuranceImage?: boolean
    PermitImage?: boolean
    VehicleNumber?: boolean
    Bookings?: boolean | Vehicle$BookingsArgs<ExtArgs>
    DriverVehicle?: boolean | Vehicle$DriverVehicleArgs<ExtArgs>
    OwnerVehicle?: boolean | Vehicle$OwnerVehicleArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Model?: boolean
    Year?: boolean
    Category?: boolean
    VehicleImage?: boolean
    VehicleInsuranceImage?: boolean
    PermitImage?: boolean
    VehicleNumber?: boolean
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Model?: boolean
    Year?: boolean
    Category?: boolean
    VehicleImage?: boolean
    VehicleInsuranceImage?: boolean
    PermitImage?: boolean
    VehicleNumber?: boolean
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    Id?: boolean
    Model?: boolean
    Year?: boolean
    Category?: boolean
    VehicleImage?: boolean
    VehicleInsuranceImage?: boolean
    PermitImage?: boolean
    VehicleNumber?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Model" | "Year" | "Category" | "VehicleImage" | "VehicleInsuranceImage" | "PermitImage" | "VehicleNumber", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | Vehicle$BookingsArgs<ExtArgs>
    DriverVehicle?: boolean | Vehicle$DriverVehicleArgs<ExtArgs>
    OwnerVehicle?: boolean | Vehicle$OwnerVehicleArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      Bookings: Prisma.$BookingsPayload<ExtArgs>[]
      DriverVehicle: Prisma.$DriverVehiclePayload<ExtArgs>[]
      OwnerVehicle: Prisma.$OwnerVehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Model: string
      Year: string
      Category: string
      VehicleImage: string | null
      VehicleInsuranceImage: string | null
      PermitImage: string | null
      VehicleNumber: string
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `Id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `Id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { Id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bookings<T extends Vehicle$BookingsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$BookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DriverVehicle<T extends Vehicle$DriverVehicleArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$DriverVehicleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OwnerVehicle<T extends Vehicle$OwnerVehicleArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$OwnerVehicleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerVehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly Id: FieldRef<"Vehicle", 'Int'>
    readonly Model: FieldRef<"Vehicle", 'String'>
    readonly Year: FieldRef<"Vehicle", 'String'>
    readonly Category: FieldRef<"Vehicle", 'String'>
    readonly VehicleImage: FieldRef<"Vehicle", 'String'>
    readonly VehicleInsuranceImage: FieldRef<"Vehicle", 'String'>
    readonly PermitImage: FieldRef<"Vehicle", 'String'>
    readonly VehicleNumber: FieldRef<"Vehicle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle.Bookings
   */
  export type Vehicle$BookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookings
     */
    omit?: BookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    where?: BookingsWhereInput
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    cursor?: BookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Vehicle.DriverVehicle
   */
  export type Vehicle$DriverVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicle
     */
    select?: DriverVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicle
     */
    omit?: DriverVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleInclude<ExtArgs> | null
    where?: DriverVehicleWhereInput
    orderBy?: DriverVehicleOrderByWithRelationInput | DriverVehicleOrderByWithRelationInput[]
    cursor?: DriverVehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverVehicleScalarFieldEnum | DriverVehicleScalarFieldEnum[]
  }

  /**
   * Vehicle.OwnerVehicle
   */
  export type Vehicle$OwnerVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerVehicle
     */
    select?: OwnerVehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerVehicle
     */
    omit?: OwnerVehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerVehicleInclude<ExtArgs> | null
    where?: OwnerVehicleWhereInput
    orderBy?: OwnerVehicleOrderByWithRelationInput | OwnerVehicleOrderByWithRelationInput[]
    cursor?: OwnerVehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerVehicleScalarFieldEnum | OwnerVehicleScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model otps
   */

  export type AggregateOtps = {
    _count: OtpsCountAggregateOutputType | null
    _avg: OtpsAvgAggregateOutputType | null
    _sum: OtpsSumAggregateOutputType | null
    _min: OtpsMinAggregateOutputType | null
    _max: OtpsMaxAggregateOutputType | null
  }

  export type OtpsAvgAggregateOutputType = {
    Id: number | null
  }

  export type OtpsSumAggregateOutputType = {
    Id: number | null
  }

  export type OtpsMinAggregateOutputType = {
    CreatedAt: Date | null
    ExpiresAt: Date | null
    Id: number | null
    MobileNumber: string | null
    Otp: string | null
  }

  export type OtpsMaxAggregateOutputType = {
    CreatedAt: Date | null
    ExpiresAt: Date | null
    Id: number | null
    MobileNumber: string | null
    Otp: string | null
  }

  export type OtpsCountAggregateOutputType = {
    CreatedAt: number
    ExpiresAt: number
    Id: number
    MobileNumber: number
    Otp: number
    _all: number
  }


  export type OtpsAvgAggregateInputType = {
    Id?: true
  }

  export type OtpsSumAggregateInputType = {
    Id?: true
  }

  export type OtpsMinAggregateInputType = {
    CreatedAt?: true
    ExpiresAt?: true
    Id?: true
    MobileNumber?: true
    Otp?: true
  }

  export type OtpsMaxAggregateInputType = {
    CreatedAt?: true
    ExpiresAt?: true
    Id?: true
    MobileNumber?: true
    Otp?: true
  }

  export type OtpsCountAggregateInputType = {
    CreatedAt?: true
    ExpiresAt?: true
    Id?: true
    MobileNumber?: true
    Otp?: true
    _all?: true
  }

  export type OtpsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to aggregate.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned otps
    **/
    _count?: true | OtpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpsMaxAggregateInputType
  }

  export type GetOtpsAggregateType<T extends OtpsAggregateArgs> = {
        [P in keyof T & keyof AggregateOtps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtps[P]>
      : GetScalarType<T[P], AggregateOtps[P]>
  }




  export type otpsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpsWhereInput
    orderBy?: otpsOrderByWithAggregationInput | otpsOrderByWithAggregationInput[]
    by: OtpsScalarFieldEnum[] | OtpsScalarFieldEnum
    having?: otpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpsCountAggregateInputType | true
    _avg?: OtpsAvgAggregateInputType
    _sum?: OtpsSumAggregateInputType
    _min?: OtpsMinAggregateInputType
    _max?: OtpsMaxAggregateInputType
  }

  export type OtpsGroupByOutputType = {
    CreatedAt: Date
    ExpiresAt: Date
    Id: number
    MobileNumber: string
    Otp: string
    _count: OtpsCountAggregateOutputType | null
    _avg: OtpsAvgAggregateOutputType | null
    _sum: OtpsSumAggregateOutputType | null
    _min: OtpsMinAggregateOutputType | null
    _max: OtpsMaxAggregateOutputType | null
  }

  type GetOtpsGroupByPayload<T extends otpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpsGroupByOutputType[P]>
            : GetScalarType<T[P], OtpsGroupByOutputType[P]>
        }
      >
    >


  export type otpsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CreatedAt?: boolean
    ExpiresAt?: boolean
    Id?: boolean
    MobileNumber?: boolean
    Otp?: boolean
  }, ExtArgs["result"]["otps"]>

  export type otpsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CreatedAt?: boolean
    ExpiresAt?: boolean
    Id?: boolean
    MobileNumber?: boolean
    Otp?: boolean
  }, ExtArgs["result"]["otps"]>

  export type otpsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CreatedAt?: boolean
    ExpiresAt?: boolean
    Id?: boolean
    MobileNumber?: boolean
    Otp?: boolean
  }, ExtArgs["result"]["otps"]>

  export type otpsSelectScalar = {
    CreatedAt?: boolean
    ExpiresAt?: boolean
    Id?: boolean
    MobileNumber?: boolean
    Otp?: boolean
  }

  export type otpsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"CreatedAt" | "ExpiresAt" | "Id" | "MobileNumber" | "Otp", ExtArgs["result"]["otps"]>

  export type $otpsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "otps"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CreatedAt: Date
      ExpiresAt: Date
      Id: number
      MobileNumber: string
      Otp: string
    }, ExtArgs["result"]["otps"]>
    composites: {}
  }

  type otpsGetPayload<S extends boolean | null | undefined | otpsDefaultArgs> = $Result.GetResult<Prisma.$otpsPayload, S>

  type otpsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<otpsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpsCountAggregateInputType | true
    }

  export interface otpsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['otps'], meta: { name: 'otps' } }
    /**
     * Find zero or one Otps that matches the filter.
     * @param {otpsFindUniqueArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends otpsFindUniqueArgs>(args: SelectSubset<T, otpsFindUniqueArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otps that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {otpsFindUniqueOrThrowArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends otpsFindUniqueOrThrowArgs>(args: SelectSubset<T, otpsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsFindFirstArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends otpsFindFirstArgs>(args?: SelectSubset<T, otpsFindFirstArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsFindFirstOrThrowArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends otpsFindFirstOrThrowArgs>(args?: SelectSubset<T, otpsFindFirstOrThrowArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otps.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otps.findMany({ take: 10 })
     * 
     * // Only select the `CreatedAt`
     * const otpsWithCreatedAtOnly = await prisma.otps.findMany({ select: { CreatedAt: true } })
     * 
     */
    findMany<T extends otpsFindManyArgs>(args?: SelectSubset<T, otpsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otps.
     * @param {otpsCreateArgs} args - Arguments to create a Otps.
     * @example
     * // Create one Otps
     * const Otps = await prisma.otps.create({
     *   data: {
     *     // ... data to create a Otps
     *   }
     * })
     * 
     */
    create<T extends otpsCreateArgs>(args: SelectSubset<T, otpsCreateArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {otpsCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otps = await prisma.otps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends otpsCreateManyArgs>(args?: SelectSubset<T, otpsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {otpsCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otps = await prisma.otps.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `CreatedAt`
     * const otpsWithCreatedAtOnly = await prisma.otps.createManyAndReturn({
     *   select: { CreatedAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends otpsCreateManyAndReturnArgs>(args?: SelectSubset<T, otpsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otps.
     * @param {otpsDeleteArgs} args - Arguments to delete one Otps.
     * @example
     * // Delete one Otps
     * const Otps = await prisma.otps.delete({
     *   where: {
     *     // ... filter to delete one Otps
     *   }
     * })
     * 
     */
    delete<T extends otpsDeleteArgs>(args: SelectSubset<T, otpsDeleteArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otps.
     * @param {otpsUpdateArgs} args - Arguments to update one Otps.
     * @example
     * // Update one Otps
     * const otps = await prisma.otps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends otpsUpdateArgs>(args: SelectSubset<T, otpsUpdateArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {otpsDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends otpsDeleteManyArgs>(args?: SelectSubset<T, otpsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otps = await prisma.otps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends otpsUpdateManyArgs>(args: SelectSubset<T, otpsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {otpsUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otps = await prisma.otps.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `CreatedAt`
     * const otpsWithCreatedAtOnly = await prisma.otps.updateManyAndReturn({
     *   select: { CreatedAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends otpsUpdateManyAndReturnArgs>(args: SelectSubset<T, otpsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otps.
     * @param {otpsUpsertArgs} args - Arguments to update or create a Otps.
     * @example
     * // Update or create a Otps
     * const otps = await prisma.otps.upsert({
     *   create: {
     *     // ... data to create a Otps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otps we want to update
     *   }
     * })
     */
    upsert<T extends otpsUpsertArgs>(args: SelectSubset<T, otpsUpsertArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otps.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends otpsCountArgs>(
      args?: Subset<T, otpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpsAggregateArgs>(args: Subset<T, OtpsAggregateArgs>): Prisma.PrismaPromise<GetOtpsAggregateType<T>>

    /**
     * Group by Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends otpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: otpsGroupByArgs['orderBy'] }
        : { orderBy?: otpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, otpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the otps model
   */
  readonly fields: otpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for otps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__otpsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the otps model
   */
  interface otpsFieldRefs {
    readonly CreatedAt: FieldRef<"otps", 'DateTime'>
    readonly ExpiresAt: FieldRef<"otps", 'DateTime'>
    readonly Id: FieldRef<"otps", 'Int'>
    readonly MobileNumber: FieldRef<"otps", 'String'>
    readonly Otp: FieldRef<"otps", 'String'>
  }
    

  // Custom InputTypes
  /**
   * otps findUnique
   */
  export type otpsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps findUniqueOrThrow
   */
  export type otpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps findFirst
   */
  export type otpsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpsScalarFieldEnum | OtpsScalarFieldEnum[]
  }

  /**
   * otps findFirstOrThrow
   */
  export type otpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpsScalarFieldEnum | OtpsScalarFieldEnum[]
  }

  /**
   * otps findMany
   */
  export type otpsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing otps.
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    distinct?: OtpsScalarFieldEnum | OtpsScalarFieldEnum[]
  }

  /**
   * otps create
   */
  export type otpsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * The data needed to create a otps.
     */
    data: XOR<otpsCreateInput, otpsUncheckedCreateInput>
  }

  /**
   * otps createMany
   */
  export type otpsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many otps.
     */
    data: otpsCreateManyInput | otpsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otps createManyAndReturn
   */
  export type otpsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * The data used to create many otps.
     */
    data: otpsCreateManyInput | otpsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otps update
   */
  export type otpsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * The data needed to update a otps.
     */
    data: XOR<otpsUpdateInput, otpsUncheckedUpdateInput>
    /**
     * Choose, which otps to update.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps updateMany
   */
  export type otpsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update otps.
     */
    data: XOR<otpsUpdateManyMutationInput, otpsUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpsWhereInput
    /**
     * Limit how many otps to update.
     */
    limit?: number
  }

  /**
   * otps updateManyAndReturn
   */
  export type otpsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * The data used to update otps.
     */
    data: XOR<otpsUpdateManyMutationInput, otpsUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpsWhereInput
    /**
     * Limit how many otps to update.
     */
    limit?: number
  }

  /**
   * otps upsert
   */
  export type otpsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * The filter to search for the otps to update in case it exists.
     */
    where: otpsWhereUniqueInput
    /**
     * In case the otps found by the `where` argument doesn't exist, create a new otps with this data.
     */
    create: XOR<otpsCreateInput, otpsUncheckedCreateInput>
    /**
     * In case the otps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<otpsUpdateInput, otpsUncheckedUpdateInput>
  }

  /**
   * otps delete
   */
  export type otpsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Filter which otps to delete.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps deleteMany
   */
  export type otpsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to delete
     */
    where?: otpsWhereInput
    /**
     * Limit how many otps to delete.
     */
    limit?: number
  }

  /**
   * otps without action
   */
  export type otpsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    permission_audit_logs?: boolean | admin$permission_audit_logsArgs<ExtArgs>
    roles?: boolean | admin$rolesArgs<ExtArgs>
    user_roles_user_roles_adminIdToadmin?: boolean | admin$user_roles_user_roles_adminIdToadminArgs<ExtArgs>
    user_roles_user_roles_assignedByIdToadmin?: boolean | admin$user_roles_user_roles_assignedByIdToadminArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["admin"]>

  export type adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["admin"]>

  export type adminSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }

  export type adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "fullName" | "isActive" | "createdAt" | "updatedAt" | "lastLogin", ExtArgs["result"]["admin"]>
  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_audit_logs?: boolean | admin$permission_audit_logsArgs<ExtArgs>
    roles?: boolean | admin$rolesArgs<ExtArgs>
    user_roles_user_roles_adminIdToadmin?: boolean | admin$user_roles_user_roles_adminIdToadminArgs<ExtArgs>
    user_roles_user_roles_assignedByIdToadmin?: boolean | admin$user_roles_user_roles_assignedByIdToadminArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      permission_audit_logs: Prisma.$permission_audit_logsPayload<ExtArgs>[]
      roles: Prisma.$rolesPayload<ExtArgs>[]
      user_roles_user_roles_adminIdToadmin: Prisma.$user_rolesPayload<ExtArgs>[]
      user_roles_user_roles_assignedByIdToadmin: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      fullName: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastLogin: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adminCreateManyAndReturnArgs>(args?: SelectSubset<T, adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {adminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends adminUpdateManyAndReturnArgs>(args: SelectSubset<T, adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission_audit_logs<T extends admin$permission_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, admin$permission_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends admin$rolesArgs<ExtArgs> = {}>(args?: Subset<T, admin$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_roles_user_roles_adminIdToadmin<T extends admin$user_roles_user_roles_adminIdToadminArgs<ExtArgs> = {}>(args?: Subset<T, admin$user_roles_user_roles_adminIdToadminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_roles_user_roles_assignedByIdToadmin<T extends admin$user_roles_user_roles_assignedByIdToadminArgs<ExtArgs> = {}>(args?: Subset<T, admin$user_roles_user_roles_assignedByIdToadminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'String'>
    readonly email: FieldRef<"admin", 'String'>
    readonly passwordHash: FieldRef<"admin", 'String'>
    readonly fullName: FieldRef<"admin", 'String'>
    readonly isActive: FieldRef<"admin", 'Boolean'>
    readonly createdAt: FieldRef<"admin", 'DateTime'>
    readonly updatedAt: FieldRef<"admin", 'DateTime'>
    readonly lastLogin: FieldRef<"admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin createManyAndReturn
   */
  export type adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin updateManyAndReturn
   */
  export type adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admin.permission_audit_logs
   */
  export type admin$permission_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    where?: permission_audit_logsWhereInput
    orderBy?: permission_audit_logsOrderByWithRelationInput | permission_audit_logsOrderByWithRelationInput[]
    cursor?: permission_audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Permission_audit_logsScalarFieldEnum | Permission_audit_logsScalarFieldEnum[]
  }

  /**
   * admin.roles
   */
  export type admin$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    cursor?: rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * admin.user_roles_user_roles_adminIdToadmin
   */
  export type admin$user_roles_user_roles_adminIdToadminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * admin.user_roles_user_roles_assignedByIdToadmin
   */
  export type admin$user_roles_user_roles_assignedByIdToadminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model permission_audit_logs
   */

  export type AggregatePermission_audit_logs = {
    _count: Permission_audit_logsCountAggregateOutputType | null
    _min: Permission_audit_logsMinAggregateOutputType | null
    _max: Permission_audit_logsMaxAggregateOutputType | null
  }

  export type Permission_audit_logsMinAggregateOutputType = {
    id: string | null
    actionType: $Enums.AuditActionType | null
    details: string | null
    actionTimestamp: Date | null
    adminId: string | null
    roleId: string | null
    permissionId: string | null
  }

  export type Permission_audit_logsMaxAggregateOutputType = {
    id: string | null
    actionType: $Enums.AuditActionType | null
    details: string | null
    actionTimestamp: Date | null
    adminId: string | null
    roleId: string | null
    permissionId: string | null
  }

  export type Permission_audit_logsCountAggregateOutputType = {
    id: number
    actionType: number
    details: number
    actionTimestamp: number
    adminId: number
    roleId: number
    permissionId: number
    _all: number
  }


  export type Permission_audit_logsMinAggregateInputType = {
    id?: true
    actionType?: true
    details?: true
    actionTimestamp?: true
    adminId?: true
    roleId?: true
    permissionId?: true
  }

  export type Permission_audit_logsMaxAggregateInputType = {
    id?: true
    actionType?: true
    details?: true
    actionTimestamp?: true
    adminId?: true
    roleId?: true
    permissionId?: true
  }

  export type Permission_audit_logsCountAggregateInputType = {
    id?: true
    actionType?: true
    details?: true
    actionTimestamp?: true
    adminId?: true
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type Permission_audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission_audit_logs to aggregate.
     */
    where?: permission_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_audit_logs to fetch.
     */
    orderBy?: permission_audit_logsOrderByWithRelationInput | permission_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permission_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permission_audit_logs
    **/
    _count?: true | Permission_audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Permission_audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Permission_audit_logsMaxAggregateInputType
  }

  export type GetPermission_audit_logsAggregateType<T extends Permission_audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission_audit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission_audit_logs[P]>
      : GetScalarType<T[P], AggregatePermission_audit_logs[P]>
  }




  export type permission_audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permission_audit_logsWhereInput
    orderBy?: permission_audit_logsOrderByWithAggregationInput | permission_audit_logsOrderByWithAggregationInput[]
    by: Permission_audit_logsScalarFieldEnum[] | Permission_audit_logsScalarFieldEnum
    having?: permission_audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Permission_audit_logsCountAggregateInputType | true
    _min?: Permission_audit_logsMinAggregateInputType
    _max?: Permission_audit_logsMaxAggregateInputType
  }

  export type Permission_audit_logsGroupByOutputType = {
    id: string
    actionType: $Enums.AuditActionType
    details: string | null
    actionTimestamp: Date
    adminId: string
    roleId: string | null
    permissionId: string | null
    _count: Permission_audit_logsCountAggregateOutputType | null
    _min: Permission_audit_logsMinAggregateOutputType | null
    _max: Permission_audit_logsMaxAggregateOutputType | null
  }

  type GetPermission_audit_logsGroupByPayload<T extends permission_audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Permission_audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Permission_audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Permission_audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Permission_audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type permission_audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionType?: boolean
    details?: boolean
    actionTimestamp?: boolean
    adminId?: boolean
    roleId?: boolean
    permissionId?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
    permissions?: boolean | permission_audit_logs$permissionsArgs<ExtArgs>
    roles?: boolean | permission_audit_logs$rolesArgs<ExtArgs>
  }, ExtArgs["result"]["permission_audit_logs"]>

  export type permission_audit_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionType?: boolean
    details?: boolean
    actionTimestamp?: boolean
    adminId?: boolean
    roleId?: boolean
    permissionId?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
    permissions?: boolean | permission_audit_logs$permissionsArgs<ExtArgs>
    roles?: boolean | permission_audit_logs$rolesArgs<ExtArgs>
  }, ExtArgs["result"]["permission_audit_logs"]>

  export type permission_audit_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionType?: boolean
    details?: boolean
    actionTimestamp?: boolean
    adminId?: boolean
    roleId?: boolean
    permissionId?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
    permissions?: boolean | permission_audit_logs$permissionsArgs<ExtArgs>
    roles?: boolean | permission_audit_logs$rolesArgs<ExtArgs>
  }, ExtArgs["result"]["permission_audit_logs"]>

  export type permission_audit_logsSelectScalar = {
    id?: boolean
    actionType?: boolean
    details?: boolean
    actionTimestamp?: boolean
    adminId?: boolean
    roleId?: boolean
    permissionId?: boolean
  }

  export type permission_audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actionType" | "details" | "actionTimestamp" | "adminId" | "roleId" | "permissionId", ExtArgs["result"]["permission_audit_logs"]>
  export type permission_audit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
    permissions?: boolean | permission_audit_logs$permissionsArgs<ExtArgs>
    roles?: boolean | permission_audit_logs$rolesArgs<ExtArgs>
  }
  export type permission_audit_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
    permissions?: boolean | permission_audit_logs$permissionsArgs<ExtArgs>
    roles?: boolean | permission_audit_logs$rolesArgs<ExtArgs>
  }
  export type permission_audit_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
    permissions?: boolean | permission_audit_logs$permissionsArgs<ExtArgs>
    roles?: boolean | permission_audit_logs$rolesArgs<ExtArgs>
  }

  export type $permission_audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permission_audit_logs"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs>
      permissions: Prisma.$permissionsPayload<ExtArgs> | null
      roles: Prisma.$rolesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actionType: $Enums.AuditActionType
      details: string | null
      actionTimestamp: Date
      adminId: string
      roleId: string | null
      permissionId: string | null
    }, ExtArgs["result"]["permission_audit_logs"]>
    composites: {}
  }

  type permission_audit_logsGetPayload<S extends boolean | null | undefined | permission_audit_logsDefaultArgs> = $Result.GetResult<Prisma.$permission_audit_logsPayload, S>

  type permission_audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permission_audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Permission_audit_logsCountAggregateInputType | true
    }

  export interface permission_audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission_audit_logs'], meta: { name: 'permission_audit_logs' } }
    /**
     * Find zero or one Permission_audit_logs that matches the filter.
     * @param {permission_audit_logsFindUniqueArgs} args - Arguments to find a Permission_audit_logs
     * @example
     * // Get one Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permission_audit_logsFindUniqueArgs>(args: SelectSubset<T, permission_audit_logsFindUniqueArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission_audit_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permission_audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Permission_audit_logs
     * @example
     * // Get one Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permission_audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, permission_audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission_audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_audit_logsFindFirstArgs} args - Arguments to find a Permission_audit_logs
     * @example
     * // Get one Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permission_audit_logsFindFirstArgs>(args?: SelectSubset<T, permission_audit_logsFindFirstArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission_audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_audit_logsFindFirstOrThrowArgs} args - Arguments to find a Permission_audit_logs
     * @example
     * // Get one Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permission_audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, permission_audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permission_audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.findMany()
     * 
     * // Get first 10 Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permission_audit_logsWithIdOnly = await prisma.permission_audit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permission_audit_logsFindManyArgs>(args?: SelectSubset<T, permission_audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission_audit_logs.
     * @param {permission_audit_logsCreateArgs} args - Arguments to create a Permission_audit_logs.
     * @example
     * // Create one Permission_audit_logs
     * const Permission_audit_logs = await prisma.permission_audit_logs.create({
     *   data: {
     *     // ... data to create a Permission_audit_logs
     *   }
     * })
     * 
     */
    create<T extends permission_audit_logsCreateArgs>(args: SelectSubset<T, permission_audit_logsCreateArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permission_audit_logs.
     * @param {permission_audit_logsCreateManyArgs} args - Arguments to create many Permission_audit_logs.
     * @example
     * // Create many Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permission_audit_logsCreateManyArgs>(args?: SelectSubset<T, permission_audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permission_audit_logs and returns the data saved in the database.
     * @param {permission_audit_logsCreateManyAndReturnArgs} args - Arguments to create many Permission_audit_logs.
     * @example
     * // Create many Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permission_audit_logs and only return the `id`
     * const permission_audit_logsWithIdOnly = await prisma.permission_audit_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permission_audit_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, permission_audit_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission_audit_logs.
     * @param {permission_audit_logsDeleteArgs} args - Arguments to delete one Permission_audit_logs.
     * @example
     * // Delete one Permission_audit_logs
     * const Permission_audit_logs = await prisma.permission_audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Permission_audit_logs
     *   }
     * })
     * 
     */
    delete<T extends permission_audit_logsDeleteArgs>(args: SelectSubset<T, permission_audit_logsDeleteArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission_audit_logs.
     * @param {permission_audit_logsUpdateArgs} args - Arguments to update one Permission_audit_logs.
     * @example
     * // Update one Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permission_audit_logsUpdateArgs>(args: SelectSubset<T, permission_audit_logsUpdateArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permission_audit_logs.
     * @param {permission_audit_logsDeleteManyArgs} args - Arguments to filter Permission_audit_logs to delete.
     * @example
     * // Delete a few Permission_audit_logs
     * const { count } = await prisma.permission_audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permission_audit_logsDeleteManyArgs>(args?: SelectSubset<T, permission_audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permission_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permission_audit_logsUpdateManyArgs>(args: SelectSubset<T, permission_audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permission_audit_logs and returns the data updated in the database.
     * @param {permission_audit_logsUpdateManyAndReturnArgs} args - Arguments to update many Permission_audit_logs.
     * @example
     * // Update many Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permission_audit_logs and only return the `id`
     * const permission_audit_logsWithIdOnly = await prisma.permission_audit_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends permission_audit_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, permission_audit_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission_audit_logs.
     * @param {permission_audit_logsUpsertArgs} args - Arguments to update or create a Permission_audit_logs.
     * @example
     * // Update or create a Permission_audit_logs
     * const permission_audit_logs = await prisma.permission_audit_logs.upsert({
     *   create: {
     *     // ... data to create a Permission_audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission_audit_logs we want to update
     *   }
     * })
     */
    upsert<T extends permission_audit_logsUpsertArgs>(args: SelectSubset<T, permission_audit_logsUpsertArgs<ExtArgs>>): Prisma__permission_audit_logsClient<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permission_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_audit_logsCountArgs} args - Arguments to filter Permission_audit_logs to count.
     * @example
     * // Count the number of Permission_audit_logs
     * const count = await prisma.permission_audit_logs.count({
     *   where: {
     *     // ... the filter for the Permission_audit_logs we want to count
     *   }
     * })
    **/
    count<T extends permission_audit_logsCountArgs>(
      args?: Subset<T, permission_audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Permission_audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Permission_audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Permission_audit_logsAggregateArgs>(args: Subset<T, Permission_audit_logsAggregateArgs>): Prisma.PrismaPromise<GetPermission_audit_logsAggregateType<T>>

    /**
     * Group by Permission_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permission_audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permission_audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: permission_audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permission_audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermission_audit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission_audit_logs model
   */
  readonly fields: permission_audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission_audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permission_audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permissions<T extends permission_audit_logs$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permission_audit_logs$permissionsArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roles<T extends permission_audit_logs$rolesArgs<ExtArgs> = {}>(args?: Subset<T, permission_audit_logs$rolesArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permission_audit_logs model
   */
  interface permission_audit_logsFieldRefs {
    readonly id: FieldRef<"permission_audit_logs", 'String'>
    readonly actionType: FieldRef<"permission_audit_logs", 'AuditActionType'>
    readonly details: FieldRef<"permission_audit_logs", 'String'>
    readonly actionTimestamp: FieldRef<"permission_audit_logs", 'DateTime'>
    readonly adminId: FieldRef<"permission_audit_logs", 'String'>
    readonly roleId: FieldRef<"permission_audit_logs", 'String'>
    readonly permissionId: FieldRef<"permission_audit_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * permission_audit_logs findUnique
   */
  export type permission_audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which permission_audit_logs to fetch.
     */
    where: permission_audit_logsWhereUniqueInput
  }

  /**
   * permission_audit_logs findUniqueOrThrow
   */
  export type permission_audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which permission_audit_logs to fetch.
     */
    where: permission_audit_logsWhereUniqueInput
  }

  /**
   * permission_audit_logs findFirst
   */
  export type permission_audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which permission_audit_logs to fetch.
     */
    where?: permission_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_audit_logs to fetch.
     */
    orderBy?: permission_audit_logsOrderByWithRelationInput | permission_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permission_audit_logs.
     */
    cursor?: permission_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permission_audit_logs.
     */
    distinct?: Permission_audit_logsScalarFieldEnum | Permission_audit_logsScalarFieldEnum[]
  }

  /**
   * permission_audit_logs findFirstOrThrow
   */
  export type permission_audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which permission_audit_logs to fetch.
     */
    where?: permission_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_audit_logs to fetch.
     */
    orderBy?: permission_audit_logsOrderByWithRelationInput | permission_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permission_audit_logs.
     */
    cursor?: permission_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permission_audit_logs.
     */
    distinct?: Permission_audit_logsScalarFieldEnum | Permission_audit_logsScalarFieldEnum[]
  }

  /**
   * permission_audit_logs findMany
   */
  export type permission_audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which permission_audit_logs to fetch.
     */
    where?: permission_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_audit_logs to fetch.
     */
    orderBy?: permission_audit_logsOrderByWithRelationInput | permission_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permission_audit_logs.
     */
    cursor?: permission_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_audit_logs.
     */
    skip?: number
    distinct?: Permission_audit_logsScalarFieldEnum | Permission_audit_logsScalarFieldEnum[]
  }

  /**
   * permission_audit_logs create
   */
  export type permission_audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a permission_audit_logs.
     */
    data: XOR<permission_audit_logsCreateInput, permission_audit_logsUncheckedCreateInput>
  }

  /**
   * permission_audit_logs createMany
   */
  export type permission_audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permission_audit_logs.
     */
    data: permission_audit_logsCreateManyInput | permission_audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission_audit_logs createManyAndReturn
   */
  export type permission_audit_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * The data used to create many permission_audit_logs.
     */
    data: permission_audit_logsCreateManyInput | permission_audit_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * permission_audit_logs update
   */
  export type permission_audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a permission_audit_logs.
     */
    data: XOR<permission_audit_logsUpdateInput, permission_audit_logsUncheckedUpdateInput>
    /**
     * Choose, which permission_audit_logs to update.
     */
    where: permission_audit_logsWhereUniqueInput
  }

  /**
   * permission_audit_logs updateMany
   */
  export type permission_audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permission_audit_logs.
     */
    data: XOR<permission_audit_logsUpdateManyMutationInput, permission_audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which permission_audit_logs to update
     */
    where?: permission_audit_logsWhereInput
    /**
     * Limit how many permission_audit_logs to update.
     */
    limit?: number
  }

  /**
   * permission_audit_logs updateManyAndReturn
   */
  export type permission_audit_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * The data used to update permission_audit_logs.
     */
    data: XOR<permission_audit_logsUpdateManyMutationInput, permission_audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which permission_audit_logs to update
     */
    where?: permission_audit_logsWhereInput
    /**
     * Limit how many permission_audit_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * permission_audit_logs upsert
   */
  export type permission_audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the permission_audit_logs to update in case it exists.
     */
    where: permission_audit_logsWhereUniqueInput
    /**
     * In case the permission_audit_logs found by the `where` argument doesn't exist, create a new permission_audit_logs with this data.
     */
    create: XOR<permission_audit_logsCreateInput, permission_audit_logsUncheckedCreateInput>
    /**
     * In case the permission_audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permission_audit_logsUpdateInput, permission_audit_logsUncheckedUpdateInput>
  }

  /**
   * permission_audit_logs delete
   */
  export type permission_audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    /**
     * Filter which permission_audit_logs to delete.
     */
    where: permission_audit_logsWhereUniqueInput
  }

  /**
   * permission_audit_logs deleteMany
   */
  export type permission_audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission_audit_logs to delete
     */
    where?: permission_audit_logsWhereInput
    /**
     * Limit how many permission_audit_logs to delete.
     */
    limit?: number
  }

  /**
   * permission_audit_logs.permissions
   */
  export type permission_audit_logs$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    where?: permissionsWhereInput
  }

  /**
   * permission_audit_logs.roles
   */
  export type permission_audit_logs$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    where?: rolesWhereInput
  }

  /**
   * permission_audit_logs without action
   */
  export type permission_audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
  }


  /**
   * Model permission_categories
   */

  export type AggregatePermission_categories = {
    _count: Permission_categoriesCountAggregateOutputType | null
    _avg: Permission_categoriesAvgAggregateOutputType | null
    _sum: Permission_categoriesSumAggregateOutputType | null
    _min: Permission_categoriesMinAggregateOutputType | null
    _max: Permission_categoriesMaxAggregateOutputType | null
  }

  export type Permission_categoriesAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type Permission_categoriesSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type Permission_categoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    displayOrder: number | null
  }

  export type Permission_categoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    displayOrder: number | null
  }

  export type Permission_categoriesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    displayOrder: number
    _all: number
  }


  export type Permission_categoriesAvgAggregateInputType = {
    displayOrder?: true
  }

  export type Permission_categoriesSumAggregateInputType = {
    displayOrder?: true
  }

  export type Permission_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    displayOrder?: true
  }

  export type Permission_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    displayOrder?: true
  }

  export type Permission_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    displayOrder?: true
    _all?: true
  }

  export type Permission_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission_categories to aggregate.
     */
    where?: permission_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_categories to fetch.
     */
    orderBy?: permission_categoriesOrderByWithRelationInput | permission_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permission_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permission_categories
    **/
    _count?: true | Permission_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Permission_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Permission_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Permission_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Permission_categoriesMaxAggregateInputType
  }

  export type GetPermission_categoriesAggregateType<T extends Permission_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission_categories[P]>
      : GetScalarType<T[P], AggregatePermission_categories[P]>
  }




  export type permission_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permission_categoriesWhereInput
    orderBy?: permission_categoriesOrderByWithAggregationInput | permission_categoriesOrderByWithAggregationInput[]
    by: Permission_categoriesScalarFieldEnum[] | Permission_categoriesScalarFieldEnum
    having?: permission_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Permission_categoriesCountAggregateInputType | true
    _avg?: Permission_categoriesAvgAggregateInputType
    _sum?: Permission_categoriesSumAggregateInputType
    _min?: Permission_categoriesMinAggregateInputType
    _max?: Permission_categoriesMaxAggregateInputType
  }

  export type Permission_categoriesGroupByOutputType = {
    id: string
    name: string
    description: string | null
    icon: string | null
    displayOrder: number
    _count: Permission_categoriesCountAggregateOutputType | null
    _avg: Permission_categoriesAvgAggregateOutputType | null
    _sum: Permission_categoriesSumAggregateOutputType | null
    _min: Permission_categoriesMinAggregateOutputType | null
    _max: Permission_categoriesMaxAggregateOutputType | null
  }

  type GetPermission_categoriesGroupByPayload<T extends permission_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Permission_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Permission_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Permission_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Permission_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type permission_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
    permissions?: boolean | permission_categories$permissionsArgs<ExtArgs>
    _count?: boolean | Permission_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission_categories"]>

  export type permission_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["permission_categories"]>

  export type permission_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["permission_categories"]>

  export type permission_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    displayOrder?: boolean
  }

  export type permission_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "displayOrder", ExtArgs["result"]["permission_categories"]>
  export type permission_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permission_categories$permissionsArgs<ExtArgs>
    _count?: boolean | Permission_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permission_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type permission_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $permission_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permission_categories"
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      icon: string | null
      displayOrder: number
    }, ExtArgs["result"]["permission_categories"]>
    composites: {}
  }

  type permission_categoriesGetPayload<S extends boolean | null | undefined | permission_categoriesDefaultArgs> = $Result.GetResult<Prisma.$permission_categoriesPayload, S>

  type permission_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permission_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Permission_categoriesCountAggregateInputType | true
    }

  export interface permission_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission_categories'], meta: { name: 'permission_categories' } }
    /**
     * Find zero or one Permission_categories that matches the filter.
     * @param {permission_categoriesFindUniqueArgs} args - Arguments to find a Permission_categories
     * @example
     * // Get one Permission_categories
     * const permission_categories = await prisma.permission_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permission_categoriesFindUniqueArgs>(args: SelectSubset<T, permission_categoriesFindUniqueArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permission_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Permission_categories
     * @example
     * // Get one Permission_categories
     * const permission_categories = await prisma.permission_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permission_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, permission_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_categoriesFindFirstArgs} args - Arguments to find a Permission_categories
     * @example
     * // Get one Permission_categories
     * const permission_categories = await prisma.permission_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permission_categoriesFindFirstArgs>(args?: SelectSubset<T, permission_categoriesFindFirstArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_categoriesFindFirstOrThrowArgs} args - Arguments to find a Permission_categories
     * @example
     * // Get one Permission_categories
     * const permission_categories = await prisma.permission_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permission_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, permission_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permission_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permission_categories
     * const permission_categories = await prisma.permission_categories.findMany()
     * 
     * // Get first 10 Permission_categories
     * const permission_categories = await prisma.permission_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permission_categoriesWithIdOnly = await prisma.permission_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permission_categoriesFindManyArgs>(args?: SelectSubset<T, permission_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission_categories.
     * @param {permission_categoriesCreateArgs} args - Arguments to create a Permission_categories.
     * @example
     * // Create one Permission_categories
     * const Permission_categories = await prisma.permission_categories.create({
     *   data: {
     *     // ... data to create a Permission_categories
     *   }
     * })
     * 
     */
    create<T extends permission_categoriesCreateArgs>(args: SelectSubset<T, permission_categoriesCreateArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permission_categories.
     * @param {permission_categoriesCreateManyArgs} args - Arguments to create many Permission_categories.
     * @example
     * // Create many Permission_categories
     * const permission_categories = await prisma.permission_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permission_categoriesCreateManyArgs>(args?: SelectSubset<T, permission_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permission_categories and returns the data saved in the database.
     * @param {permission_categoriesCreateManyAndReturnArgs} args - Arguments to create many Permission_categories.
     * @example
     * // Create many Permission_categories
     * const permission_categories = await prisma.permission_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permission_categories and only return the `id`
     * const permission_categoriesWithIdOnly = await prisma.permission_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permission_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, permission_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission_categories.
     * @param {permission_categoriesDeleteArgs} args - Arguments to delete one Permission_categories.
     * @example
     * // Delete one Permission_categories
     * const Permission_categories = await prisma.permission_categories.delete({
     *   where: {
     *     // ... filter to delete one Permission_categories
     *   }
     * })
     * 
     */
    delete<T extends permission_categoriesDeleteArgs>(args: SelectSubset<T, permission_categoriesDeleteArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission_categories.
     * @param {permission_categoriesUpdateArgs} args - Arguments to update one Permission_categories.
     * @example
     * // Update one Permission_categories
     * const permission_categories = await prisma.permission_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permission_categoriesUpdateArgs>(args: SelectSubset<T, permission_categoriesUpdateArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permission_categories.
     * @param {permission_categoriesDeleteManyArgs} args - Arguments to filter Permission_categories to delete.
     * @example
     * // Delete a few Permission_categories
     * const { count } = await prisma.permission_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permission_categoriesDeleteManyArgs>(args?: SelectSubset<T, permission_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permission_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permission_categories
     * const permission_categories = await prisma.permission_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permission_categoriesUpdateManyArgs>(args: SelectSubset<T, permission_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permission_categories and returns the data updated in the database.
     * @param {permission_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Permission_categories.
     * @example
     * // Update many Permission_categories
     * const permission_categories = await prisma.permission_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permission_categories and only return the `id`
     * const permission_categoriesWithIdOnly = await prisma.permission_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends permission_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, permission_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission_categories.
     * @param {permission_categoriesUpsertArgs} args - Arguments to update or create a Permission_categories.
     * @example
     * // Update or create a Permission_categories
     * const permission_categories = await prisma.permission_categories.upsert({
     *   create: {
     *     // ... data to create a Permission_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission_categories we want to update
     *   }
     * })
     */
    upsert<T extends permission_categoriesUpsertArgs>(args: SelectSubset<T, permission_categoriesUpsertArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permission_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_categoriesCountArgs} args - Arguments to filter Permission_categories to count.
     * @example
     * // Count the number of Permission_categories
     * const count = await prisma.permission_categories.count({
     *   where: {
     *     // ... the filter for the Permission_categories we want to count
     *   }
     * })
    **/
    count<T extends permission_categoriesCountArgs>(
      args?: Subset<T, permission_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Permission_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Permission_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Permission_categoriesAggregateArgs>(args: Subset<T, Permission_categoriesAggregateArgs>): Prisma.PrismaPromise<GetPermission_categoriesAggregateType<T>>

    /**
     * Group by Permission_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permission_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permission_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permission_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: permission_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permission_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermission_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission_categories model
   */
  readonly fields: permission_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permission_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends permission_categories$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permission_categories$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permission_categories model
   */
  interface permission_categoriesFieldRefs {
    readonly id: FieldRef<"permission_categories", 'String'>
    readonly name: FieldRef<"permission_categories", 'String'>
    readonly description: FieldRef<"permission_categories", 'String'>
    readonly icon: FieldRef<"permission_categories", 'String'>
    readonly displayOrder: FieldRef<"permission_categories", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * permission_categories findUnique
   */
  export type permission_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which permission_categories to fetch.
     */
    where: permission_categoriesWhereUniqueInput
  }

  /**
   * permission_categories findUniqueOrThrow
   */
  export type permission_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which permission_categories to fetch.
     */
    where: permission_categoriesWhereUniqueInput
  }

  /**
   * permission_categories findFirst
   */
  export type permission_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which permission_categories to fetch.
     */
    where?: permission_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_categories to fetch.
     */
    orderBy?: permission_categoriesOrderByWithRelationInput | permission_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permission_categories.
     */
    cursor?: permission_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permission_categories.
     */
    distinct?: Permission_categoriesScalarFieldEnum | Permission_categoriesScalarFieldEnum[]
  }

  /**
   * permission_categories findFirstOrThrow
   */
  export type permission_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which permission_categories to fetch.
     */
    where?: permission_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_categories to fetch.
     */
    orderBy?: permission_categoriesOrderByWithRelationInput | permission_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permission_categories.
     */
    cursor?: permission_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permission_categories.
     */
    distinct?: Permission_categoriesScalarFieldEnum | Permission_categoriesScalarFieldEnum[]
  }

  /**
   * permission_categories findMany
   */
  export type permission_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which permission_categories to fetch.
     */
    where?: permission_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permission_categories to fetch.
     */
    orderBy?: permission_categoriesOrderByWithRelationInput | permission_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permission_categories.
     */
    cursor?: permission_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permission_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permission_categories.
     */
    skip?: number
    distinct?: Permission_categoriesScalarFieldEnum | Permission_categoriesScalarFieldEnum[]
  }

  /**
   * permission_categories create
   */
  export type permission_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a permission_categories.
     */
    data: XOR<permission_categoriesCreateInput, permission_categoriesUncheckedCreateInput>
  }

  /**
   * permission_categories createMany
   */
  export type permission_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permission_categories.
     */
    data: permission_categoriesCreateManyInput | permission_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission_categories createManyAndReturn
   */
  export type permission_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many permission_categories.
     */
    data: permission_categoriesCreateManyInput | permission_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission_categories update
   */
  export type permission_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a permission_categories.
     */
    data: XOR<permission_categoriesUpdateInput, permission_categoriesUncheckedUpdateInput>
    /**
     * Choose, which permission_categories to update.
     */
    where: permission_categoriesWhereUniqueInput
  }

  /**
   * permission_categories updateMany
   */
  export type permission_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permission_categories.
     */
    data: XOR<permission_categoriesUpdateManyMutationInput, permission_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which permission_categories to update
     */
    where?: permission_categoriesWhereInput
    /**
     * Limit how many permission_categories to update.
     */
    limit?: number
  }

  /**
   * permission_categories updateManyAndReturn
   */
  export type permission_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update permission_categories.
     */
    data: XOR<permission_categoriesUpdateManyMutationInput, permission_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which permission_categories to update
     */
    where?: permission_categoriesWhereInput
    /**
     * Limit how many permission_categories to update.
     */
    limit?: number
  }

  /**
   * permission_categories upsert
   */
  export type permission_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the permission_categories to update in case it exists.
     */
    where: permission_categoriesWhereUniqueInput
    /**
     * In case the permission_categories found by the `where` argument doesn't exist, create a new permission_categories with this data.
     */
    create: XOR<permission_categoriesCreateInput, permission_categoriesUncheckedCreateInput>
    /**
     * In case the permission_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permission_categoriesUpdateInput, permission_categoriesUncheckedUpdateInput>
  }

  /**
   * permission_categories delete
   */
  export type permission_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
    /**
     * Filter which permission_categories to delete.
     */
    where: permission_categoriesWhereUniqueInput
  }

  /**
   * permission_categories deleteMany
   */
  export type permission_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission_categories to delete
     */
    where?: permission_categoriesWhereInput
    /**
     * Limit how many permission_categories to delete.
     */
    limit?: number
  }

  /**
   * permission_categories.permissions
   */
  export type permission_categories$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    where?: permissionsWhereInput
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    cursor?: permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permission_categories without action
   */
  export type permission_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_categories
     */
    select?: permission_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_categories
     */
    omit?: permission_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    categoryId: string | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    categoryId: string | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    categoryId: number
    _all: number
  }


  export type PermissionsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to aggregate.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionsWhereInput
    orderBy?: permissionsOrderByWithAggregationInput | permissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    categoryId: string
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    permission_audit_logs?: boolean | permissions$permission_audit_logsArgs<ExtArgs>
    permission_categories?: boolean | permission_categoriesDefaultArgs<ExtArgs>
    role_permissions?: boolean | permissions$role_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    permission_categories?: boolean | permission_categoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    permission_categories?: boolean | permission_categoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
  }

  export type permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "categoryId", ExtArgs["result"]["permissions"]>
  export type permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_audit_logs?: boolean | permissions$permission_audit_logsArgs<ExtArgs>
    permission_categories?: boolean | permission_categoriesDefaultArgs<ExtArgs>
    role_permissions?: boolean | permissions$role_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_categories?: boolean | permission_categoriesDefaultArgs<ExtArgs>
  }
  export type permissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_categories?: boolean | permission_categoriesDefaultArgs<ExtArgs>
  }

  export type $permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissions"
    objects: {
      permission_audit_logs: Prisma.$permission_audit_logsPayload<ExtArgs>[]
      permission_categories: Prisma.$permission_categoriesPayload<ExtArgs>
      role_permissions: Prisma.$role_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      categoryId: string
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type permissionsGetPayload<S extends boolean | null | undefined | permissionsDefaultArgs> = $Result.GetResult<Prisma.$permissionsPayload, S>

  type permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissions'], meta: { name: 'permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {permissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionsFindUniqueArgs>(args: SelectSubset<T, permissionsFindUniqueArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionsFindFirstArgs>(args?: SelectSubset<T, permissionsFindFirstArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionsFindManyArgs>(args?: SelectSubset<T, permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {permissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends permissionsCreateArgs>(args: SelectSubset<T, permissionsCreateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {permissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionsCreateManyArgs>(args?: SelectSubset<T, permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionsCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permissions.
     * @param {permissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends permissionsDeleteArgs>(args: SelectSubset<T, permissionsDeleteArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {permissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionsUpdateArgs>(args: SelectSubset<T, permissionsUpdateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {permissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionsDeleteManyArgs>(args?: SelectSubset<T, permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionsUpdateManyArgs>(args: SelectSubset<T, permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {permissionsUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends permissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, permissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permissions.
     * @param {permissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends permissionsUpsertArgs>(args: SelectSubset<T, permissionsUpsertArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionsCountArgs>(
      args?: Subset<T, permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionsGroupByArgs['orderBy'] }
        : { orderBy?: permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissions model
   */
  readonly fields: permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission_audit_logs<T extends permissions$permission_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$permission_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permission_categories<T extends permission_categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permission_categoriesDefaultArgs<ExtArgs>>): Prisma__permission_categoriesClient<$Result.GetResult<Prisma.$permission_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role_permissions<T extends permissions$role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissions model
   */
  interface permissionsFieldRefs {
    readonly id: FieldRef<"permissions", 'String'>
    readonly name: FieldRef<"permissions", 'String'>
    readonly code: FieldRef<"permissions", 'String'>
    readonly description: FieldRef<"permissions", 'String'>
    readonly categoryId: FieldRef<"permissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * permissions findUnique
   */
  export type permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findUniqueOrThrow
   */
  export type permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findFirst
   */
  export type permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findFirstOrThrow
   */
  export type permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findMany
   */
  export type permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions create
   */
  export type permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a permissions.
     */
    data: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
  }

  /**
   * permissions createMany
   */
  export type permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions createManyAndReturn
   */
  export type permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * permissions update
   */
  export type permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a permissions.
     */
    data: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
    /**
     * Choose, which permissions to update.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions updateMany
   */
  export type permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permissions updateManyAndReturn
   */
  export type permissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * permissions upsert
   */
  export type permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the permissions to update in case it exists.
     */
    where: permissionsWhereUniqueInput
    /**
     * In case the permissions found by the `where` argument doesn't exist, create a new permissions with this data.
     */
    create: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
    /**
     * In case the permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
  }

  /**
   * permissions delete
   */
  export type permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter which permissions to delete.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions deleteMany
   */
  export type permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to delete.
     */
    limit?: number
  }

  /**
   * permissions.permission_audit_logs
   */
  export type permissions$permission_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    where?: permission_audit_logsWhereInput
    orderBy?: permission_audit_logsOrderByWithRelationInput | permission_audit_logsOrderByWithRelationInput[]
    cursor?: permission_audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Permission_audit_logsScalarFieldEnum | Permission_audit_logsScalarFieldEnum[]
  }

  /**
   * permissions.role_permissions
   */
  export type permissions$role_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    cursor?: role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * permissions without action
   */
  export type permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
  }


  /**
   * Model role_permissions
   */

  export type AggregateRole_permissions = {
    _count: Role_permissionsCountAggregateOutputType | null
    _min: Role_permissionsMinAggregateOutputType | null
    _max: Role_permissionsMaxAggregateOutputType | null
  }

  export type Role_permissionsMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
  }

  export type Role_permissionsMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
  }

  export type Role_permissionsCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    _all: number
  }


  export type Role_permissionsMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type Role_permissionsMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type Role_permissionsCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type Role_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permissions to aggregate.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_permissions
    **/
    _count?: true | Role_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_permissionsMaxAggregateInputType
  }

  export type GetRole_permissionsAggregateType<T extends Role_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_permissions[P]>
      : GetScalarType<T[P], AggregateRole_permissions[P]>
  }




  export type role_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithAggregationInput | role_permissionsOrderByWithAggregationInput[]
    by: Role_permissionsScalarFieldEnum[] | Role_permissionsScalarFieldEnum
    having?: role_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_permissionsCountAggregateInputType | true
    _min?: Role_permissionsMinAggregateInputType
    _max?: Role_permissionsMaxAggregateInputType
  }

  export type Role_permissionsGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    _count: Role_permissionsCountAggregateOutputType | null
    _min: Role_permissionsMinAggregateOutputType | null
    _max: Role_permissionsMaxAggregateOutputType | null
  }

  type GetRole_permissionsGroupByPayload<T extends role_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Role_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Role_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type role_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_permissions"]>

  export type role_permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_permissions"]>

  export type role_permissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_permissions"]>

  export type role_permissionsSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
  }

  export type role_permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId", ExtArgs["result"]["role_permissions"]>
  export type role_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type role_permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type role_permissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $role_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role_permissions"
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
    }, ExtArgs["result"]["role_permissions"]>
    composites: {}
  }

  type role_permissionsGetPayload<S extends boolean | null | undefined | role_permissionsDefaultArgs> = $Result.GetResult<Prisma.$role_permissionsPayload, S>

  type role_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<role_permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Role_permissionsCountAggregateInputType | true
    }

  export interface role_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role_permissions'], meta: { name: 'role_permissions' } }
    /**
     * Find zero or one Role_permissions that matches the filter.
     * @param {role_permissionsFindUniqueArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends role_permissionsFindUniqueArgs>(args: SelectSubset<T, role_permissionsFindUniqueArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role_permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {role_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends role_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, role_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindFirstArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends role_permissionsFindFirstArgs>(args?: SelectSubset<T, role_permissionsFindFirstArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindFirstOrThrowArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends role_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, role_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_permissions
     * const role_permissions = await prisma.role_permissions.findMany()
     * 
     * // Get first 10 Role_permissions
     * const role_permissions = await prisma.role_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const role_permissionsWithIdOnly = await prisma.role_permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends role_permissionsFindManyArgs>(args?: SelectSubset<T, role_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role_permissions.
     * @param {role_permissionsCreateArgs} args - Arguments to create a Role_permissions.
     * @example
     * // Create one Role_permissions
     * const Role_permissions = await prisma.role_permissions.create({
     *   data: {
     *     // ... data to create a Role_permissions
     *   }
     * })
     * 
     */
    create<T extends role_permissionsCreateArgs>(args: SelectSubset<T, role_permissionsCreateArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Role_permissions.
     * @param {role_permissionsCreateManyArgs} args - Arguments to create many Role_permissions.
     * @example
     * // Create many Role_permissions
     * const role_permissions = await prisma.role_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends role_permissionsCreateManyArgs>(args?: SelectSubset<T, role_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Role_permissions and returns the data saved in the database.
     * @param {role_permissionsCreateManyAndReturnArgs} args - Arguments to create many Role_permissions.
     * @example
     * // Create many Role_permissions
     * const role_permissions = await prisma.role_permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Role_permissions and only return the `id`
     * const role_permissionsWithIdOnly = await prisma.role_permissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends role_permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, role_permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role_permissions.
     * @param {role_permissionsDeleteArgs} args - Arguments to delete one Role_permissions.
     * @example
     * // Delete one Role_permissions
     * const Role_permissions = await prisma.role_permissions.delete({
     *   where: {
     *     // ... filter to delete one Role_permissions
     *   }
     * })
     * 
     */
    delete<T extends role_permissionsDeleteArgs>(args: SelectSubset<T, role_permissionsDeleteArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role_permissions.
     * @param {role_permissionsUpdateArgs} args - Arguments to update one Role_permissions.
     * @example
     * // Update one Role_permissions
     * const role_permissions = await prisma.role_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends role_permissionsUpdateArgs>(args: SelectSubset<T, role_permissionsUpdateArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Role_permissions.
     * @param {role_permissionsDeleteManyArgs} args - Arguments to filter Role_permissions to delete.
     * @example
     * // Delete a few Role_permissions
     * const { count } = await prisma.role_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends role_permissionsDeleteManyArgs>(args?: SelectSubset<T, role_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_permissions
     * const role_permissions = await prisma.role_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends role_permissionsUpdateManyArgs>(args: SelectSubset<T, role_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_permissions and returns the data updated in the database.
     * @param {role_permissionsUpdateManyAndReturnArgs} args - Arguments to update many Role_permissions.
     * @example
     * // Update many Role_permissions
     * const role_permissions = await prisma.role_permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Role_permissions and only return the `id`
     * const role_permissionsWithIdOnly = await prisma.role_permissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends role_permissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, role_permissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role_permissions.
     * @param {role_permissionsUpsertArgs} args - Arguments to update or create a Role_permissions.
     * @example
     * // Update or create a Role_permissions
     * const role_permissions = await prisma.role_permissions.upsert({
     *   create: {
     *     // ... data to create a Role_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_permissions we want to update
     *   }
     * })
     */
    upsert<T extends role_permissionsUpsertArgs>(args: SelectSubset<T, role_permissionsUpsertArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsCountArgs} args - Arguments to filter Role_permissions to count.
     * @example
     * // Count the number of Role_permissions
     * const count = await prisma.role_permissions.count({
     *   where: {
     *     // ... the filter for the Role_permissions we want to count
     *   }
     * })
    **/
    count<T extends role_permissionsCountArgs>(
      args?: Subset<T, role_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_permissionsAggregateArgs>(args: Subset<T, Role_permissionsAggregateArgs>): Prisma.PrismaPromise<GetRole_permissionsAggregateType<T>>

    /**
     * Group by Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends role_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: role_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: role_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, role_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role_permissions model
   */
  readonly fields: role_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__role_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends permissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionsDefaultArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role_permissions model
   */
  interface role_permissionsFieldRefs {
    readonly id: FieldRef<"role_permissions", 'String'>
    readonly roleId: FieldRef<"role_permissions", 'String'>
    readonly permissionId: FieldRef<"role_permissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role_permissions findUnique
   */
  export type role_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions findUniqueOrThrow
   */
  export type role_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions findFirst
   */
  export type role_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions findFirstOrThrow
   */
  export type role_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions findMany
   */
  export type role_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions create
   */
  export type role_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a role_permissions.
     */
    data: XOR<role_permissionsCreateInput, role_permissionsUncheckedCreateInput>
  }

  /**
   * role_permissions createMany
   */
  export type role_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many role_permissions.
     */
    data: role_permissionsCreateManyInput | role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_permissions createManyAndReturn
   */
  export type role_permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * The data used to create many role_permissions.
     */
    data: role_permissionsCreateManyInput | role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * role_permissions update
   */
  export type role_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a role_permissions.
     */
    data: XOR<role_permissionsUpdateInput, role_permissionsUncheckedUpdateInput>
    /**
     * Choose, which role_permissions to update.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions updateMany
   */
  export type role_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update role_permissions.
     */
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which role_permissions to update
     */
    where?: role_permissionsWhereInput
    /**
     * Limit how many role_permissions to update.
     */
    limit?: number
  }

  /**
   * role_permissions updateManyAndReturn
   */
  export type role_permissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * The data used to update role_permissions.
     */
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which role_permissions to update
     */
    where?: role_permissionsWhereInput
    /**
     * Limit how many role_permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * role_permissions upsert
   */
  export type role_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the role_permissions to update in case it exists.
     */
    where: role_permissionsWhereUniqueInput
    /**
     * In case the role_permissions found by the `where` argument doesn't exist, create a new role_permissions with this data.
     */
    create: XOR<role_permissionsCreateInput, role_permissionsUncheckedCreateInput>
    /**
     * In case the role_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_permissionsUpdateInput, role_permissionsUncheckedUpdateInput>
  }

  /**
   * role_permissions delete
   */
  export type role_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter which role_permissions to delete.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions deleteMany
   */
  export type role_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permissions to delete
     */
    where?: role_permissionsWhereInput
    /**
     * Limit how many role_permissions to delete.
     */
    limit?: number
  }

  /**
   * role_permissions without action
   */
  export type role_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystemRole: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystemRole: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSystemRole: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystemRole?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystemRole?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystemRole?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isSystemRole: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: RolesCountAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystemRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    permission_audit_logs?: boolean | roles$permission_audit_logsArgs<ExtArgs>
    role_permissions?: boolean | roles$role_permissionsArgs<ExtArgs>
    admin?: boolean | roles$adminArgs<ExtArgs>
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystemRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    admin?: boolean | roles$adminArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystemRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    admin?: boolean | roles$adminArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSystemRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isSystemRole" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission_audit_logs?: boolean | roles$permission_audit_logsArgs<ExtArgs>
    role_permissions?: boolean | roles$role_permissionsArgs<ExtArgs>
    admin?: boolean | roles$adminArgs<ExtArgs>
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | roles$adminArgs<ExtArgs>
  }
  export type rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | roles$adminArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      permission_audit_logs: Prisma.$permission_audit_logsPayload<ExtArgs>[]
      role_permissions: Prisma.$role_permissionsPayload<ExtArgs>[]
      admin: Prisma.$adminPayload<ExtArgs> | null
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isSystemRole: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {rolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission_audit_logs<T extends roles$permission_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, roles$permission_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permission_audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role_permissions<T extends roles$role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, roles$role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends roles$adminArgs<ExtArgs> = {}>(args?: Subset<T, roles$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_roles<T extends roles$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'String'>
    readonly name: FieldRef<"roles", 'String'>
    readonly description: FieldRef<"roles", 'String'>
    readonly isSystemRole: FieldRef<"roles", 'Boolean'>
    readonly createdAt: FieldRef<"roles", 'DateTime'>
    readonly updatedAt: FieldRef<"roles", 'DateTime'>
    readonly createdById: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles updateManyAndReturn
   */
  export type rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.permission_audit_logs
   */
  export type roles$permission_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission_audit_logs
     */
    select?: permission_audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission_audit_logs
     */
    omit?: permission_audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permission_audit_logsInclude<ExtArgs> | null
    where?: permission_audit_logsWhereInput
    orderBy?: permission_audit_logsOrderByWithRelationInput | permission_audit_logsOrderByWithRelationInput[]
    cursor?: permission_audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Permission_audit_logsScalarFieldEnum | Permission_audit_logsScalarFieldEnum[]
  }

  /**
   * roles.role_permissions
   */
  export type roles$role_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_permissions
     */
    omit?: role_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    cursor?: role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * roles.admin
   */
  export type roles$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }

  /**
   * roles.user_roles
   */
  export type roles$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model user_roles
   */

  export type AggregateUser_roles = {
    _count: User_rolesCountAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  export type User_rolesMinAggregateOutputType = {
    id: string | null
    assignedAt: Date | null
    adminId: string | null
    roleId: string | null
    assignedById: string | null
  }

  export type User_rolesMaxAggregateOutputType = {
    id: string | null
    assignedAt: Date | null
    adminId: string | null
    roleId: string | null
    assignedById: string | null
  }

  export type User_rolesCountAggregateOutputType = {
    id: number
    assignedAt: number
    adminId: number
    roleId: number
    assignedById: number
    _all: number
  }


  export type User_rolesMinAggregateInputType = {
    id?: true
    assignedAt?: true
    adminId?: true
    roleId?: true
    assignedById?: true
  }

  export type User_rolesMaxAggregateInputType = {
    id?: true
    assignedAt?: true
    adminId?: true
    roleId?: true
    assignedById?: true
  }

  export type User_rolesCountAggregateInputType = {
    id?: true
    assignedAt?: true
    adminId?: true
    roleId?: true
    assignedById?: true
    _all?: true
  }

  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to aggregate.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_rolesMaxAggregateInputType
  }

  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_roles[P]>
      : GetScalarType<T[P], AggregateUser_roles[P]>
  }




  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]
    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum
    having?: user_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_rolesCountAggregateInputType | true
    _min?: User_rolesMinAggregateInputType
    _max?: User_rolesMaxAggregateInputType
  }

  export type User_rolesGroupByOutputType = {
    id: string
    assignedAt: Date
    adminId: string
    roleId: string
    assignedById: string | null
    _count: User_rolesCountAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
        }
      >
    >


  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignedAt?: boolean
    adminId?: boolean
    roleId?: boolean
    assignedById?: boolean
    admin_user_roles_adminIdToadmin?: boolean | adminDefaultArgs<ExtArgs>
    admin_user_roles_assignedByIdToadmin?: boolean | user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignedAt?: boolean
    adminId?: boolean
    roleId?: boolean
    assignedById?: boolean
    admin_user_roles_adminIdToadmin?: boolean | adminDefaultArgs<ExtArgs>
    admin_user_roles_assignedByIdToadmin?: boolean | user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignedAt?: boolean
    adminId?: boolean
    roleId?: boolean
    assignedById?: boolean
    admin_user_roles_adminIdToadmin?: boolean | adminDefaultArgs<ExtArgs>
    admin_user_roles_assignedByIdToadmin?: boolean | user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectScalar = {
    id?: boolean
    assignedAt?: boolean
    adminId?: boolean
    roleId?: boolean
    assignedById?: boolean
  }

  export type user_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assignedAt" | "adminId" | "roleId" | "assignedById", ExtArgs["result"]["user_roles"]>
  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_user_roles_adminIdToadmin?: boolean | adminDefaultArgs<ExtArgs>
    admin_user_roles_assignedByIdToadmin?: boolean | user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type user_rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_user_roles_adminIdToadmin?: boolean | adminDefaultArgs<ExtArgs>
    admin_user_roles_assignedByIdToadmin?: boolean | user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type user_rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_user_roles_adminIdToadmin?: boolean | adminDefaultArgs<ExtArgs>
    admin_user_roles_assignedByIdToadmin?: boolean | user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_roles"
    objects: {
      admin_user_roles_adminIdToadmin: Prisma.$adminPayload<ExtArgs>
      admin_user_roles_assignedByIdToadmin: Prisma.$adminPayload<ExtArgs> | null
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignedAt: Date
      adminId: string
      roleId: string
      assignedById: string | null
    }, ExtArgs["result"]["user_roles"]>
    composites: {}
  }

  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>

  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_rolesCountAggregateInputType | true
    }

  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }
    /**
     * Find zero or one User_roles that matches the filter.
     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_roles.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_roles.
     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.
     * @example
     * // Create one User_roles
     * const User_roles = await prisma.user_roles.create({
     *   data: {
     *     // ... data to create a User_roles
     *   }
     * })
     * 
     */
    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_roles.
     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_roles and returns the data saved in the database.
     * @param {user_rolesCreateManyAndReturnArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_roles and only return the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_roles.
     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.
     * @example
     * // Delete one User_roles
     * const User_roles = await prisma.user_roles.delete({
     *   where: {
     *     // ... filter to delete one User_roles
     *   }
     * })
     * 
     */
    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_roles.
     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.
     * @example
     * // Update one User_roles
     * const user_roles = await prisma.user_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_roles.
     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles and returns the data updated in the database.
     * @param {user_rolesUpdateManyAndReturnArgs} args - Arguments to update many User_roles.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_roles and only return the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_roles.
     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.
     * @example
     * // Update or create a User_roles
     * const user_roles = await prisma.user_roles.upsert({
     *   create: {
     *     // ... data to create a User_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_roles we want to update
     *   }
     * })
     */
    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_roles.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_rolesCountArgs>(
      args?: Subset<T, user_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>

    /**
     * Group by User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_rolesGroupByArgs['orderBy'] }
        : { orderBy?: user_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_roles model
   */
  readonly fields: user_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_user_roles_adminIdToadmin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admin_user_roles_assignedByIdToadmin<T extends user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs> = {}>(args?: Subset<T, user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_roles model
   */
  interface user_rolesFieldRefs {
    readonly id: FieldRef<"user_roles", 'String'>
    readonly assignedAt: FieldRef<"user_roles", 'DateTime'>
    readonly adminId: FieldRef<"user_roles", 'String'>
    readonly roleId: FieldRef<"user_roles", 'String'>
    readonly assignedById: FieldRef<"user_roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_roles findUnique
   */
  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findUniqueOrThrow
   */
  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findFirst
   */
  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findFirstOrThrow
   */
  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findMany
   */
  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles create
   */
  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_roles.
     */
    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
  }

  /**
   * user_roles createMany
   */
  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_roles createManyAndReturn
   */
  export type user_rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_roles update
   */
  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_roles.
     */
    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
    /**
     * Choose, which user_roles to update.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles updateMany
   */
  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_roles updateManyAndReturn
   */
  export type user_rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_roles upsert
   */
  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_roles to update in case it exists.
     */
    where: user_rolesWhereUniqueInput
    /**
     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.
     */
    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
    /**
     * In case the user_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
  }

  /**
   * user_roles delete
   */
  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter which user_roles to delete.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles deleteMany
   */
  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to delete.
     */
    limit?: number
  }

  /**
   * user_roles.admin_user_roles_assignedByIdToadmin
   */
  export type user_roles$admin_user_roles_assignedByIdToadminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }

  /**
   * user_roles without action
   */
  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BookingsScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    PickUpLocation: 'PickUpLocation',
    DropLocation: 'DropLocation',
    Product: 'Product',
    Distance: 'Distance',
    Status: 'Status',
    PaymentMode: 'PaymentMode',
    BookingTime: 'BookingTime',
    DriverId: 'DriverId',
    Fare: 'Fare',
    VehicleId: 'VehicleId',
    StartTime: 'StartTime',
    CreatedDateTime: 'CreatedDateTime',
    UpdatedDateTime: 'UpdatedDateTime'
  };

  export type BookingsScalarFieldEnum = (typeof BookingsScalarFieldEnum)[keyof typeof BookingsScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Gender: 'Gender',
    Password: 'Password',
    MobileNumber: 'MobileNumber',
    DOB: 'DOB',
    DrivingLicenceNumber: 'DrivingLicenceNumber',
    DrivingLicenceFrontImage: 'DrivingLicenceFrontImage',
    DrivingLicenceBackImage: 'DrivingLicenceBackImage',
    DriverImage: 'DriverImage',
    Email: 'Email',
    AdhaarCardNumber: 'AdhaarCardNumber',
    FrontSideAdhaarImage: 'FrontSideAdhaarImage',
    BackSideAdhaarImage: 'BackSideAdhaarImage',
    PanNumber: 'PanNumber',
    PanImage: 'PanImage',
    LastLoggedIn: 'LastLoggedIn',
    CreatedDate: 'CreatedDate',
    IsOnline: 'IsOnline'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const DriverVehicleScalarFieldEnum: {
    Id: 'Id',
    DriverId: 'DriverId',
    VehicleId: 'VehicleId'
  };

  export type DriverVehicleScalarFieldEnum = (typeof DriverVehicleScalarFieldEnum)[keyof typeof DriverVehicleScalarFieldEnum]


  export const DriverWalletScalarFieldEnum: {
    Id: 'Id',
    DriverId: 'DriverId',
    Amount: 'Amount',
    LastUpdated: 'LastUpdated'
  };

  export type DriverWalletScalarFieldEnum = (typeof DriverWalletScalarFieldEnum)[keyof typeof DriverWalletScalarFieldEnum]


  export const FareNegotiationScalarFieldEnum: {
    Id: 'Id',
    BookingId: 'BookingId',
    DriverId: 'DriverId',
    OwnerId: 'OwnerId',
    NegotiatedFare: 'NegotiatedFare',
    NegotiatedTime: 'NegotiatedTime'
  };

  export type FareNegotiationScalarFieldEnum = (typeof FareNegotiationScalarFieldEnum)[keyof typeof FareNegotiationScalarFieldEnum]


  export const OwnerScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    Password: 'Password',
    MobileNumber: 'MobileNumber',
    DOB: 'DOB',
    Email: 'Email',
    Gender: 'Gender',
    AdhaarCardNumber: 'AdhaarCardNumber',
    FrontSideAdhaarImage: 'FrontSideAdhaarImage',
    BackSideAdhaarImage: 'BackSideAdhaarImage',
    PanNumber: 'PanNumber',
    PanImage: 'PanImage',
    LastLoggedIn: 'LastLoggedIn',
    CreatedDate: 'CreatedDate'
  };

  export type OwnerScalarFieldEnum = (typeof OwnerScalarFieldEnum)[keyof typeof OwnerScalarFieldEnum]


  export const OwnerDriverScalarFieldEnum: {
    Id: 'Id',
    OwnerId: 'OwnerId',
    DriverId: 'DriverId'
  };

  export type OwnerDriverScalarFieldEnum = (typeof OwnerDriverScalarFieldEnum)[keyof typeof OwnerDriverScalarFieldEnum]


  export const OwnerVehicleScalarFieldEnum: {
    Id: 'Id',
    OwnerId: 'OwnerId',
    VehicleId: 'VehicleId'
  };

  export type OwnerVehicleScalarFieldEnum = (typeof OwnerVehicleScalarFieldEnum)[keyof typeof OwnerVehicleScalarFieldEnum]


  export const OwnerWalletScalarFieldEnum: {
    Id: 'Id',
    OwnerId: 'OwnerId',
    Amount: 'Amount',
    LastUpdated: 'LastUpdated'
  };

  export type OwnerWalletScalarFieldEnum = (typeof OwnerWalletScalarFieldEnum)[keyof typeof OwnerWalletScalarFieldEnum]


  export const UserScalarFieldEnum: {
    Id: 'Id',
    MobileNumber: 'MobileNumber',
    CreatedDate: 'CreatedDate',
    LastLoggedIn: 'LastLoggedIn',
    Gender: 'Gender',
    Name: 'Name'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserWalletScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    Amount: 'Amount'
  };

  export type UserWalletScalarFieldEnum = (typeof UserWalletScalarFieldEnum)[keyof typeof UserWalletScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    Id: 'Id',
    Model: 'Model',
    Year: 'Year',
    Category: 'Category',
    VehicleImage: 'VehicleImage',
    VehicleInsuranceImage: 'VehicleInsuranceImage',
    PermitImage: 'PermitImage',
    VehicleNumber: 'VehicleNumber'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const OtpsScalarFieldEnum: {
    CreatedAt: 'CreatedAt',
    ExpiresAt: 'ExpiresAt',
    Id: 'Id',
    MobileNumber: 'MobileNumber',
    Otp: 'Otp'
  };

  export type OtpsScalarFieldEnum = (typeof OtpsScalarFieldEnum)[keyof typeof OtpsScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const Permission_audit_logsScalarFieldEnum: {
    id: 'id',
    actionType: 'actionType',
    details: 'details',
    actionTimestamp: 'actionTimestamp',
    adminId: 'adminId',
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type Permission_audit_logsScalarFieldEnum = (typeof Permission_audit_logsScalarFieldEnum)[keyof typeof Permission_audit_logsScalarFieldEnum]


  export const Permission_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    displayOrder: 'displayOrder'
  };

  export type Permission_categoriesScalarFieldEnum = (typeof Permission_categoriesScalarFieldEnum)[keyof typeof Permission_categoriesScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    categoryId: 'categoryId'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const Role_permissionsScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type Role_permissionsScalarFieldEnum = (typeof Role_permissionsScalarFieldEnum)[keyof typeof Role_permissionsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSystemRole: 'isSystemRole',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const User_rolesScalarFieldEnum: {
    id: 'id',
    assignedAt: 'assignedAt',
    adminId: 'adminId',
    roleId: 'roleId',
    assignedById: 'assignedById'
  };

  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMode'
   */
  export type EnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode'>
    


  /**
   * Reference to a field of type 'PaymentMode[]'
   */
  export type ListEnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AuditActionType'
   */
  export type EnumAuditActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditActionType'>
    


  /**
   * Reference to a field of type 'AuditActionType[]'
   */
  export type ListEnumAuditActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditActionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BookingsWhereInput = {
    AND?: BookingsWhereInput | BookingsWhereInput[]
    OR?: BookingsWhereInput[]
    NOT?: BookingsWhereInput | BookingsWhereInput[]
    Id?: IntFilter<"Bookings"> | number
    UserId?: IntFilter<"Bookings"> | number
    PickUpLocation?: StringFilter<"Bookings"> | string
    DropLocation?: StringFilter<"Bookings"> | string
    Product?: StringFilter<"Bookings"> | string
    Distance?: StringFilter<"Bookings"> | string
    Status?: EnumBookingStatusFilter<"Bookings"> | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFilter<"Bookings"> | $Enums.PaymentMode
    BookingTime?: DateTimeFilter<"Bookings"> | Date | string
    DriverId?: IntNullableFilter<"Bookings"> | number | null
    Fare?: StringFilter<"Bookings"> | string
    VehicleId?: IntNullableFilter<"Bookings"> | number | null
    StartTime?: DateTimeFilter<"Bookings"> | Date | string
    CreatedDateTime?: DateTimeFilter<"Bookings"> | Date | string
    UpdatedDateTime?: DateTimeFilter<"Bookings"> | Date | string
    Driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    FareNegotiation?: FareNegotiationListRelationFilter
  }

  export type BookingsOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    PickUpLocation?: SortOrder
    DropLocation?: SortOrder
    Product?: SortOrder
    Distance?: SortOrder
    Status?: SortOrder
    PaymentMode?: SortOrder
    BookingTime?: SortOrder
    DriverId?: SortOrderInput | SortOrder
    Fare?: SortOrder
    VehicleId?: SortOrderInput | SortOrder
    StartTime?: SortOrder
    CreatedDateTime?: SortOrder
    UpdatedDateTime?: SortOrder
    Driver?: DriverOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    Vehicle?: VehicleOrderByWithRelationInput
    FareNegotiation?: FareNegotiationOrderByRelationAggregateInput
  }

  export type BookingsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: BookingsWhereInput | BookingsWhereInput[]
    OR?: BookingsWhereInput[]
    NOT?: BookingsWhereInput | BookingsWhereInput[]
    UserId?: IntFilter<"Bookings"> | number
    PickUpLocation?: StringFilter<"Bookings"> | string
    DropLocation?: StringFilter<"Bookings"> | string
    Product?: StringFilter<"Bookings"> | string
    Distance?: StringFilter<"Bookings"> | string
    Status?: EnumBookingStatusFilter<"Bookings"> | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFilter<"Bookings"> | $Enums.PaymentMode
    BookingTime?: DateTimeFilter<"Bookings"> | Date | string
    DriverId?: IntNullableFilter<"Bookings"> | number | null
    Fare?: StringFilter<"Bookings"> | string
    VehicleId?: IntNullableFilter<"Bookings"> | number | null
    StartTime?: DateTimeFilter<"Bookings"> | Date | string
    CreatedDateTime?: DateTimeFilter<"Bookings"> | Date | string
    UpdatedDateTime?: DateTimeFilter<"Bookings"> | Date | string
    Driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    FareNegotiation?: FareNegotiationListRelationFilter
  }, "Id">

  export type BookingsOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    PickUpLocation?: SortOrder
    DropLocation?: SortOrder
    Product?: SortOrder
    Distance?: SortOrder
    Status?: SortOrder
    PaymentMode?: SortOrder
    BookingTime?: SortOrder
    DriverId?: SortOrderInput | SortOrder
    Fare?: SortOrder
    VehicleId?: SortOrderInput | SortOrder
    StartTime?: SortOrder
    CreatedDateTime?: SortOrder
    UpdatedDateTime?: SortOrder
    _count?: BookingsCountOrderByAggregateInput
    _avg?: BookingsAvgOrderByAggregateInput
    _max?: BookingsMaxOrderByAggregateInput
    _min?: BookingsMinOrderByAggregateInput
    _sum?: BookingsSumOrderByAggregateInput
  }

  export type BookingsScalarWhereWithAggregatesInput = {
    AND?: BookingsScalarWhereWithAggregatesInput | BookingsScalarWhereWithAggregatesInput[]
    OR?: BookingsScalarWhereWithAggregatesInput[]
    NOT?: BookingsScalarWhereWithAggregatesInput | BookingsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Bookings"> | number
    UserId?: IntWithAggregatesFilter<"Bookings"> | number
    PickUpLocation?: StringWithAggregatesFilter<"Bookings"> | string
    DropLocation?: StringWithAggregatesFilter<"Bookings"> | string
    Product?: StringWithAggregatesFilter<"Bookings"> | string
    Distance?: StringWithAggregatesFilter<"Bookings"> | string
    Status?: EnumBookingStatusWithAggregatesFilter<"Bookings"> | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeWithAggregatesFilter<"Bookings"> | $Enums.PaymentMode
    BookingTime?: DateTimeWithAggregatesFilter<"Bookings"> | Date | string
    DriverId?: IntNullableWithAggregatesFilter<"Bookings"> | number | null
    Fare?: StringWithAggregatesFilter<"Bookings"> | string
    VehicleId?: IntNullableWithAggregatesFilter<"Bookings"> | number | null
    StartTime?: DateTimeWithAggregatesFilter<"Bookings"> | Date | string
    CreatedDateTime?: DateTimeWithAggregatesFilter<"Bookings"> | Date | string
    UpdatedDateTime?: DateTimeWithAggregatesFilter<"Bookings"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    Id?: IntFilter<"Driver"> | number
    Name?: StringNullableFilter<"Driver"> | string | null
    Gender?: EnumGenderFilter<"Driver"> | $Enums.Gender
    Password?: StringNullableFilter<"Driver"> | string | null
    MobileNumber?: StringFilter<"Driver"> | string
    DOB?: DateTimeNullableFilter<"Driver"> | Date | string | null
    DrivingLicenceNumber?: StringFilter<"Driver"> | string
    DrivingLicenceFrontImage?: StringFilter<"Driver"> | string
    DrivingLicenceBackImage?: StringFilter<"Driver"> | string
    DriverImage?: StringFilter<"Driver"> | string
    Email?: StringNullableFilter<"Driver"> | string | null
    AdhaarCardNumber?: StringFilter<"Driver"> | string
    FrontSideAdhaarImage?: StringFilter<"Driver"> | string
    BackSideAdhaarImage?: StringFilter<"Driver"> | string
    PanNumber?: StringFilter<"Driver"> | string
    PanImage?: StringFilter<"Driver"> | string
    LastLoggedIn?: DateTimeFilter<"Driver"> | Date | string
    CreatedDate?: DateTimeFilter<"Driver"> | Date | string
    IsOnline?: BoolFilter<"Driver"> | boolean
    Bookings?: BookingsListRelationFilter
    DriverVehicle?: DriverVehicleListRelationFilter
    DriverWallet?: XOR<DriverWalletNullableScalarRelationFilter, DriverWalletWhereInput> | null
    FareNegotiation?: FareNegotiationListRelationFilter
    OwnerDriver?: OwnerDriverListRelationFilter
  }

  export type DriverOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    Gender?: SortOrder
    Password?: SortOrderInput | SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrderInput | SortOrder
    DrivingLicenceNumber?: SortOrder
    DrivingLicenceFrontImage?: SortOrder
    DrivingLicenceBackImage?: SortOrder
    DriverImage?: SortOrder
    Email?: SortOrderInput | SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
    IsOnline?: SortOrder
    Bookings?: BookingsOrderByRelationAggregateInput
    DriverVehicle?: DriverVehicleOrderByRelationAggregateInput
    DriverWallet?: DriverWalletOrderByWithRelationInput
    FareNegotiation?: FareNegotiationOrderByRelationAggregateInput
    OwnerDriver?: OwnerDriverOrderByRelationAggregateInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    MobileNumber?: string
    Email?: string
    AdhaarCardNumber?: string
    PanNumber?: string
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    Name?: StringNullableFilter<"Driver"> | string | null
    Gender?: EnumGenderFilter<"Driver"> | $Enums.Gender
    Password?: StringNullableFilter<"Driver"> | string | null
    DOB?: DateTimeNullableFilter<"Driver"> | Date | string | null
    DrivingLicenceNumber?: StringFilter<"Driver"> | string
    DrivingLicenceFrontImage?: StringFilter<"Driver"> | string
    DrivingLicenceBackImage?: StringFilter<"Driver"> | string
    DriverImage?: StringFilter<"Driver"> | string
    FrontSideAdhaarImage?: StringFilter<"Driver"> | string
    BackSideAdhaarImage?: StringFilter<"Driver"> | string
    PanImage?: StringFilter<"Driver"> | string
    LastLoggedIn?: DateTimeFilter<"Driver"> | Date | string
    CreatedDate?: DateTimeFilter<"Driver"> | Date | string
    IsOnline?: BoolFilter<"Driver"> | boolean
    Bookings?: BookingsListRelationFilter
    DriverVehicle?: DriverVehicleListRelationFilter
    DriverWallet?: XOR<DriverWalletNullableScalarRelationFilter, DriverWalletWhereInput> | null
    FareNegotiation?: FareNegotiationListRelationFilter
    OwnerDriver?: OwnerDriverListRelationFilter
  }, "Id" | "MobileNumber" | "Email" | "AdhaarCardNumber" | "PanNumber">

  export type DriverOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    Gender?: SortOrder
    Password?: SortOrderInput | SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrderInput | SortOrder
    DrivingLicenceNumber?: SortOrder
    DrivingLicenceFrontImage?: SortOrder
    DrivingLicenceBackImage?: SortOrder
    DriverImage?: SortOrder
    Email?: SortOrderInput | SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
    IsOnline?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Driver"> | number
    Name?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    Gender?: EnumGenderWithAggregatesFilter<"Driver"> | $Enums.Gender
    Password?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    MobileNumber?: StringWithAggregatesFilter<"Driver"> | string
    DOB?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    DrivingLicenceNumber?: StringWithAggregatesFilter<"Driver"> | string
    DrivingLicenceFrontImage?: StringWithAggregatesFilter<"Driver"> | string
    DrivingLicenceBackImage?: StringWithAggregatesFilter<"Driver"> | string
    DriverImage?: StringWithAggregatesFilter<"Driver"> | string
    Email?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    AdhaarCardNumber?: StringWithAggregatesFilter<"Driver"> | string
    FrontSideAdhaarImage?: StringWithAggregatesFilter<"Driver"> | string
    BackSideAdhaarImage?: StringWithAggregatesFilter<"Driver"> | string
    PanNumber?: StringWithAggregatesFilter<"Driver"> | string
    PanImage?: StringWithAggregatesFilter<"Driver"> | string
    LastLoggedIn?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    CreatedDate?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    IsOnline?: BoolWithAggregatesFilter<"Driver"> | boolean
  }

  export type DriverVehicleWhereInput = {
    AND?: DriverVehicleWhereInput | DriverVehicleWhereInput[]
    OR?: DriverVehicleWhereInput[]
    NOT?: DriverVehicleWhereInput | DriverVehicleWhereInput[]
    Id?: IntFilter<"DriverVehicle"> | number
    DriverId?: IntFilter<"DriverVehicle"> | number
    VehicleId?: IntFilter<"DriverVehicle"> | number
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    Vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type DriverVehicleOrderByWithRelationInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
    Driver?: DriverOrderByWithRelationInput
    Vehicle?: VehicleOrderByWithRelationInput
  }

  export type DriverVehicleWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: DriverVehicleWhereInput | DriverVehicleWhereInput[]
    OR?: DriverVehicleWhereInput[]
    NOT?: DriverVehicleWhereInput | DriverVehicleWhereInput[]
    DriverId?: IntFilter<"DriverVehicle"> | number
    VehicleId?: IntFilter<"DriverVehicle"> | number
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    Vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "Id">

  export type DriverVehicleOrderByWithAggregationInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
    _count?: DriverVehicleCountOrderByAggregateInput
    _avg?: DriverVehicleAvgOrderByAggregateInput
    _max?: DriverVehicleMaxOrderByAggregateInput
    _min?: DriverVehicleMinOrderByAggregateInput
    _sum?: DriverVehicleSumOrderByAggregateInput
  }

  export type DriverVehicleScalarWhereWithAggregatesInput = {
    AND?: DriverVehicleScalarWhereWithAggregatesInput | DriverVehicleScalarWhereWithAggregatesInput[]
    OR?: DriverVehicleScalarWhereWithAggregatesInput[]
    NOT?: DriverVehicleScalarWhereWithAggregatesInput | DriverVehicleScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"DriverVehicle"> | number
    DriverId?: IntWithAggregatesFilter<"DriverVehicle"> | number
    VehicleId?: IntWithAggregatesFilter<"DriverVehicle"> | number
  }

  export type DriverWalletWhereInput = {
    AND?: DriverWalletWhereInput | DriverWalletWhereInput[]
    OR?: DriverWalletWhereInput[]
    NOT?: DriverWalletWhereInput | DriverWalletWhereInput[]
    Id?: IntFilter<"DriverWallet"> | number
    DriverId?: IntFilter<"DriverWallet"> | number
    Amount?: IntFilter<"DriverWallet"> | number
    LastUpdated?: DateTimeFilter<"DriverWallet"> | Date | string
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
  }

  export type DriverWalletOrderByWithRelationInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
    Driver?: DriverOrderByWithRelationInput
  }

  export type DriverWalletWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    DriverId?: number
    AND?: DriverWalletWhereInput | DriverWalletWhereInput[]
    OR?: DriverWalletWhereInput[]
    NOT?: DriverWalletWhereInput | DriverWalletWhereInput[]
    Amount?: IntFilter<"DriverWallet"> | number
    LastUpdated?: DateTimeFilter<"DriverWallet"> | Date | string
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
  }, "Id" | "DriverId">

  export type DriverWalletOrderByWithAggregationInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
    _count?: DriverWalletCountOrderByAggregateInput
    _avg?: DriverWalletAvgOrderByAggregateInput
    _max?: DriverWalletMaxOrderByAggregateInput
    _min?: DriverWalletMinOrderByAggregateInput
    _sum?: DriverWalletSumOrderByAggregateInput
  }

  export type DriverWalletScalarWhereWithAggregatesInput = {
    AND?: DriverWalletScalarWhereWithAggregatesInput | DriverWalletScalarWhereWithAggregatesInput[]
    OR?: DriverWalletScalarWhereWithAggregatesInput[]
    NOT?: DriverWalletScalarWhereWithAggregatesInput | DriverWalletScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"DriverWallet"> | number
    DriverId?: IntWithAggregatesFilter<"DriverWallet"> | number
    Amount?: IntWithAggregatesFilter<"DriverWallet"> | number
    LastUpdated?: DateTimeWithAggregatesFilter<"DriverWallet"> | Date | string
  }

  export type FareNegotiationWhereInput = {
    AND?: FareNegotiationWhereInput | FareNegotiationWhereInput[]
    OR?: FareNegotiationWhereInput[]
    NOT?: FareNegotiationWhereInput | FareNegotiationWhereInput[]
    Id?: IntFilter<"FareNegotiation"> | number
    BookingId?: IntFilter<"FareNegotiation"> | number
    DriverId?: IntFilter<"FareNegotiation"> | number
    OwnerId?: IntFilter<"FareNegotiation"> | number
    NegotiatedFare?: StringFilter<"FareNegotiation"> | string
    NegotiatedTime?: DateTimeFilter<"FareNegotiation"> | Date | string
    Bookings?: XOR<BookingsScalarRelationFilter, BookingsWhereInput>
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type FareNegotiationOrderByWithRelationInput = {
    Id?: SortOrder
    BookingId?: SortOrder
    DriverId?: SortOrder
    OwnerId?: SortOrder
    NegotiatedFare?: SortOrder
    NegotiatedTime?: SortOrder
    Bookings?: BookingsOrderByWithRelationInput
    Driver?: DriverOrderByWithRelationInput
    Owner?: OwnerOrderByWithRelationInput
  }

  export type FareNegotiationWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    BookingId_DriverId?: FareNegotiationBookingIdDriverIdCompoundUniqueInput
    AND?: FareNegotiationWhereInput | FareNegotiationWhereInput[]
    OR?: FareNegotiationWhereInput[]
    NOT?: FareNegotiationWhereInput | FareNegotiationWhereInput[]
    BookingId?: IntFilter<"FareNegotiation"> | number
    DriverId?: IntFilter<"FareNegotiation"> | number
    OwnerId?: IntFilter<"FareNegotiation"> | number
    NegotiatedFare?: StringFilter<"FareNegotiation"> | string
    NegotiatedTime?: DateTimeFilter<"FareNegotiation"> | Date | string
    Bookings?: XOR<BookingsScalarRelationFilter, BookingsWhereInput>
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "Id" | "BookingId_DriverId">

  export type FareNegotiationOrderByWithAggregationInput = {
    Id?: SortOrder
    BookingId?: SortOrder
    DriverId?: SortOrder
    OwnerId?: SortOrder
    NegotiatedFare?: SortOrder
    NegotiatedTime?: SortOrder
    _count?: FareNegotiationCountOrderByAggregateInput
    _avg?: FareNegotiationAvgOrderByAggregateInput
    _max?: FareNegotiationMaxOrderByAggregateInput
    _min?: FareNegotiationMinOrderByAggregateInput
    _sum?: FareNegotiationSumOrderByAggregateInput
  }

  export type FareNegotiationScalarWhereWithAggregatesInput = {
    AND?: FareNegotiationScalarWhereWithAggregatesInput | FareNegotiationScalarWhereWithAggregatesInput[]
    OR?: FareNegotiationScalarWhereWithAggregatesInput[]
    NOT?: FareNegotiationScalarWhereWithAggregatesInput | FareNegotiationScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"FareNegotiation"> | number
    BookingId?: IntWithAggregatesFilter<"FareNegotiation"> | number
    DriverId?: IntWithAggregatesFilter<"FareNegotiation"> | number
    OwnerId?: IntWithAggregatesFilter<"FareNegotiation"> | number
    NegotiatedFare?: StringWithAggregatesFilter<"FareNegotiation"> | string
    NegotiatedTime?: DateTimeWithAggregatesFilter<"FareNegotiation"> | Date | string
  }

  export type OwnerWhereInput = {
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    Id?: IntFilter<"Owner"> | number
    Name?: StringFilter<"Owner"> | string
    Password?: StringFilter<"Owner"> | string
    MobileNumber?: StringFilter<"Owner"> | string
    DOB?: DateTimeNullableFilter<"Owner"> | Date | string | null
    Email?: StringNullableFilter<"Owner"> | string | null
    Gender?: EnumGenderFilter<"Owner"> | $Enums.Gender
    AdhaarCardNumber?: StringNullableFilter<"Owner"> | string | null
    FrontSideAdhaarImage?: StringNullableFilter<"Owner"> | string | null
    BackSideAdhaarImage?: StringNullableFilter<"Owner"> | string | null
    PanNumber?: StringNullableFilter<"Owner"> | string | null
    PanImage?: StringNullableFilter<"Owner"> | string | null
    LastLoggedIn?: DateTimeFilter<"Owner"> | Date | string
    CreatedDate?: DateTimeFilter<"Owner"> | Date | string
    FareNegotiation?: FareNegotiationListRelationFilter
    OwnerDriver?: OwnerDriverListRelationFilter
    OwnerVehicle?: OwnerVehicleListRelationFilter
    OwnerWallet?: XOR<OwnerWalletNullableScalarRelationFilter, OwnerWalletWhereInput> | null
  }

  export type OwnerOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Gender?: SortOrder
    AdhaarCardNumber?: SortOrderInput | SortOrder
    FrontSideAdhaarImage?: SortOrderInput | SortOrder
    BackSideAdhaarImage?: SortOrderInput | SortOrder
    PanNumber?: SortOrderInput | SortOrder
    PanImage?: SortOrderInput | SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
    FareNegotiation?: FareNegotiationOrderByRelationAggregateInput
    OwnerDriver?: OwnerDriverOrderByRelationAggregateInput
    OwnerVehicle?: OwnerVehicleOrderByRelationAggregateInput
    OwnerWallet?: OwnerWalletOrderByWithRelationInput
  }

  export type OwnerWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    MobileNumber?: string
    Email?: string
    AdhaarCardNumber?: string
    PanNumber?: string
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    Name?: StringFilter<"Owner"> | string
    Password?: StringFilter<"Owner"> | string
    DOB?: DateTimeNullableFilter<"Owner"> | Date | string | null
    Gender?: EnumGenderFilter<"Owner"> | $Enums.Gender
    FrontSideAdhaarImage?: StringNullableFilter<"Owner"> | string | null
    BackSideAdhaarImage?: StringNullableFilter<"Owner"> | string | null
    PanImage?: StringNullableFilter<"Owner"> | string | null
    LastLoggedIn?: DateTimeFilter<"Owner"> | Date | string
    CreatedDate?: DateTimeFilter<"Owner"> | Date | string
    FareNegotiation?: FareNegotiationListRelationFilter
    OwnerDriver?: OwnerDriverListRelationFilter
    OwnerVehicle?: OwnerVehicleListRelationFilter
    OwnerWallet?: XOR<OwnerWalletNullableScalarRelationFilter, OwnerWalletWhereInput> | null
  }, "Id" | "MobileNumber" | "Email" | "AdhaarCardNumber" | "PanNumber">

  export type OwnerOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Gender?: SortOrder
    AdhaarCardNumber?: SortOrderInput | SortOrder
    FrontSideAdhaarImage?: SortOrderInput | SortOrder
    BackSideAdhaarImage?: SortOrderInput | SortOrder
    PanNumber?: SortOrderInput | SortOrder
    PanImage?: SortOrderInput | SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
    _count?: OwnerCountOrderByAggregateInput
    _avg?: OwnerAvgOrderByAggregateInput
    _max?: OwnerMaxOrderByAggregateInput
    _min?: OwnerMinOrderByAggregateInput
    _sum?: OwnerSumOrderByAggregateInput
  }

  export type OwnerScalarWhereWithAggregatesInput = {
    AND?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    OR?: OwnerScalarWhereWithAggregatesInput[]
    NOT?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Owner"> | number
    Name?: StringWithAggregatesFilter<"Owner"> | string
    Password?: StringWithAggregatesFilter<"Owner"> | string
    MobileNumber?: StringWithAggregatesFilter<"Owner"> | string
    DOB?: DateTimeNullableWithAggregatesFilter<"Owner"> | Date | string | null
    Email?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    Gender?: EnumGenderWithAggregatesFilter<"Owner"> | $Enums.Gender
    AdhaarCardNumber?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    FrontSideAdhaarImage?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    BackSideAdhaarImage?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    PanNumber?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    PanImage?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    LastLoggedIn?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
    CreatedDate?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
  }

  export type OwnerDriverWhereInput = {
    AND?: OwnerDriverWhereInput | OwnerDriverWhereInput[]
    OR?: OwnerDriverWhereInput[]
    NOT?: OwnerDriverWhereInput | OwnerDriverWhereInput[]
    Id?: IntFilter<"OwnerDriver"> | number
    OwnerId?: IntFilter<"OwnerDriver"> | number
    DriverId?: IntFilter<"OwnerDriver"> | number
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type OwnerDriverOrderByWithRelationInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    DriverId?: SortOrder
    Driver?: DriverOrderByWithRelationInput
    Owner?: OwnerOrderByWithRelationInput
  }

  export type OwnerDriverWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: OwnerDriverWhereInput | OwnerDriverWhereInput[]
    OR?: OwnerDriverWhereInput[]
    NOT?: OwnerDriverWhereInput | OwnerDriverWhereInput[]
    OwnerId?: IntFilter<"OwnerDriver"> | number
    DriverId?: IntFilter<"OwnerDriver"> | number
    Driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "Id">

  export type OwnerDriverOrderByWithAggregationInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    DriverId?: SortOrder
    _count?: OwnerDriverCountOrderByAggregateInput
    _avg?: OwnerDriverAvgOrderByAggregateInput
    _max?: OwnerDriverMaxOrderByAggregateInput
    _min?: OwnerDriverMinOrderByAggregateInput
    _sum?: OwnerDriverSumOrderByAggregateInput
  }

  export type OwnerDriverScalarWhereWithAggregatesInput = {
    AND?: OwnerDriverScalarWhereWithAggregatesInput | OwnerDriverScalarWhereWithAggregatesInput[]
    OR?: OwnerDriverScalarWhereWithAggregatesInput[]
    NOT?: OwnerDriverScalarWhereWithAggregatesInput | OwnerDriverScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"OwnerDriver"> | number
    OwnerId?: IntWithAggregatesFilter<"OwnerDriver"> | number
    DriverId?: IntWithAggregatesFilter<"OwnerDriver"> | number
  }

  export type OwnerVehicleWhereInput = {
    AND?: OwnerVehicleWhereInput | OwnerVehicleWhereInput[]
    OR?: OwnerVehicleWhereInput[]
    NOT?: OwnerVehicleWhereInput | OwnerVehicleWhereInput[]
    Id?: IntFilter<"OwnerVehicle"> | number
    OwnerId?: IntFilter<"OwnerVehicle"> | number
    VehicleId?: IntFilter<"OwnerVehicle"> | number
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
    Vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type OwnerVehicleOrderByWithRelationInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    VehicleId?: SortOrder
    Owner?: OwnerOrderByWithRelationInput
    Vehicle?: VehicleOrderByWithRelationInput
  }

  export type OwnerVehicleWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: OwnerVehicleWhereInput | OwnerVehicleWhereInput[]
    OR?: OwnerVehicleWhereInput[]
    NOT?: OwnerVehicleWhereInput | OwnerVehicleWhereInput[]
    OwnerId?: IntFilter<"OwnerVehicle"> | number
    VehicleId?: IntFilter<"OwnerVehicle"> | number
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
    Vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "Id">

  export type OwnerVehicleOrderByWithAggregationInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    VehicleId?: SortOrder
    _count?: OwnerVehicleCountOrderByAggregateInput
    _avg?: OwnerVehicleAvgOrderByAggregateInput
    _max?: OwnerVehicleMaxOrderByAggregateInput
    _min?: OwnerVehicleMinOrderByAggregateInput
    _sum?: OwnerVehicleSumOrderByAggregateInput
  }

  export type OwnerVehicleScalarWhereWithAggregatesInput = {
    AND?: OwnerVehicleScalarWhereWithAggregatesInput | OwnerVehicleScalarWhereWithAggregatesInput[]
    OR?: OwnerVehicleScalarWhereWithAggregatesInput[]
    NOT?: OwnerVehicleScalarWhereWithAggregatesInput | OwnerVehicleScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"OwnerVehicle"> | number
    OwnerId?: IntWithAggregatesFilter<"OwnerVehicle"> | number
    VehicleId?: IntWithAggregatesFilter<"OwnerVehicle"> | number
  }

  export type OwnerWalletWhereInput = {
    AND?: OwnerWalletWhereInput | OwnerWalletWhereInput[]
    OR?: OwnerWalletWhereInput[]
    NOT?: OwnerWalletWhereInput | OwnerWalletWhereInput[]
    Id?: IntFilter<"OwnerWallet"> | number
    OwnerId?: IntFilter<"OwnerWallet"> | number
    Amount?: IntFilter<"OwnerWallet"> | number
    LastUpdated?: DateTimeFilter<"OwnerWallet"> | Date | string
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }

  export type OwnerWalletOrderByWithRelationInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
    Owner?: OwnerOrderByWithRelationInput
  }

  export type OwnerWalletWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    OwnerId?: number
    AND?: OwnerWalletWhereInput | OwnerWalletWhereInput[]
    OR?: OwnerWalletWhereInput[]
    NOT?: OwnerWalletWhereInput | OwnerWalletWhereInput[]
    Amount?: IntFilter<"OwnerWallet"> | number
    LastUpdated?: DateTimeFilter<"OwnerWallet"> | Date | string
    Owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
  }, "Id" | "OwnerId">

  export type OwnerWalletOrderByWithAggregationInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
    _count?: OwnerWalletCountOrderByAggregateInput
    _avg?: OwnerWalletAvgOrderByAggregateInput
    _max?: OwnerWalletMaxOrderByAggregateInput
    _min?: OwnerWalletMinOrderByAggregateInput
    _sum?: OwnerWalletSumOrderByAggregateInput
  }

  export type OwnerWalletScalarWhereWithAggregatesInput = {
    AND?: OwnerWalletScalarWhereWithAggregatesInput | OwnerWalletScalarWhereWithAggregatesInput[]
    OR?: OwnerWalletScalarWhereWithAggregatesInput[]
    NOT?: OwnerWalletScalarWhereWithAggregatesInput | OwnerWalletScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"OwnerWallet"> | number
    OwnerId?: IntWithAggregatesFilter<"OwnerWallet"> | number
    Amount?: IntWithAggregatesFilter<"OwnerWallet"> | number
    LastUpdated?: DateTimeWithAggregatesFilter<"OwnerWallet"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    Id?: IntFilter<"User"> | number
    MobileNumber?: StringFilter<"User"> | string
    CreatedDate?: DateTimeFilter<"User"> | Date | string
    LastLoggedIn?: DateTimeFilter<"User"> | Date | string
    Gender?: EnumGenderFilter<"User"> | $Enums.Gender
    Name?: StringFilter<"User"> | string
    Bookings?: BookingsListRelationFilter
    UserWallet?: XOR<UserWalletNullableScalarRelationFilter, UserWalletWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    Id?: SortOrder
    MobileNumber?: SortOrder
    CreatedDate?: SortOrder
    LastLoggedIn?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
    Bookings?: BookingsOrderByRelationAggregateInput
    UserWallet?: UserWalletOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    MobileNumber?: StringFilter<"User"> | string
    CreatedDate?: DateTimeFilter<"User"> | Date | string
    LastLoggedIn?: DateTimeFilter<"User"> | Date | string
    Gender?: EnumGenderFilter<"User"> | $Enums.Gender
    Name?: StringFilter<"User"> | string
    Bookings?: BookingsListRelationFilter
    UserWallet?: XOR<UserWalletNullableScalarRelationFilter, UserWalletWhereInput> | null
  }, "Id">

  export type UserOrderByWithAggregationInput = {
    Id?: SortOrder
    MobileNumber?: SortOrder
    CreatedDate?: SortOrder
    LastLoggedIn?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"User"> | number
    MobileNumber?: StringWithAggregatesFilter<"User"> | string
    CreatedDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    LastLoggedIn?: DateTimeWithAggregatesFilter<"User"> | Date | string
    Gender?: EnumGenderWithAggregatesFilter<"User"> | $Enums.Gender
    Name?: StringWithAggregatesFilter<"User"> | string
  }

  export type UserWalletWhereInput = {
    AND?: UserWalletWhereInput | UserWalletWhereInput[]
    OR?: UserWalletWhereInput[]
    NOT?: UserWalletWhereInput | UserWalletWhereInput[]
    Id?: IntFilter<"UserWallet"> | number
    UserId?: IntFilter<"UserWallet"> | number
    Amount?: IntFilter<"UserWallet"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserWalletOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type UserWalletWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    UserId?: number
    AND?: UserWalletWhereInput | UserWalletWhereInput[]
    OR?: UserWalletWhereInput[]
    NOT?: UserWalletWhereInput | UserWalletWhereInput[]
    Amount?: IntFilter<"UserWallet"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "Id" | "UserId">

  export type UserWalletOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
    _count?: UserWalletCountOrderByAggregateInput
    _avg?: UserWalletAvgOrderByAggregateInput
    _max?: UserWalletMaxOrderByAggregateInput
    _min?: UserWalletMinOrderByAggregateInput
    _sum?: UserWalletSumOrderByAggregateInput
  }

  export type UserWalletScalarWhereWithAggregatesInput = {
    AND?: UserWalletScalarWhereWithAggregatesInput | UserWalletScalarWhereWithAggregatesInput[]
    OR?: UserWalletScalarWhereWithAggregatesInput[]
    NOT?: UserWalletScalarWhereWithAggregatesInput | UserWalletScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"UserWallet"> | number
    UserId?: IntWithAggregatesFilter<"UserWallet"> | number
    Amount?: IntWithAggregatesFilter<"UserWallet"> | number
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    Id?: IntFilter<"Vehicle"> | number
    Model?: StringFilter<"Vehicle"> | string
    Year?: StringFilter<"Vehicle"> | string
    Category?: StringFilter<"Vehicle"> | string
    VehicleImage?: StringNullableFilter<"Vehicle"> | string | null
    VehicleInsuranceImage?: StringNullableFilter<"Vehicle"> | string | null
    PermitImage?: StringNullableFilter<"Vehicle"> | string | null
    VehicleNumber?: StringFilter<"Vehicle"> | string
    Bookings?: BookingsListRelationFilter
    DriverVehicle?: DriverVehicleListRelationFilter
    OwnerVehicle?: OwnerVehicleListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    Id?: SortOrder
    Model?: SortOrder
    Year?: SortOrder
    Category?: SortOrder
    VehicleImage?: SortOrderInput | SortOrder
    VehicleInsuranceImage?: SortOrderInput | SortOrder
    PermitImage?: SortOrderInput | SortOrder
    VehicleNumber?: SortOrder
    Bookings?: BookingsOrderByRelationAggregateInput
    DriverVehicle?: DriverVehicleOrderByRelationAggregateInput
    OwnerVehicle?: OwnerVehicleOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    Model?: StringFilter<"Vehicle"> | string
    Year?: StringFilter<"Vehicle"> | string
    Category?: StringFilter<"Vehicle"> | string
    VehicleImage?: StringNullableFilter<"Vehicle"> | string | null
    VehicleInsuranceImage?: StringNullableFilter<"Vehicle"> | string | null
    PermitImage?: StringNullableFilter<"Vehicle"> | string | null
    VehicleNumber?: StringFilter<"Vehicle"> | string
    Bookings?: BookingsListRelationFilter
    DriverVehicle?: DriverVehicleListRelationFilter
    OwnerVehicle?: OwnerVehicleListRelationFilter
  }, "Id">

  export type VehicleOrderByWithAggregationInput = {
    Id?: SortOrder
    Model?: SortOrder
    Year?: SortOrder
    Category?: SortOrder
    VehicleImage?: SortOrderInput | SortOrder
    VehicleInsuranceImage?: SortOrderInput | SortOrder
    PermitImage?: SortOrderInput | SortOrder
    VehicleNumber?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Vehicle"> | number
    Model?: StringWithAggregatesFilter<"Vehicle"> | string
    Year?: StringWithAggregatesFilter<"Vehicle"> | string
    Category?: StringWithAggregatesFilter<"Vehicle"> | string
    VehicleImage?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    VehicleInsuranceImage?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    PermitImage?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    VehicleNumber?: StringWithAggregatesFilter<"Vehicle"> | string
  }

  export type otpsWhereInput = {
    AND?: otpsWhereInput | otpsWhereInput[]
    OR?: otpsWhereInput[]
    NOT?: otpsWhereInput | otpsWhereInput[]
    CreatedAt?: DateTimeFilter<"otps"> | Date | string
    ExpiresAt?: DateTimeFilter<"otps"> | Date | string
    Id?: IntFilter<"otps"> | number
    MobileNumber?: StringFilter<"otps"> | string
    Otp?: StringFilter<"otps"> | string
  }

  export type otpsOrderByWithRelationInput = {
    CreatedAt?: SortOrder
    ExpiresAt?: SortOrder
    Id?: SortOrder
    MobileNumber?: SortOrder
    Otp?: SortOrder
  }

  export type otpsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    MobileNumber?: string
    AND?: otpsWhereInput | otpsWhereInput[]
    OR?: otpsWhereInput[]
    NOT?: otpsWhereInput | otpsWhereInput[]
    CreatedAt?: DateTimeFilter<"otps"> | Date | string
    ExpiresAt?: DateTimeFilter<"otps"> | Date | string
    Otp?: StringFilter<"otps"> | string
  }, "Id" | "MobileNumber">

  export type otpsOrderByWithAggregationInput = {
    CreatedAt?: SortOrder
    ExpiresAt?: SortOrder
    Id?: SortOrder
    MobileNumber?: SortOrder
    Otp?: SortOrder
    _count?: otpsCountOrderByAggregateInput
    _avg?: otpsAvgOrderByAggregateInput
    _max?: otpsMaxOrderByAggregateInput
    _min?: otpsMinOrderByAggregateInput
    _sum?: otpsSumOrderByAggregateInput
  }

  export type otpsScalarWhereWithAggregatesInput = {
    AND?: otpsScalarWhereWithAggregatesInput | otpsScalarWhereWithAggregatesInput[]
    OR?: otpsScalarWhereWithAggregatesInput[]
    NOT?: otpsScalarWhereWithAggregatesInput | otpsScalarWhereWithAggregatesInput[]
    CreatedAt?: DateTimeWithAggregatesFilter<"otps"> | Date | string
    ExpiresAt?: DateTimeWithAggregatesFilter<"otps"> | Date | string
    Id?: IntWithAggregatesFilter<"otps"> | number
    MobileNumber?: StringWithAggregatesFilter<"otps"> | string
    Otp?: StringWithAggregatesFilter<"otps"> | string
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: StringFilter<"admin"> | string
    email?: StringFilter<"admin"> | string
    passwordHash?: StringFilter<"admin"> | string
    fullName?: StringFilter<"admin"> | string
    isActive?: BoolFilter<"admin"> | boolean
    createdAt?: DateTimeFilter<"admin"> | Date | string
    updatedAt?: DateTimeFilter<"admin"> | Date | string
    lastLogin?: DateTimeNullableFilter<"admin"> | Date | string | null
    permission_audit_logs?: Permission_audit_logsListRelationFilter
    roles?: RolesListRelationFilter
    user_roles_user_roles_adminIdToadmin?: User_rolesListRelationFilter
    user_roles_user_roles_assignedByIdToadmin?: User_rolesListRelationFilter
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    permission_audit_logs?: permission_audit_logsOrderByRelationAggregateInput
    roles?: rolesOrderByRelationAggregateInput
    user_roles_user_roles_adminIdToadmin?: user_rolesOrderByRelationAggregateInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesOrderByRelationAggregateInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    passwordHash?: StringFilter<"admin"> | string
    fullName?: StringFilter<"admin"> | string
    isActive?: BoolFilter<"admin"> | boolean
    createdAt?: DateTimeFilter<"admin"> | Date | string
    updatedAt?: DateTimeFilter<"admin"> | Date | string
    lastLogin?: DateTimeNullableFilter<"admin"> | Date | string | null
    permission_audit_logs?: Permission_audit_logsListRelationFilter
    roles?: RolesListRelationFilter
    user_roles_user_roles_adminIdToadmin?: User_rolesListRelationFilter
    user_roles_user_roles_assignedByIdToadmin?: User_rolesListRelationFilter
  }, "id" | "email">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: adminCountOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admin"> | string
    email?: StringWithAggregatesFilter<"admin"> | string
    passwordHash?: StringWithAggregatesFilter<"admin"> | string
    fullName?: StringWithAggregatesFilter<"admin"> | string
    isActive?: BoolWithAggregatesFilter<"admin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"admin"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
  }

  export type permission_audit_logsWhereInput = {
    AND?: permission_audit_logsWhereInput | permission_audit_logsWhereInput[]
    OR?: permission_audit_logsWhereInput[]
    NOT?: permission_audit_logsWhereInput | permission_audit_logsWhereInput[]
    id?: StringFilter<"permission_audit_logs"> | string
    actionType?: EnumAuditActionTypeFilter<"permission_audit_logs"> | $Enums.AuditActionType
    details?: StringNullableFilter<"permission_audit_logs"> | string | null
    actionTimestamp?: DateTimeFilter<"permission_audit_logs"> | Date | string
    adminId?: StringFilter<"permission_audit_logs"> | string
    roleId?: StringNullableFilter<"permission_audit_logs"> | string | null
    permissionId?: StringNullableFilter<"permission_audit_logs"> | string | null
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
    permissions?: XOR<PermissionsNullableScalarRelationFilter, permissionsWhereInput> | null
    roles?: XOR<RolesNullableScalarRelationFilter, rolesWhereInput> | null
  }

  export type permission_audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    actionType?: SortOrder
    details?: SortOrderInput | SortOrder
    actionTimestamp?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrderInput | SortOrder
    permissionId?: SortOrderInput | SortOrder
    admin?: adminOrderByWithRelationInput
    permissions?: permissionsOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type permission_audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: permission_audit_logsWhereInput | permission_audit_logsWhereInput[]
    OR?: permission_audit_logsWhereInput[]
    NOT?: permission_audit_logsWhereInput | permission_audit_logsWhereInput[]
    actionType?: EnumAuditActionTypeFilter<"permission_audit_logs"> | $Enums.AuditActionType
    details?: StringNullableFilter<"permission_audit_logs"> | string | null
    actionTimestamp?: DateTimeFilter<"permission_audit_logs"> | Date | string
    adminId?: StringFilter<"permission_audit_logs"> | string
    roleId?: StringNullableFilter<"permission_audit_logs"> | string | null
    permissionId?: StringNullableFilter<"permission_audit_logs"> | string | null
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
    permissions?: XOR<PermissionsNullableScalarRelationFilter, permissionsWhereInput> | null
    roles?: XOR<RolesNullableScalarRelationFilter, rolesWhereInput> | null
  }, "id">

  export type permission_audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    actionType?: SortOrder
    details?: SortOrderInput | SortOrder
    actionTimestamp?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrderInput | SortOrder
    permissionId?: SortOrderInput | SortOrder
    _count?: permission_audit_logsCountOrderByAggregateInput
    _max?: permission_audit_logsMaxOrderByAggregateInput
    _min?: permission_audit_logsMinOrderByAggregateInput
  }

  export type permission_audit_logsScalarWhereWithAggregatesInput = {
    AND?: permission_audit_logsScalarWhereWithAggregatesInput | permission_audit_logsScalarWhereWithAggregatesInput[]
    OR?: permission_audit_logsScalarWhereWithAggregatesInput[]
    NOT?: permission_audit_logsScalarWhereWithAggregatesInput | permission_audit_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"permission_audit_logs"> | string
    actionType?: EnumAuditActionTypeWithAggregatesFilter<"permission_audit_logs"> | $Enums.AuditActionType
    details?: StringNullableWithAggregatesFilter<"permission_audit_logs"> | string | null
    actionTimestamp?: DateTimeWithAggregatesFilter<"permission_audit_logs"> | Date | string
    adminId?: StringWithAggregatesFilter<"permission_audit_logs"> | string
    roleId?: StringNullableWithAggregatesFilter<"permission_audit_logs"> | string | null
    permissionId?: StringNullableWithAggregatesFilter<"permission_audit_logs"> | string | null
  }

  export type permission_categoriesWhereInput = {
    AND?: permission_categoriesWhereInput | permission_categoriesWhereInput[]
    OR?: permission_categoriesWhereInput[]
    NOT?: permission_categoriesWhereInput | permission_categoriesWhereInput[]
    id?: StringFilter<"permission_categories"> | string
    name?: StringFilter<"permission_categories"> | string
    description?: StringNullableFilter<"permission_categories"> | string | null
    icon?: StringNullableFilter<"permission_categories"> | string | null
    displayOrder?: IntFilter<"permission_categories"> | number
    permissions?: PermissionsListRelationFilter
  }

  export type permission_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    permissions?: permissionsOrderByRelationAggregateInput
  }

  export type permission_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: permission_categoriesWhereInput | permission_categoriesWhereInput[]
    OR?: permission_categoriesWhereInput[]
    NOT?: permission_categoriesWhereInput | permission_categoriesWhereInput[]
    description?: StringNullableFilter<"permission_categories"> | string | null
    icon?: StringNullableFilter<"permission_categories"> | string | null
    displayOrder?: IntFilter<"permission_categories"> | number
    permissions?: PermissionsListRelationFilter
  }, "id" | "name">

  export type permission_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    _count?: permission_categoriesCountOrderByAggregateInput
    _avg?: permission_categoriesAvgOrderByAggregateInput
    _max?: permission_categoriesMaxOrderByAggregateInput
    _min?: permission_categoriesMinOrderByAggregateInput
    _sum?: permission_categoriesSumOrderByAggregateInput
  }

  export type permission_categoriesScalarWhereWithAggregatesInput = {
    AND?: permission_categoriesScalarWhereWithAggregatesInput | permission_categoriesScalarWhereWithAggregatesInput[]
    OR?: permission_categoriesScalarWhereWithAggregatesInput[]
    NOT?: permission_categoriesScalarWhereWithAggregatesInput | permission_categoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"permission_categories"> | string
    name?: StringWithAggregatesFilter<"permission_categories"> | string
    description?: StringNullableWithAggregatesFilter<"permission_categories"> | string | null
    icon?: StringNullableWithAggregatesFilter<"permission_categories"> | string | null
    displayOrder?: IntWithAggregatesFilter<"permission_categories"> | number
  }

  export type permissionsWhereInput = {
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    id?: StringFilter<"permissions"> | string
    name?: StringFilter<"permissions"> | string
    code?: StringFilter<"permissions"> | string
    description?: StringNullableFilter<"permissions"> | string | null
    categoryId?: StringFilter<"permissions"> | string
    permission_audit_logs?: Permission_audit_logsListRelationFilter
    permission_categories?: XOR<Permission_categoriesScalarRelationFilter, permission_categoriesWhereInput>
    role_permissions?: Role_permissionsListRelationFilter
  }

  export type permissionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    permission_audit_logs?: permission_audit_logsOrderByRelationAggregateInput
    permission_categories?: permission_categoriesOrderByWithRelationInput
    role_permissions?: role_permissionsOrderByRelationAggregateInput
  }

  export type permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    name?: StringFilter<"permissions"> | string
    description?: StringNullableFilter<"permissions"> | string | null
    categoryId?: StringFilter<"permissions"> | string
    permission_audit_logs?: Permission_audit_logsListRelationFilter
    permission_categories?: XOR<Permission_categoriesScalarRelationFilter, permission_categoriesWhereInput>
    role_permissions?: Role_permissionsListRelationFilter
  }, "id" | "code">

  export type permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    _count?: permissionsCountOrderByAggregateInput
    _max?: permissionsMaxOrderByAggregateInput
    _min?: permissionsMinOrderByAggregateInput
  }

  export type permissionsScalarWhereWithAggregatesInput = {
    AND?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    OR?: permissionsScalarWhereWithAggregatesInput[]
    NOT?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"permissions"> | string
    name?: StringWithAggregatesFilter<"permissions"> | string
    code?: StringWithAggregatesFilter<"permissions"> | string
    description?: StringNullableWithAggregatesFilter<"permissions"> | string | null
    categoryId?: StringWithAggregatesFilter<"permissions"> | string
  }

  export type role_permissionsWhereInput = {
    AND?: role_permissionsWhereInput | role_permissionsWhereInput[]
    OR?: role_permissionsWhereInput[]
    NOT?: role_permissionsWhereInput | role_permissionsWhereInput[]
    id?: StringFilter<"role_permissions"> | string
    roleId?: StringFilter<"role_permissions"> | string
    permissionId?: StringFilter<"role_permissions"> | string
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type role_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    permissions?: permissionsOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type role_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: role_permissionsRoleIdPermissionIdCompoundUniqueInput
    AND?: role_permissionsWhereInput | role_permissionsWhereInput[]
    OR?: role_permissionsWhereInput[]
    NOT?: role_permissionsWhereInput | role_permissionsWhereInput[]
    roleId?: StringFilter<"role_permissions"> | string
    permissionId?: StringFilter<"role_permissions"> | string
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "id" | "roleId_permissionId">

  export type role_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: role_permissionsCountOrderByAggregateInput
    _max?: role_permissionsMaxOrderByAggregateInput
    _min?: role_permissionsMinOrderByAggregateInput
  }

  export type role_permissionsScalarWhereWithAggregatesInput = {
    AND?: role_permissionsScalarWhereWithAggregatesInput | role_permissionsScalarWhereWithAggregatesInput[]
    OR?: role_permissionsScalarWhereWithAggregatesInput[]
    NOT?: role_permissionsScalarWhereWithAggregatesInput | role_permissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"role_permissions"> | string
    roleId?: StringWithAggregatesFilter<"role_permissions"> | string
    permissionId?: StringWithAggregatesFilter<"role_permissions"> | string
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: StringFilter<"roles"> | string
    name?: StringFilter<"roles"> | string
    description?: StringNullableFilter<"roles"> | string | null
    isSystemRole?: BoolFilter<"roles"> | boolean
    createdAt?: DateTimeFilter<"roles"> | Date | string
    updatedAt?: DateTimeFilter<"roles"> | Date | string
    createdById?: StringNullableFilter<"roles"> | string | null
    permission_audit_logs?: Permission_audit_logsListRelationFilter
    role_permissions?: Role_permissionsListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    user_roles?: User_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    permission_audit_logs?: permission_audit_logsOrderByRelationAggregateInput
    role_permissions?: role_permissionsOrderByRelationAggregateInput
    admin?: adminOrderByWithRelationInput
    user_roles?: user_rolesOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    description?: StringNullableFilter<"roles"> | string | null
    isSystemRole?: BoolFilter<"roles"> | boolean
    createdAt?: DateTimeFilter<"roles"> | Date | string
    updatedAt?: DateTimeFilter<"roles"> | Date | string
    createdById?: StringNullableFilter<"roles"> | string | null
    permission_audit_logs?: Permission_audit_logsListRelationFilter
    role_permissions?: Role_permissionsListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    user_roles?: User_rolesListRelationFilter
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"roles"> | string
    name?: StringWithAggregatesFilter<"roles"> | string
    description?: StringNullableWithAggregatesFilter<"roles"> | string | null
    isSystemRole?: BoolWithAggregatesFilter<"roles"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"roles"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"roles"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"roles"> | string | null
  }

  export type user_rolesWhereInput = {
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    id?: StringFilter<"user_roles"> | string
    assignedAt?: DateTimeFilter<"user_roles"> | Date | string
    adminId?: StringFilter<"user_roles"> | string
    roleId?: StringFilter<"user_roles"> | string
    assignedById?: StringNullableFilter<"user_roles"> | string | null
    admin_user_roles_adminIdToadmin?: XOR<AdminScalarRelationFilter, adminWhereInput>
    admin_user_roles_assignedByIdToadmin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type user_rolesOrderByWithRelationInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    admin_user_roles_adminIdToadmin?: adminOrderByWithRelationInput
    admin_user_roles_assignedByIdToadmin?: adminOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminId_roleId?: user_rolesAdminIdRoleIdCompoundUniqueInput
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    assignedAt?: DateTimeFilter<"user_roles"> | Date | string
    adminId?: StringFilter<"user_roles"> | string
    roleId?: StringFilter<"user_roles"> | string
    assignedById?: StringNullableFilter<"user_roles"> | string | null
    admin_user_roles_adminIdToadmin?: XOR<AdminScalarRelationFilter, adminWhereInput>
    admin_user_roles_assignedByIdToadmin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "id" | "adminId_roleId">

  export type user_rolesOrderByWithAggregationInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    _count?: user_rolesCountOrderByAggregateInput
    _max?: user_rolesMaxOrderByAggregateInput
    _min?: user_rolesMinOrderByAggregateInput
  }

  export type user_rolesScalarWhereWithAggregatesInput = {
    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    OR?: user_rolesScalarWhereWithAggregatesInput[]
    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_roles"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"user_roles"> | Date | string
    adminId?: StringWithAggregatesFilter<"user_roles"> | string
    roleId?: StringWithAggregatesFilter<"user_roles"> | string
    assignedById?: StringNullableWithAggregatesFilter<"user_roles"> | string | null
  }

  export type BookingsCreateInput = {
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    Fare: string
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    Driver?: DriverCreateNestedOneWithoutBookingsInput
    User: UserCreateNestedOneWithoutBookingsInput
    Vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutBookingsInput
  }

  export type BookingsUncheckedCreateInput = {
    Id?: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    DriverId?: number | null
    Fare: string
    VehicleId?: number | null
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type BookingsUpdateInput = {
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Driver?: DriverUpdateOneWithoutBookingsNestedInput
    User?: UserUpdateOneRequiredWithoutBookingsNestedInput
    Vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverId?: NullableIntFieldUpdateOperationsInput | number | null
    Fare?: StringFieldUpdateOperationsInput | string
    VehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsCreateManyInput = {
    Id?: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    DriverId?: number | null
    Fare: string
    VehicleId?: number | null
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
  }

  export type BookingsUpdateManyMutationInput = {
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverId?: NullableIntFieldUpdateOperationsInput | number | null
    Fare?: StringFieldUpdateOperationsInput | string
    VehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    Id?: number
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsUncheckedCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletUncheckedCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUncheckedUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUncheckedUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    Id?: number
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
  }

  export type DriverUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DriverUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DriverVehicleCreateInput = {
    Driver: DriverCreateNestedOneWithoutDriverVehicleInput
    Vehicle: VehicleCreateNestedOneWithoutDriverVehicleInput
  }

  export type DriverVehicleUncheckedCreateInput = {
    Id?: number
    DriverId: number
    VehicleId: number
  }

  export type DriverVehicleUpdateInput = {
    Driver?: DriverUpdateOneRequiredWithoutDriverVehicleNestedInput
    Vehicle?: VehicleUpdateOneRequiredWithoutDriverVehicleNestedInput
  }

  export type DriverVehicleUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type DriverVehicleCreateManyInput = {
    Id?: number
    DriverId: number
    VehicleId: number
  }

  export type DriverVehicleUpdateManyMutationInput = {

  }

  export type DriverVehicleUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type DriverWalletCreateInput = {
    Amount: number
    LastUpdated?: Date | string
    Driver: DriverCreateNestedOneWithoutDriverWalletInput
  }

  export type DriverWalletUncheckedCreateInput = {
    Id?: number
    DriverId: number
    Amount: number
    LastUpdated?: Date | string
  }

  export type DriverWalletUpdateInput = {
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    Driver?: DriverUpdateOneRequiredWithoutDriverWalletNestedInput
  }

  export type DriverWalletUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverWalletCreateManyInput = {
    Id?: number
    DriverId: number
    Amount: number
    LastUpdated?: Date | string
  }

  export type DriverWalletUpdateManyMutationInput = {
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverWalletUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareNegotiationCreateInput = {
    NegotiatedFare: string
    NegotiatedTime?: Date | string
    Bookings: BookingsCreateNestedOneWithoutFareNegotiationInput
    Driver: DriverCreateNestedOneWithoutFareNegotiationInput
    Owner: OwnerCreateNestedOneWithoutFareNegotiationInput
  }

  export type FareNegotiationUncheckedCreateInput = {
    Id?: number
    BookingId: number
    DriverId: number
    OwnerId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type FareNegotiationUpdateInput = {
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookings?: BookingsUpdateOneRequiredWithoutFareNegotiationNestedInput
    Driver?: DriverUpdateOneRequiredWithoutFareNegotiationNestedInput
    Owner?: OwnerUpdateOneRequiredWithoutFareNegotiationNestedInput
  }

  export type FareNegotiationUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    BookingId?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareNegotiationCreateManyInput = {
    Id?: number
    BookingId: number
    DriverId: number
    OwnerId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type FareNegotiationUpdateManyMutationInput = {
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareNegotiationUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    BookingId?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerCreateInput = {
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutOwnerInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletCreateNestedOneWithoutOwnerInput
  }

  export type OwnerUncheckedCreateInput = {
    Id?: number
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutOwnerInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleUncheckedCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletUncheckedCreateNestedOneWithoutOwnerInput
  }

  export type OwnerUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUpdateManyWithoutOwnerNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUpdateOneWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUncheckedUpdateOneWithoutOwnerNestedInput
  }

  export type OwnerCreateManyInput = {
    Id?: number
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
  }

  export type OwnerUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDriverCreateInput = {
    Driver: DriverCreateNestedOneWithoutOwnerDriverInput
    Owner: OwnerCreateNestedOneWithoutOwnerDriverInput
  }

  export type OwnerDriverUncheckedCreateInput = {
    Id?: number
    OwnerId: number
    DriverId: number
  }

  export type OwnerDriverUpdateInput = {
    Driver?: DriverUpdateOneRequiredWithoutOwnerDriverNestedInput
    Owner?: OwnerUpdateOneRequiredWithoutOwnerDriverNestedInput
  }

  export type OwnerDriverUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerDriverCreateManyInput = {
    Id?: number
    OwnerId: number
    DriverId: number
  }

  export type OwnerDriverUpdateManyMutationInput = {

  }

  export type OwnerDriverUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerVehicleCreateInput = {
    Owner: OwnerCreateNestedOneWithoutOwnerVehicleInput
    Vehicle: VehicleCreateNestedOneWithoutOwnerVehicleInput
  }

  export type OwnerVehicleUncheckedCreateInput = {
    Id?: number
    OwnerId: number
    VehicleId: number
  }

  export type OwnerVehicleUpdateInput = {
    Owner?: OwnerUpdateOneRequiredWithoutOwnerVehicleNestedInput
    Vehicle?: VehicleUpdateOneRequiredWithoutOwnerVehicleNestedInput
  }

  export type OwnerVehicleUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerVehicleCreateManyInput = {
    Id?: number
    OwnerId: number
    VehicleId: number
  }

  export type OwnerVehicleUpdateManyMutationInput = {

  }

  export type OwnerVehicleUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerWalletCreateInput = {
    Amount: number
    LastUpdated?: Date | string
    Owner: OwnerCreateNestedOneWithoutOwnerWalletInput
  }

  export type OwnerWalletUncheckedCreateInput = {
    Id?: number
    OwnerId: number
    Amount: number
    LastUpdated?: Date | string
  }

  export type OwnerWalletUpdateInput = {
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    Owner?: OwnerUpdateOneRequiredWithoutOwnerWalletNestedInput
  }

  export type OwnerWalletUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerWalletCreateManyInput = {
    Id?: number
    OwnerId: number
    Amount: number
    LastUpdated?: Date | string
  }

  export type OwnerWalletUpdateManyMutationInput = {
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerWalletUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    MobileNumber: string
    CreatedDate?: Date | string
    LastLoggedIn?: Date | string
    Gender: $Enums.Gender
    Name: string
    Bookings?: BookingsCreateNestedManyWithoutUserInput
    UserWallet?: UserWalletCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    Id?: number
    MobileNumber: string
    CreatedDate?: Date | string
    LastLoggedIn?: Date | string
    Gender: $Enums.Gender
    Name: string
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUserInput
    UserWallet?: UserWalletUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUpdateManyWithoutUserNestedInput
    UserWallet?: UserWalletUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUncheckedUpdateManyWithoutUserNestedInput
    UserWallet?: UserWalletUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    Id?: number
    MobileNumber: string
    CreatedDate?: Date | string
    LastLoggedIn?: Date | string
    Gender: $Enums.Gender
    Name: string
  }

  export type UserUpdateManyMutationInput = {
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type UserWalletCreateInput = {
    Amount: number
    User: UserCreateNestedOneWithoutUserWalletInput
  }

  export type UserWalletUncheckedCreateInput = {
    Id?: number
    UserId: number
    Amount: number
  }

  export type UserWalletUpdateInput = {
    Amount?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutUserWalletNestedInput
  }

  export type UserWalletUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
  }

  export type UserWalletCreateManyInput = {
    Id?: number
    UserId: number
    Amount: number
  }

  export type UserWalletUpdateManyMutationInput = {
    Amount?: IntFieldUpdateOperationsInput | number
  }

  export type UserWalletUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleCreateInput = {
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    Bookings?: BookingsCreateNestedManyWithoutVehicleInput
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutVehicleInput
    OwnerVehicle?: OwnerVehicleCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    Id?: number
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    Bookings?: BookingsUncheckedCreateNestedManyWithoutVehicleInput
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutVehicleInput
    OwnerVehicle?: OwnerVehicleUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUpdateManyWithoutVehicleNestedInput
    DriverVehicle?: DriverVehicleUpdateManyWithoutVehicleNestedInput
    OwnerVehicle?: OwnerVehicleUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUncheckedUpdateManyWithoutVehicleNestedInput
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    OwnerVehicle?: OwnerVehicleUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    Id?: number
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
  }

  export type VehicleUpdateManyMutationInput = {
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
  }

  export type otpsCreateInput = {
    CreatedAt?: Date | string
    ExpiresAt?: Date | string
    MobileNumber: string
    Otp: string
  }

  export type otpsUncheckedCreateInput = {
    CreatedAt?: Date | string
    ExpiresAt?: Date | string
    Id?: number
    MobileNumber: string
    Otp: string
  }

  export type otpsUpdateInput = {
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Otp?: StringFieldUpdateOperationsInput | string
  }

  export type otpsUncheckedUpdateInput = {
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Id?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Otp?: StringFieldUpdateOperationsInput | string
  }

  export type otpsCreateManyInput = {
    CreatedAt?: Date | string
    ExpiresAt?: Date | string
    Id?: number
    MobileNumber: string
    Otp: string
  }

  export type otpsUpdateManyMutationInput = {
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Otp?: StringFieldUpdateOperationsInput | string
  }

  export type otpsUncheckedUpdateManyInput = {
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Id?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    Otp?: StringFieldUpdateOperationsInput | string
  }

  export type adminCreateInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutAdminInput
    roles?: rolesCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminUncheckedCreateInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutAdminInput
    roles?: rolesUncheckedCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutAdminNestedInput
    roles?: rolesUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutAdminNestedInput
    roles?: rolesUncheckedUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type adminCreateManyInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
  }

  export type adminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permission_audit_logsCreateInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    admin: adminCreateNestedOneWithoutPermission_audit_logsInput
    permissions?: permissionsCreateNestedOneWithoutPermission_audit_logsInput
    roles?: rolesCreateNestedOneWithoutPermission_audit_logsInput
  }

  export type permission_audit_logsUncheckedCreateInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    adminId: string
    roleId?: string | null
    permissionId?: string | null
  }

  export type permission_audit_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutPermission_audit_logsNestedInput
    permissions?: permissionsUpdateOneWithoutPermission_audit_logsNestedInput
    roles?: rolesUpdateOneWithoutPermission_audit_logsNestedInput
  }

  export type permission_audit_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permission_audit_logsCreateManyInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    adminId: string
    roleId?: string | null
    permissionId?: string | null
  }

  export type permission_audit_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permission_audit_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permission_categoriesCreateInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    displayOrder?: number
    permissions?: permissionsCreateNestedManyWithoutPermission_categoriesInput
  }

  export type permission_categoriesUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    displayOrder?: number
    permissions?: permissionsUncheckedCreateNestedManyWithoutPermission_categoriesInput
  }

  export type permission_categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    permissions?: permissionsUpdateManyWithoutPermission_categoriesNestedInput
  }

  export type permission_categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    permissions?: permissionsUncheckedUpdateManyWithoutPermission_categoriesNestedInput
  }

  export type permission_categoriesCreateManyInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    displayOrder?: number
  }

  export type permission_categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type permission_categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type permissionsCreateInput = {
    id: string
    name: string
    code: string
    description?: string | null
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutPermissionsInput
    permission_categories: permission_categoriesCreateNestedOneWithoutPermissionsInput
    role_permissions?: role_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateInput = {
    id: string
    name: string
    code: string
    description?: string | null
    categoryId: string
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutPermissionsInput
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutPermissionsNestedInput
    permission_categories?: permission_categoriesUpdateOneRequiredWithoutPermissionsNestedInput
    role_permissions?: role_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutPermissionsNestedInput
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsCreateManyInput = {
    id: string
    name: string
    code: string
    description?: string | null
    categoryId: string
  }

  export type permissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type role_permissionsCreateInput = {
    id: string
    permissions: permissionsCreateNestedOneWithoutRole_permissionsInput
    roles: rolesCreateNestedOneWithoutRole_permissionsInput
  }

  export type role_permissionsUncheckedCreateInput = {
    id: string
    roleId: string
    permissionId: string
  }

  export type role_permissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: permissionsUpdateOneRequiredWithoutRole_permissionsNestedInput
    roles?: rolesUpdateOneRequiredWithoutRole_permissionsNestedInput
  }

  export type role_permissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type role_permissionsCreateManyInput = {
    id: string
    roleId: string
    permissionId: string
  }

  export type role_permissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type role_permissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type rolesCreateInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
    admin?: adminCreateNestedOneWithoutRolesInput
    user_roles?: user_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    createdById?: string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
    admin?: adminUpdateOneWithoutRolesNestedInput
    user_roles?: user_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    createdById?: string | null
  }

  export type rolesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_rolesCreateInput = {
    id: string
    assignedAt?: Date | string
    admin_user_roles_adminIdToadmin: adminCreateNestedOneWithoutUser_roles_user_roles_adminIdToadminInput
    admin_user_roles_assignedByIdToadmin?: adminCreateNestedOneWithoutUser_roles_user_roles_assignedByIdToadminInput
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateInput = {
    id: string
    assignedAt?: Date | string
    adminId: string
    roleId: string
    assignedById?: string | null
  }

  export type user_rolesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_user_roles_adminIdToadmin?: adminUpdateOneRequiredWithoutUser_roles_user_roles_adminIdToadminNestedInput
    admin_user_roles_assignedByIdToadmin?: adminUpdateOneWithoutUser_roles_user_roles_assignedByIdToadminNestedInput
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_rolesCreateManyInput = {
    id: string
    assignedAt?: Date | string
    adminId: string
    roleId: string
    assignedById?: string | null
  }

  export type user_rolesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type EnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DriverNullableScalarRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VehicleNullableScalarRelationFilter = {
    is?: VehicleWhereInput | null
    isNot?: VehicleWhereInput | null
  }

  export type FareNegotiationListRelationFilter = {
    every?: FareNegotiationWhereInput
    some?: FareNegotiationWhereInput
    none?: FareNegotiationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FareNegotiationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingsCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    PickUpLocation?: SortOrder
    DropLocation?: SortOrder
    Product?: SortOrder
    Distance?: SortOrder
    Status?: SortOrder
    PaymentMode?: SortOrder
    BookingTime?: SortOrder
    DriverId?: SortOrder
    Fare?: SortOrder
    VehicleId?: SortOrder
    StartTime?: SortOrder
    CreatedDateTime?: SortOrder
    UpdatedDateTime?: SortOrder
  }

  export type BookingsAvgOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
  }

  export type BookingsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    PickUpLocation?: SortOrder
    DropLocation?: SortOrder
    Product?: SortOrder
    Distance?: SortOrder
    Status?: SortOrder
    PaymentMode?: SortOrder
    BookingTime?: SortOrder
    DriverId?: SortOrder
    Fare?: SortOrder
    VehicleId?: SortOrder
    StartTime?: SortOrder
    CreatedDateTime?: SortOrder
    UpdatedDateTime?: SortOrder
  }

  export type BookingsMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    PickUpLocation?: SortOrder
    DropLocation?: SortOrder
    Product?: SortOrder
    Distance?: SortOrder
    Status?: SortOrder
    PaymentMode?: SortOrder
    BookingTime?: SortOrder
    DriverId?: SortOrder
    Fare?: SortOrder
    VehicleId?: SortOrder
    StartTime?: SortOrder
    CreatedDateTime?: SortOrder
    UpdatedDateTime?: SortOrder
  }

  export type BookingsSumOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BookingsListRelationFilter = {
    every?: BookingsWhereInput
    some?: BookingsWhereInput
    none?: BookingsWhereInput
  }

  export type DriverVehicleListRelationFilter = {
    every?: DriverVehicleWhereInput
    some?: DriverVehicleWhereInput
    none?: DriverVehicleWhereInput
  }

  export type DriverWalletNullableScalarRelationFilter = {
    is?: DriverWalletWhereInput | null
    isNot?: DriverWalletWhereInput | null
  }

  export type OwnerDriverListRelationFilter = {
    every?: OwnerDriverWhereInput
    some?: OwnerDriverWhereInput
    none?: OwnerDriverWhereInput
  }

  export type BookingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverVehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerDriverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Gender?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrder
    DrivingLicenceNumber?: SortOrder
    DrivingLicenceFrontImage?: SortOrder
    DrivingLicenceBackImage?: SortOrder
    DriverImage?: SortOrder
    Email?: SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
    IsOnline?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Gender?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrder
    DrivingLicenceNumber?: SortOrder
    DrivingLicenceFrontImage?: SortOrder
    DrivingLicenceBackImage?: SortOrder
    DriverImage?: SortOrder
    Email?: SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
    IsOnline?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Gender?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrder
    DrivingLicenceNumber?: SortOrder
    DrivingLicenceFrontImage?: SortOrder
    DrivingLicenceBackImage?: SortOrder
    DriverImage?: SortOrder
    Email?: SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
    IsOnline?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DriverScalarRelationFilter = {
    is?: DriverWhereInput
    isNot?: DriverWhereInput
  }

  export type VehicleScalarRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type DriverVehicleCountOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
  }

  export type DriverVehicleAvgOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
  }

  export type DriverVehicleMaxOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
  }

  export type DriverVehicleMinOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
  }

  export type DriverVehicleSumOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    VehicleId?: SortOrder
  }

  export type DriverWalletCountOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
  }

  export type DriverWalletAvgOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    Amount?: SortOrder
  }

  export type DriverWalletMaxOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
  }

  export type DriverWalletMinOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
  }

  export type DriverWalletSumOrderByAggregateInput = {
    Id?: SortOrder
    DriverId?: SortOrder
    Amount?: SortOrder
  }

  export type BookingsScalarRelationFilter = {
    is?: BookingsWhereInput
    isNot?: BookingsWhereInput
  }

  export type OwnerScalarRelationFilter = {
    is?: OwnerWhereInput
    isNot?: OwnerWhereInput
  }

  export type FareNegotiationBookingIdDriverIdCompoundUniqueInput = {
    BookingId: number
    DriverId: number
  }

  export type FareNegotiationCountOrderByAggregateInput = {
    Id?: SortOrder
    BookingId?: SortOrder
    DriverId?: SortOrder
    OwnerId?: SortOrder
    NegotiatedFare?: SortOrder
    NegotiatedTime?: SortOrder
  }

  export type FareNegotiationAvgOrderByAggregateInput = {
    Id?: SortOrder
    BookingId?: SortOrder
    DriverId?: SortOrder
    OwnerId?: SortOrder
  }

  export type FareNegotiationMaxOrderByAggregateInput = {
    Id?: SortOrder
    BookingId?: SortOrder
    DriverId?: SortOrder
    OwnerId?: SortOrder
    NegotiatedFare?: SortOrder
    NegotiatedTime?: SortOrder
  }

  export type FareNegotiationMinOrderByAggregateInput = {
    Id?: SortOrder
    BookingId?: SortOrder
    DriverId?: SortOrder
    OwnerId?: SortOrder
    NegotiatedFare?: SortOrder
    NegotiatedTime?: SortOrder
  }

  export type FareNegotiationSumOrderByAggregateInput = {
    Id?: SortOrder
    BookingId?: SortOrder
    DriverId?: SortOrder
    OwnerId?: SortOrder
  }

  export type OwnerVehicleListRelationFilter = {
    every?: OwnerVehicleWhereInput
    some?: OwnerVehicleWhereInput
    none?: OwnerVehicleWhereInput
  }

  export type OwnerWalletNullableScalarRelationFilter = {
    is?: OwnerWalletWhereInput | null
    isNot?: OwnerWalletWhereInput | null
  }

  export type OwnerVehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrder
    Email?: SortOrder
    Gender?: SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
  }

  export type OwnerAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type OwnerMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrder
    Email?: SortOrder
    Gender?: SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
  }

  export type OwnerMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    DOB?: SortOrder
    Email?: SortOrder
    Gender?: SortOrder
    AdhaarCardNumber?: SortOrder
    FrontSideAdhaarImage?: SortOrder
    BackSideAdhaarImage?: SortOrder
    PanNumber?: SortOrder
    PanImage?: SortOrder
    LastLoggedIn?: SortOrder
    CreatedDate?: SortOrder
  }

  export type OwnerSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type OwnerDriverCountOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    DriverId?: SortOrder
  }

  export type OwnerDriverAvgOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    DriverId?: SortOrder
  }

  export type OwnerDriverMaxOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    DriverId?: SortOrder
  }

  export type OwnerDriverMinOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    DriverId?: SortOrder
  }

  export type OwnerDriverSumOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    DriverId?: SortOrder
  }

  export type OwnerVehicleCountOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    VehicleId?: SortOrder
  }

  export type OwnerVehicleAvgOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    VehicleId?: SortOrder
  }

  export type OwnerVehicleMaxOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    VehicleId?: SortOrder
  }

  export type OwnerVehicleMinOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    VehicleId?: SortOrder
  }

  export type OwnerVehicleSumOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    VehicleId?: SortOrder
  }

  export type OwnerWalletCountOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
  }

  export type OwnerWalletAvgOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    Amount?: SortOrder
  }

  export type OwnerWalletMaxOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
  }

  export type OwnerWalletMinOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    Amount?: SortOrder
    LastUpdated?: SortOrder
  }

  export type OwnerWalletSumOrderByAggregateInput = {
    Id?: SortOrder
    OwnerId?: SortOrder
    Amount?: SortOrder
  }

  export type UserWalletNullableScalarRelationFilter = {
    is?: UserWalletWhereInput | null
    isNot?: UserWalletWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    Id?: SortOrder
    MobileNumber?: SortOrder
    CreatedDate?: SortOrder
    LastLoggedIn?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    Id?: SortOrder
    MobileNumber?: SortOrder
    CreatedDate?: SortOrder
    LastLoggedIn?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    Id?: SortOrder
    MobileNumber?: SortOrder
    CreatedDate?: SortOrder
    LastLoggedIn?: SortOrder
    Gender?: SortOrder
    Name?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UserWalletCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
  }

  export type UserWalletAvgOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
  }

  export type UserWalletMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
  }

  export type UserWalletMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
  }

  export type UserWalletSumOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    Id?: SortOrder
    Model?: SortOrder
    Year?: SortOrder
    Category?: SortOrder
    VehicleImage?: SortOrder
    VehicleInsuranceImage?: SortOrder
    PermitImage?: SortOrder
    VehicleNumber?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    Id?: SortOrder
    Model?: SortOrder
    Year?: SortOrder
    Category?: SortOrder
    VehicleImage?: SortOrder
    VehicleInsuranceImage?: SortOrder
    PermitImage?: SortOrder
    VehicleNumber?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    Id?: SortOrder
    Model?: SortOrder
    Year?: SortOrder
    Category?: SortOrder
    VehicleImage?: SortOrder
    VehicleInsuranceImage?: SortOrder
    PermitImage?: SortOrder
    VehicleNumber?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type otpsCountOrderByAggregateInput = {
    CreatedAt?: SortOrder
    ExpiresAt?: SortOrder
    Id?: SortOrder
    MobileNumber?: SortOrder
    Otp?: SortOrder
  }

  export type otpsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type otpsMaxOrderByAggregateInput = {
    CreatedAt?: SortOrder
    ExpiresAt?: SortOrder
    Id?: SortOrder
    MobileNumber?: SortOrder
    Otp?: SortOrder
  }

  export type otpsMinOrderByAggregateInput = {
    CreatedAt?: SortOrder
    ExpiresAt?: SortOrder
    Id?: SortOrder
    MobileNumber?: SortOrder
    Otp?: SortOrder
  }

  export type otpsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type Permission_audit_logsListRelationFilter = {
    every?: permission_audit_logsWhereInput
    some?: permission_audit_logsWhereInput
    none?: permission_audit_logsWhereInput
  }

  export type RolesListRelationFilter = {
    every?: rolesWhereInput
    some?: rolesWhereInput
    none?: rolesWhereInput
  }

  export type User_rolesListRelationFilter = {
    every?: user_rolesWhereInput
    some?: user_rolesWhereInput
    none?: user_rolesWhereInput
  }

  export type permission_audit_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type EnumAuditActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditActionType | EnumAuditActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionTypeFilter<$PrismaModel> | $Enums.AuditActionType
  }

  export type AdminScalarRelationFilter = {
    is?: adminWhereInput
    isNot?: adminWhereInput
  }

  export type PermissionsNullableScalarRelationFilter = {
    is?: permissionsWhereInput | null
    isNot?: permissionsWhereInput | null
  }

  export type RolesNullableScalarRelationFilter = {
    is?: rolesWhereInput | null
    isNot?: rolesWhereInput | null
  }

  export type permission_audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    details?: SortOrder
    actionTimestamp?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type permission_audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    details?: SortOrder
    actionTimestamp?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type permission_audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    details?: SortOrder
    actionTimestamp?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type EnumAuditActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditActionType | EnumAuditActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditActionTypeFilter<$PrismaModel>
  }

  export type PermissionsListRelationFilter = {
    every?: permissionsWhereInput
    some?: permissionsWhereInput
    none?: permissionsWhereInput
  }

  export type permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permission_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
  }

  export type permission_categoriesAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type permission_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
  }

  export type permission_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    displayOrder?: SortOrder
  }

  export type permission_categoriesSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type Permission_categoriesScalarRelationFilter = {
    is?: permission_categoriesWhereInput
    isNot?: permission_categoriesWhereInput
  }

  export type Role_permissionsListRelationFilter = {
    every?: role_permissionsWhereInput
    some?: role_permissionsWhereInput
    none?: role_permissionsWhereInput
  }

  export type role_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
  }

  export type PermissionsScalarRelationFilter = {
    is?: permissionsWhereInput
    isNot?: permissionsWhereInput
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type role_permissionsRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type role_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type role_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type role_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type AdminNullableScalarRelationFilter = {
    is?: adminWhereInput | null
    isNot?: adminWhereInput | null
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type user_rolesAdminIdRoleIdCompoundUniqueInput = {
    adminId: string
    roleId: string
  }

  export type user_rolesCountOrderByAggregateInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    assignedById?: SortOrder
  }

  export type user_rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    assignedById?: SortOrder
  }

  export type user_rolesMinOrderByAggregateInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    assignedById?: SortOrder
  }

  export type DriverCreateNestedOneWithoutBookingsInput = {
    create?: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutBookingsInput
    connect?: DriverWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutBookingsInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    connect?: VehicleWhereUniqueInput
  }

  export type FareNegotiationCreateNestedManyWithoutBookingsInput = {
    create?: XOR<FareNegotiationCreateWithoutBookingsInput, FareNegotiationUncheckedCreateWithoutBookingsInput> | FareNegotiationCreateWithoutBookingsInput[] | FareNegotiationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutBookingsInput | FareNegotiationCreateOrConnectWithoutBookingsInput[]
    createMany?: FareNegotiationCreateManyBookingsInputEnvelope
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
  }

  export type FareNegotiationUncheckedCreateNestedManyWithoutBookingsInput = {
    create?: XOR<FareNegotiationCreateWithoutBookingsInput, FareNegotiationUncheckedCreateWithoutBookingsInput> | FareNegotiationCreateWithoutBookingsInput[] | FareNegotiationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutBookingsInput | FareNegotiationCreateOrConnectWithoutBookingsInput[]
    createMany?: FareNegotiationCreateManyBookingsInputEnvelope
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type EnumPaymentModeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMode
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DriverUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutBookingsInput
    upsert?: DriverUpsertWithoutBookingsInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutBookingsInput, DriverUpdateWithoutBookingsInput>, DriverUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    upsert?: VehicleUpsertWithoutBookingsInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutBookingsInput, VehicleUpdateWithoutBookingsInput>, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type FareNegotiationUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<FareNegotiationCreateWithoutBookingsInput, FareNegotiationUncheckedCreateWithoutBookingsInput> | FareNegotiationCreateWithoutBookingsInput[] | FareNegotiationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutBookingsInput | FareNegotiationCreateOrConnectWithoutBookingsInput[]
    upsert?: FareNegotiationUpsertWithWhereUniqueWithoutBookingsInput | FareNegotiationUpsertWithWhereUniqueWithoutBookingsInput[]
    createMany?: FareNegotiationCreateManyBookingsInputEnvelope
    set?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    disconnect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    delete?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    update?: FareNegotiationUpdateWithWhereUniqueWithoutBookingsInput | FareNegotiationUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: FareNegotiationUpdateManyWithWhereWithoutBookingsInput | FareNegotiationUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FareNegotiationUncheckedUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<FareNegotiationCreateWithoutBookingsInput, FareNegotiationUncheckedCreateWithoutBookingsInput> | FareNegotiationCreateWithoutBookingsInput[] | FareNegotiationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutBookingsInput | FareNegotiationCreateOrConnectWithoutBookingsInput[]
    upsert?: FareNegotiationUpsertWithWhereUniqueWithoutBookingsInput | FareNegotiationUpsertWithWhereUniqueWithoutBookingsInput[]
    createMany?: FareNegotiationCreateManyBookingsInputEnvelope
    set?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    disconnect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    delete?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    update?: FareNegotiationUpdateWithWhereUniqueWithoutBookingsInput | FareNegotiationUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: FareNegotiationUpdateManyWithWhereWithoutBookingsInput | FareNegotiationUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
  }

  export type BookingsCreateNestedManyWithoutDriverInput = {
    create?: XOR<BookingsCreateWithoutDriverInput, BookingsUncheckedCreateWithoutDriverInput> | BookingsCreateWithoutDriverInput[] | BookingsUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutDriverInput | BookingsCreateOrConnectWithoutDriverInput[]
    createMany?: BookingsCreateManyDriverInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type DriverVehicleCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverVehicleCreateWithoutDriverInput, DriverVehicleUncheckedCreateWithoutDriverInput> | DriverVehicleCreateWithoutDriverInput[] | DriverVehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutDriverInput | DriverVehicleCreateOrConnectWithoutDriverInput[]
    createMany?: DriverVehicleCreateManyDriverInputEnvelope
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
  }

  export type DriverWalletCreateNestedOneWithoutDriverInput = {
    create?: XOR<DriverWalletCreateWithoutDriverInput, DriverWalletUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverWalletCreateOrConnectWithoutDriverInput
    connect?: DriverWalletWhereUniqueInput
  }

  export type FareNegotiationCreateNestedManyWithoutDriverInput = {
    create?: XOR<FareNegotiationCreateWithoutDriverInput, FareNegotiationUncheckedCreateWithoutDriverInput> | FareNegotiationCreateWithoutDriverInput[] | FareNegotiationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutDriverInput | FareNegotiationCreateOrConnectWithoutDriverInput[]
    createMany?: FareNegotiationCreateManyDriverInputEnvelope
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
  }

  export type OwnerDriverCreateNestedManyWithoutDriverInput = {
    create?: XOR<OwnerDriverCreateWithoutDriverInput, OwnerDriverUncheckedCreateWithoutDriverInput> | OwnerDriverCreateWithoutDriverInput[] | OwnerDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutDriverInput | OwnerDriverCreateOrConnectWithoutDriverInput[]
    createMany?: OwnerDriverCreateManyDriverInputEnvelope
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
  }

  export type BookingsUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<BookingsCreateWithoutDriverInput, BookingsUncheckedCreateWithoutDriverInput> | BookingsCreateWithoutDriverInput[] | BookingsUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutDriverInput | BookingsCreateOrConnectWithoutDriverInput[]
    createMany?: BookingsCreateManyDriverInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type DriverVehicleUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverVehicleCreateWithoutDriverInput, DriverVehicleUncheckedCreateWithoutDriverInput> | DriverVehicleCreateWithoutDriverInput[] | DriverVehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutDriverInput | DriverVehicleCreateOrConnectWithoutDriverInput[]
    createMany?: DriverVehicleCreateManyDriverInputEnvelope
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
  }

  export type DriverWalletUncheckedCreateNestedOneWithoutDriverInput = {
    create?: XOR<DriverWalletCreateWithoutDriverInput, DriverWalletUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverWalletCreateOrConnectWithoutDriverInput
    connect?: DriverWalletWhereUniqueInput
  }

  export type FareNegotiationUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<FareNegotiationCreateWithoutDriverInput, FareNegotiationUncheckedCreateWithoutDriverInput> | FareNegotiationCreateWithoutDriverInput[] | FareNegotiationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutDriverInput | FareNegotiationCreateOrConnectWithoutDriverInput[]
    createMany?: FareNegotiationCreateManyDriverInputEnvelope
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
  }

  export type OwnerDriverUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<OwnerDriverCreateWithoutDriverInput, OwnerDriverUncheckedCreateWithoutDriverInput> | OwnerDriverCreateWithoutDriverInput[] | OwnerDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutDriverInput | OwnerDriverCreateOrConnectWithoutDriverInput[]
    createMany?: OwnerDriverCreateManyDriverInputEnvelope
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BookingsUpdateManyWithoutDriverNestedInput = {
    create?: XOR<BookingsCreateWithoutDriverInput, BookingsUncheckedCreateWithoutDriverInput> | BookingsCreateWithoutDriverInput[] | BookingsUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutDriverInput | BookingsCreateOrConnectWithoutDriverInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutDriverInput | BookingsUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: BookingsCreateManyDriverInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutDriverInput | BookingsUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutDriverInput | BookingsUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type DriverVehicleUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverVehicleCreateWithoutDriverInput, DriverVehicleUncheckedCreateWithoutDriverInput> | DriverVehicleCreateWithoutDriverInput[] | DriverVehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutDriverInput | DriverVehicleCreateOrConnectWithoutDriverInput[]
    upsert?: DriverVehicleUpsertWithWhereUniqueWithoutDriverInput | DriverVehicleUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverVehicleCreateManyDriverInputEnvelope
    set?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    disconnect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    delete?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    update?: DriverVehicleUpdateWithWhereUniqueWithoutDriverInput | DriverVehicleUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverVehicleUpdateManyWithWhereWithoutDriverInput | DriverVehicleUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverVehicleScalarWhereInput | DriverVehicleScalarWhereInput[]
  }

  export type DriverWalletUpdateOneWithoutDriverNestedInput = {
    create?: XOR<DriverWalletCreateWithoutDriverInput, DriverWalletUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverWalletCreateOrConnectWithoutDriverInput
    upsert?: DriverWalletUpsertWithoutDriverInput
    disconnect?: DriverWalletWhereInput | boolean
    delete?: DriverWalletWhereInput | boolean
    connect?: DriverWalletWhereUniqueInput
    update?: XOR<XOR<DriverWalletUpdateToOneWithWhereWithoutDriverInput, DriverWalletUpdateWithoutDriverInput>, DriverWalletUncheckedUpdateWithoutDriverInput>
  }

  export type FareNegotiationUpdateManyWithoutDriverNestedInput = {
    create?: XOR<FareNegotiationCreateWithoutDriverInput, FareNegotiationUncheckedCreateWithoutDriverInput> | FareNegotiationCreateWithoutDriverInput[] | FareNegotiationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutDriverInput | FareNegotiationCreateOrConnectWithoutDriverInput[]
    upsert?: FareNegotiationUpsertWithWhereUniqueWithoutDriverInput | FareNegotiationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: FareNegotiationCreateManyDriverInputEnvelope
    set?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    disconnect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    delete?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    update?: FareNegotiationUpdateWithWhereUniqueWithoutDriverInput | FareNegotiationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: FareNegotiationUpdateManyWithWhereWithoutDriverInput | FareNegotiationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
  }

  export type OwnerDriverUpdateManyWithoutDriverNestedInput = {
    create?: XOR<OwnerDriverCreateWithoutDriverInput, OwnerDriverUncheckedCreateWithoutDriverInput> | OwnerDriverCreateWithoutDriverInput[] | OwnerDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutDriverInput | OwnerDriverCreateOrConnectWithoutDriverInput[]
    upsert?: OwnerDriverUpsertWithWhereUniqueWithoutDriverInput | OwnerDriverUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: OwnerDriverCreateManyDriverInputEnvelope
    set?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    disconnect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    delete?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    update?: OwnerDriverUpdateWithWhereUniqueWithoutDriverInput | OwnerDriverUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: OwnerDriverUpdateManyWithWhereWithoutDriverInput | OwnerDriverUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: OwnerDriverScalarWhereInput | OwnerDriverScalarWhereInput[]
  }

  export type BookingsUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<BookingsCreateWithoutDriverInput, BookingsUncheckedCreateWithoutDriverInput> | BookingsCreateWithoutDriverInput[] | BookingsUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutDriverInput | BookingsCreateOrConnectWithoutDriverInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutDriverInput | BookingsUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: BookingsCreateManyDriverInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutDriverInput | BookingsUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutDriverInput | BookingsUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type DriverVehicleUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverVehicleCreateWithoutDriverInput, DriverVehicleUncheckedCreateWithoutDriverInput> | DriverVehicleCreateWithoutDriverInput[] | DriverVehicleUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutDriverInput | DriverVehicleCreateOrConnectWithoutDriverInput[]
    upsert?: DriverVehicleUpsertWithWhereUniqueWithoutDriverInput | DriverVehicleUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverVehicleCreateManyDriverInputEnvelope
    set?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    disconnect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    delete?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    update?: DriverVehicleUpdateWithWhereUniqueWithoutDriverInput | DriverVehicleUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverVehicleUpdateManyWithWhereWithoutDriverInput | DriverVehicleUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverVehicleScalarWhereInput | DriverVehicleScalarWhereInput[]
  }

  export type DriverWalletUncheckedUpdateOneWithoutDriverNestedInput = {
    create?: XOR<DriverWalletCreateWithoutDriverInput, DriverWalletUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverWalletCreateOrConnectWithoutDriverInput
    upsert?: DriverWalletUpsertWithoutDriverInput
    disconnect?: DriverWalletWhereInput | boolean
    delete?: DriverWalletWhereInput | boolean
    connect?: DriverWalletWhereUniqueInput
    update?: XOR<XOR<DriverWalletUpdateToOneWithWhereWithoutDriverInput, DriverWalletUpdateWithoutDriverInput>, DriverWalletUncheckedUpdateWithoutDriverInput>
  }

  export type FareNegotiationUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<FareNegotiationCreateWithoutDriverInput, FareNegotiationUncheckedCreateWithoutDriverInput> | FareNegotiationCreateWithoutDriverInput[] | FareNegotiationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutDriverInput | FareNegotiationCreateOrConnectWithoutDriverInput[]
    upsert?: FareNegotiationUpsertWithWhereUniqueWithoutDriverInput | FareNegotiationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: FareNegotiationCreateManyDriverInputEnvelope
    set?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    disconnect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    delete?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    update?: FareNegotiationUpdateWithWhereUniqueWithoutDriverInput | FareNegotiationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: FareNegotiationUpdateManyWithWhereWithoutDriverInput | FareNegotiationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
  }

  export type OwnerDriverUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<OwnerDriverCreateWithoutDriverInput, OwnerDriverUncheckedCreateWithoutDriverInput> | OwnerDriverCreateWithoutDriverInput[] | OwnerDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutDriverInput | OwnerDriverCreateOrConnectWithoutDriverInput[]
    upsert?: OwnerDriverUpsertWithWhereUniqueWithoutDriverInput | OwnerDriverUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: OwnerDriverCreateManyDriverInputEnvelope
    set?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    disconnect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    delete?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    update?: OwnerDriverUpdateWithWhereUniqueWithoutDriverInput | OwnerDriverUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: OwnerDriverUpdateManyWithWhereWithoutDriverInput | OwnerDriverUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: OwnerDriverScalarWhereInput | OwnerDriverScalarWhereInput[]
  }

  export type DriverCreateNestedOneWithoutDriverVehicleInput = {
    create?: XOR<DriverCreateWithoutDriverVehicleInput, DriverUncheckedCreateWithoutDriverVehicleInput>
    connectOrCreate?: DriverCreateOrConnectWithoutDriverVehicleInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutDriverVehicleInput = {
    create?: XOR<VehicleCreateWithoutDriverVehicleInput, VehicleUncheckedCreateWithoutDriverVehicleInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverVehicleInput
    connect?: VehicleWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutDriverVehicleNestedInput = {
    create?: XOR<DriverCreateWithoutDriverVehicleInput, DriverUncheckedCreateWithoutDriverVehicleInput>
    connectOrCreate?: DriverCreateOrConnectWithoutDriverVehicleInput
    upsert?: DriverUpsertWithoutDriverVehicleInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutDriverVehicleInput, DriverUpdateWithoutDriverVehicleInput>, DriverUncheckedUpdateWithoutDriverVehicleInput>
  }

  export type VehicleUpdateOneRequiredWithoutDriverVehicleNestedInput = {
    create?: XOR<VehicleCreateWithoutDriverVehicleInput, VehicleUncheckedCreateWithoutDriverVehicleInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverVehicleInput
    upsert?: VehicleUpsertWithoutDriverVehicleInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutDriverVehicleInput, VehicleUpdateWithoutDriverVehicleInput>, VehicleUncheckedUpdateWithoutDriverVehicleInput>
  }

  export type DriverCreateNestedOneWithoutDriverWalletInput = {
    create?: XOR<DriverCreateWithoutDriverWalletInput, DriverUncheckedCreateWithoutDriverWalletInput>
    connectOrCreate?: DriverCreateOrConnectWithoutDriverWalletInput
    connect?: DriverWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutDriverWalletNestedInput = {
    create?: XOR<DriverCreateWithoutDriverWalletInput, DriverUncheckedCreateWithoutDriverWalletInput>
    connectOrCreate?: DriverCreateOrConnectWithoutDriverWalletInput
    upsert?: DriverUpsertWithoutDriverWalletInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutDriverWalletInput, DriverUpdateWithoutDriverWalletInput>, DriverUncheckedUpdateWithoutDriverWalletInput>
  }

  export type BookingsCreateNestedOneWithoutFareNegotiationInput = {
    create?: XOR<BookingsCreateWithoutFareNegotiationInput, BookingsUncheckedCreateWithoutFareNegotiationInput>
    connectOrCreate?: BookingsCreateOrConnectWithoutFareNegotiationInput
    connect?: BookingsWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutFareNegotiationInput = {
    create?: XOR<DriverCreateWithoutFareNegotiationInput, DriverUncheckedCreateWithoutFareNegotiationInput>
    connectOrCreate?: DriverCreateOrConnectWithoutFareNegotiationInput
    connect?: DriverWhereUniqueInput
  }

  export type OwnerCreateNestedOneWithoutFareNegotiationInput = {
    create?: XOR<OwnerCreateWithoutFareNegotiationInput, OwnerUncheckedCreateWithoutFareNegotiationInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutFareNegotiationInput
    connect?: OwnerWhereUniqueInput
  }

  export type BookingsUpdateOneRequiredWithoutFareNegotiationNestedInput = {
    create?: XOR<BookingsCreateWithoutFareNegotiationInput, BookingsUncheckedCreateWithoutFareNegotiationInput>
    connectOrCreate?: BookingsCreateOrConnectWithoutFareNegotiationInput
    upsert?: BookingsUpsertWithoutFareNegotiationInput
    connect?: BookingsWhereUniqueInput
    update?: XOR<XOR<BookingsUpdateToOneWithWhereWithoutFareNegotiationInput, BookingsUpdateWithoutFareNegotiationInput>, BookingsUncheckedUpdateWithoutFareNegotiationInput>
  }

  export type DriverUpdateOneRequiredWithoutFareNegotiationNestedInput = {
    create?: XOR<DriverCreateWithoutFareNegotiationInput, DriverUncheckedCreateWithoutFareNegotiationInput>
    connectOrCreate?: DriverCreateOrConnectWithoutFareNegotiationInput
    upsert?: DriverUpsertWithoutFareNegotiationInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutFareNegotiationInput, DriverUpdateWithoutFareNegotiationInput>, DriverUncheckedUpdateWithoutFareNegotiationInput>
  }

  export type OwnerUpdateOneRequiredWithoutFareNegotiationNestedInput = {
    create?: XOR<OwnerCreateWithoutFareNegotiationInput, OwnerUncheckedCreateWithoutFareNegotiationInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutFareNegotiationInput
    upsert?: OwnerUpsertWithoutFareNegotiationInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutFareNegotiationInput, OwnerUpdateWithoutFareNegotiationInput>, OwnerUncheckedUpdateWithoutFareNegotiationInput>
  }

  export type FareNegotiationCreateNestedManyWithoutOwnerInput = {
    create?: XOR<FareNegotiationCreateWithoutOwnerInput, FareNegotiationUncheckedCreateWithoutOwnerInput> | FareNegotiationCreateWithoutOwnerInput[] | FareNegotiationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutOwnerInput | FareNegotiationCreateOrConnectWithoutOwnerInput[]
    createMany?: FareNegotiationCreateManyOwnerInputEnvelope
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
  }

  export type OwnerDriverCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerDriverCreateWithoutOwnerInput, OwnerDriverUncheckedCreateWithoutOwnerInput> | OwnerDriverCreateWithoutOwnerInput[] | OwnerDriverUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutOwnerInput | OwnerDriverCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerDriverCreateManyOwnerInputEnvelope
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
  }

  export type OwnerVehicleCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerVehicleCreateWithoutOwnerInput, OwnerVehicleUncheckedCreateWithoutOwnerInput> | OwnerVehicleCreateWithoutOwnerInput[] | OwnerVehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutOwnerInput | OwnerVehicleCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerVehicleCreateManyOwnerInputEnvelope
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
  }

  export type OwnerWalletCreateNestedOneWithoutOwnerInput = {
    create?: XOR<OwnerWalletCreateWithoutOwnerInput, OwnerWalletUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OwnerWalletCreateOrConnectWithoutOwnerInput
    connect?: OwnerWalletWhereUniqueInput
  }

  export type FareNegotiationUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<FareNegotiationCreateWithoutOwnerInput, FareNegotiationUncheckedCreateWithoutOwnerInput> | FareNegotiationCreateWithoutOwnerInput[] | FareNegotiationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutOwnerInput | FareNegotiationCreateOrConnectWithoutOwnerInput[]
    createMany?: FareNegotiationCreateManyOwnerInputEnvelope
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
  }

  export type OwnerDriverUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerDriverCreateWithoutOwnerInput, OwnerDriverUncheckedCreateWithoutOwnerInput> | OwnerDriverCreateWithoutOwnerInput[] | OwnerDriverUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutOwnerInput | OwnerDriverCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerDriverCreateManyOwnerInputEnvelope
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
  }

  export type OwnerVehicleUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerVehicleCreateWithoutOwnerInput, OwnerVehicleUncheckedCreateWithoutOwnerInput> | OwnerVehicleCreateWithoutOwnerInput[] | OwnerVehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutOwnerInput | OwnerVehicleCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerVehicleCreateManyOwnerInputEnvelope
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
  }

  export type OwnerWalletUncheckedCreateNestedOneWithoutOwnerInput = {
    create?: XOR<OwnerWalletCreateWithoutOwnerInput, OwnerWalletUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OwnerWalletCreateOrConnectWithoutOwnerInput
    connect?: OwnerWalletWhereUniqueInput
  }

  export type FareNegotiationUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<FareNegotiationCreateWithoutOwnerInput, FareNegotiationUncheckedCreateWithoutOwnerInput> | FareNegotiationCreateWithoutOwnerInput[] | FareNegotiationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutOwnerInput | FareNegotiationCreateOrConnectWithoutOwnerInput[]
    upsert?: FareNegotiationUpsertWithWhereUniqueWithoutOwnerInput | FareNegotiationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: FareNegotiationCreateManyOwnerInputEnvelope
    set?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    disconnect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    delete?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    update?: FareNegotiationUpdateWithWhereUniqueWithoutOwnerInput | FareNegotiationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: FareNegotiationUpdateManyWithWhereWithoutOwnerInput | FareNegotiationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
  }

  export type OwnerDriverUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerDriverCreateWithoutOwnerInput, OwnerDriverUncheckedCreateWithoutOwnerInput> | OwnerDriverCreateWithoutOwnerInput[] | OwnerDriverUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutOwnerInput | OwnerDriverCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerDriverUpsertWithWhereUniqueWithoutOwnerInput | OwnerDriverUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerDriverCreateManyOwnerInputEnvelope
    set?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    disconnect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    delete?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    update?: OwnerDriverUpdateWithWhereUniqueWithoutOwnerInput | OwnerDriverUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerDriverUpdateManyWithWhereWithoutOwnerInput | OwnerDriverUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerDriverScalarWhereInput | OwnerDriverScalarWhereInput[]
  }

  export type OwnerVehicleUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerVehicleCreateWithoutOwnerInput, OwnerVehicleUncheckedCreateWithoutOwnerInput> | OwnerVehicleCreateWithoutOwnerInput[] | OwnerVehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutOwnerInput | OwnerVehicleCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerVehicleUpsertWithWhereUniqueWithoutOwnerInput | OwnerVehicleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerVehicleCreateManyOwnerInputEnvelope
    set?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    disconnect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    delete?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    update?: OwnerVehicleUpdateWithWhereUniqueWithoutOwnerInput | OwnerVehicleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerVehicleUpdateManyWithWhereWithoutOwnerInput | OwnerVehicleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerVehicleScalarWhereInput | OwnerVehicleScalarWhereInput[]
  }

  export type OwnerWalletUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<OwnerWalletCreateWithoutOwnerInput, OwnerWalletUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OwnerWalletCreateOrConnectWithoutOwnerInput
    upsert?: OwnerWalletUpsertWithoutOwnerInput
    disconnect?: OwnerWalletWhereInput | boolean
    delete?: OwnerWalletWhereInput | boolean
    connect?: OwnerWalletWhereUniqueInput
    update?: XOR<XOR<OwnerWalletUpdateToOneWithWhereWithoutOwnerInput, OwnerWalletUpdateWithoutOwnerInput>, OwnerWalletUncheckedUpdateWithoutOwnerInput>
  }

  export type FareNegotiationUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<FareNegotiationCreateWithoutOwnerInput, FareNegotiationUncheckedCreateWithoutOwnerInput> | FareNegotiationCreateWithoutOwnerInput[] | FareNegotiationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FareNegotiationCreateOrConnectWithoutOwnerInput | FareNegotiationCreateOrConnectWithoutOwnerInput[]
    upsert?: FareNegotiationUpsertWithWhereUniqueWithoutOwnerInput | FareNegotiationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: FareNegotiationCreateManyOwnerInputEnvelope
    set?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    disconnect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    delete?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    connect?: FareNegotiationWhereUniqueInput | FareNegotiationWhereUniqueInput[]
    update?: FareNegotiationUpdateWithWhereUniqueWithoutOwnerInput | FareNegotiationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: FareNegotiationUpdateManyWithWhereWithoutOwnerInput | FareNegotiationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
  }

  export type OwnerDriverUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerDriverCreateWithoutOwnerInput, OwnerDriverUncheckedCreateWithoutOwnerInput> | OwnerDriverCreateWithoutOwnerInput[] | OwnerDriverUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDriverCreateOrConnectWithoutOwnerInput | OwnerDriverCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerDriverUpsertWithWhereUniqueWithoutOwnerInput | OwnerDriverUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerDriverCreateManyOwnerInputEnvelope
    set?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    disconnect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    delete?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    connect?: OwnerDriverWhereUniqueInput | OwnerDriverWhereUniqueInput[]
    update?: OwnerDriverUpdateWithWhereUniqueWithoutOwnerInput | OwnerDriverUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerDriverUpdateManyWithWhereWithoutOwnerInput | OwnerDriverUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerDriverScalarWhereInput | OwnerDriverScalarWhereInput[]
  }

  export type OwnerVehicleUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerVehicleCreateWithoutOwnerInput, OwnerVehicleUncheckedCreateWithoutOwnerInput> | OwnerVehicleCreateWithoutOwnerInput[] | OwnerVehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutOwnerInput | OwnerVehicleCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerVehicleUpsertWithWhereUniqueWithoutOwnerInput | OwnerVehicleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerVehicleCreateManyOwnerInputEnvelope
    set?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    disconnect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    delete?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    update?: OwnerVehicleUpdateWithWhereUniqueWithoutOwnerInput | OwnerVehicleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerVehicleUpdateManyWithWhereWithoutOwnerInput | OwnerVehicleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerVehicleScalarWhereInput | OwnerVehicleScalarWhereInput[]
  }

  export type OwnerWalletUncheckedUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<OwnerWalletCreateWithoutOwnerInput, OwnerWalletUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OwnerWalletCreateOrConnectWithoutOwnerInput
    upsert?: OwnerWalletUpsertWithoutOwnerInput
    disconnect?: OwnerWalletWhereInput | boolean
    delete?: OwnerWalletWhereInput | boolean
    connect?: OwnerWalletWhereUniqueInput
    update?: XOR<XOR<OwnerWalletUpdateToOneWithWhereWithoutOwnerInput, OwnerWalletUpdateWithoutOwnerInput>, OwnerWalletUncheckedUpdateWithoutOwnerInput>
  }

  export type DriverCreateNestedOneWithoutOwnerDriverInput = {
    create?: XOR<DriverCreateWithoutOwnerDriverInput, DriverUncheckedCreateWithoutOwnerDriverInput>
    connectOrCreate?: DriverCreateOrConnectWithoutOwnerDriverInput
    connect?: DriverWhereUniqueInput
  }

  export type OwnerCreateNestedOneWithoutOwnerDriverInput = {
    create?: XOR<OwnerCreateWithoutOwnerDriverInput, OwnerUncheckedCreateWithoutOwnerDriverInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerDriverInput
    connect?: OwnerWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutOwnerDriverNestedInput = {
    create?: XOR<DriverCreateWithoutOwnerDriverInput, DriverUncheckedCreateWithoutOwnerDriverInput>
    connectOrCreate?: DriverCreateOrConnectWithoutOwnerDriverInput
    upsert?: DriverUpsertWithoutOwnerDriverInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutOwnerDriverInput, DriverUpdateWithoutOwnerDriverInput>, DriverUncheckedUpdateWithoutOwnerDriverInput>
  }

  export type OwnerUpdateOneRequiredWithoutOwnerDriverNestedInput = {
    create?: XOR<OwnerCreateWithoutOwnerDriverInput, OwnerUncheckedCreateWithoutOwnerDriverInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerDriverInput
    upsert?: OwnerUpsertWithoutOwnerDriverInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutOwnerDriverInput, OwnerUpdateWithoutOwnerDriverInput>, OwnerUncheckedUpdateWithoutOwnerDriverInput>
  }

  export type OwnerCreateNestedOneWithoutOwnerVehicleInput = {
    create?: XOR<OwnerCreateWithoutOwnerVehicleInput, OwnerUncheckedCreateWithoutOwnerVehicleInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerVehicleInput
    connect?: OwnerWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutOwnerVehicleInput = {
    create?: XOR<VehicleCreateWithoutOwnerVehicleInput, VehicleUncheckedCreateWithoutOwnerVehicleInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutOwnerVehicleInput
    connect?: VehicleWhereUniqueInput
  }

  export type OwnerUpdateOneRequiredWithoutOwnerVehicleNestedInput = {
    create?: XOR<OwnerCreateWithoutOwnerVehicleInput, OwnerUncheckedCreateWithoutOwnerVehicleInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerVehicleInput
    upsert?: OwnerUpsertWithoutOwnerVehicleInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutOwnerVehicleInput, OwnerUpdateWithoutOwnerVehicleInput>, OwnerUncheckedUpdateWithoutOwnerVehicleInput>
  }

  export type VehicleUpdateOneRequiredWithoutOwnerVehicleNestedInput = {
    create?: XOR<VehicleCreateWithoutOwnerVehicleInput, VehicleUncheckedCreateWithoutOwnerVehicleInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutOwnerVehicleInput
    upsert?: VehicleUpsertWithoutOwnerVehicleInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutOwnerVehicleInput, VehicleUpdateWithoutOwnerVehicleInput>, VehicleUncheckedUpdateWithoutOwnerVehicleInput>
  }

  export type OwnerCreateNestedOneWithoutOwnerWalletInput = {
    create?: XOR<OwnerCreateWithoutOwnerWalletInput, OwnerUncheckedCreateWithoutOwnerWalletInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerWalletInput
    connect?: OwnerWhereUniqueInput
  }

  export type OwnerUpdateOneRequiredWithoutOwnerWalletNestedInput = {
    create?: XOR<OwnerCreateWithoutOwnerWalletInput, OwnerUncheckedCreateWithoutOwnerWalletInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutOwnerWalletInput
    upsert?: OwnerUpsertWithoutOwnerWalletInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutOwnerWalletInput, OwnerUpdateWithoutOwnerWalletInput>, OwnerUncheckedUpdateWithoutOwnerWalletInput>
  }

  export type BookingsCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingsCreateWithoutUserInput, BookingsUncheckedCreateWithoutUserInput> | BookingsCreateWithoutUserInput[] | BookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUserInput | BookingsCreateOrConnectWithoutUserInput[]
    createMany?: BookingsCreateManyUserInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type UserWalletCreateNestedOneWithoutUserInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput
    connect?: UserWalletWhereUniqueInput
  }

  export type BookingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingsCreateWithoutUserInput, BookingsUncheckedCreateWithoutUserInput> | BookingsCreateWithoutUserInput[] | BookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUserInput | BookingsCreateOrConnectWithoutUserInput[]
    createMany?: BookingsCreateManyUserInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type UserWalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput
    connect?: UserWalletWhereUniqueInput
  }

  export type BookingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingsCreateWithoutUserInput, BookingsUncheckedCreateWithoutUserInput> | BookingsCreateWithoutUserInput[] | BookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUserInput | BookingsCreateOrConnectWithoutUserInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutUserInput | BookingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingsCreateManyUserInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutUserInput | BookingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutUserInput | BookingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type UserWalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput
    upsert?: UserWalletUpsertWithoutUserInput
    disconnect?: UserWalletWhereInput | boolean
    delete?: UserWalletWhereInput | boolean
    connect?: UserWalletWhereUniqueInput
    update?: XOR<XOR<UserWalletUpdateToOneWithWhereWithoutUserInput, UserWalletUpdateWithoutUserInput>, UserWalletUncheckedUpdateWithoutUserInput>
  }

  export type BookingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingsCreateWithoutUserInput, BookingsUncheckedCreateWithoutUserInput> | BookingsCreateWithoutUserInput[] | BookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUserInput | BookingsCreateOrConnectWithoutUserInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutUserInput | BookingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingsCreateManyUserInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutUserInput | BookingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutUserInput | BookingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type UserWalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserWalletCreateOrConnectWithoutUserInput
    upsert?: UserWalletUpsertWithoutUserInput
    disconnect?: UserWalletWhereInput | boolean
    delete?: UserWalletWhereInput | boolean
    connect?: UserWalletWhereUniqueInput
    update?: XOR<XOR<UserWalletUpdateToOneWithWhereWithoutUserInput, UserWalletUpdateWithoutUserInput>, UserWalletUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUserWalletInput = {
    create?: XOR<UserCreateWithoutUserWalletInput, UserUncheckedCreateWithoutUserWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserWalletInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserWalletNestedInput = {
    create?: XOR<UserCreateWithoutUserWalletInput, UserUncheckedCreateWithoutUserWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserWalletInput
    upsert?: UserUpsertWithoutUserWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserWalletInput, UserUpdateWithoutUserWalletInput>, UserUncheckedUpdateWithoutUserWalletInput>
  }

  export type BookingsCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingsCreateWithoutVehicleInput, BookingsUncheckedCreateWithoutVehicleInput> | BookingsCreateWithoutVehicleInput[] | BookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutVehicleInput | BookingsCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingsCreateManyVehicleInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type DriverVehicleCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DriverVehicleCreateWithoutVehicleInput, DriverVehicleUncheckedCreateWithoutVehicleInput> | DriverVehicleCreateWithoutVehicleInput[] | DriverVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutVehicleInput | DriverVehicleCreateOrConnectWithoutVehicleInput[]
    createMany?: DriverVehicleCreateManyVehicleInputEnvelope
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
  }

  export type OwnerVehicleCreateNestedManyWithoutVehicleInput = {
    create?: XOR<OwnerVehicleCreateWithoutVehicleInput, OwnerVehicleUncheckedCreateWithoutVehicleInput> | OwnerVehicleCreateWithoutVehicleInput[] | OwnerVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutVehicleInput | OwnerVehicleCreateOrConnectWithoutVehicleInput[]
    createMany?: OwnerVehicleCreateManyVehicleInputEnvelope
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
  }

  export type BookingsUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingsCreateWithoutVehicleInput, BookingsUncheckedCreateWithoutVehicleInput> | BookingsCreateWithoutVehicleInput[] | BookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutVehicleInput | BookingsCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingsCreateManyVehicleInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type DriverVehicleUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DriverVehicleCreateWithoutVehicleInput, DriverVehicleUncheckedCreateWithoutVehicleInput> | DriverVehicleCreateWithoutVehicleInput[] | DriverVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutVehicleInput | DriverVehicleCreateOrConnectWithoutVehicleInput[]
    createMany?: DriverVehicleCreateManyVehicleInputEnvelope
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
  }

  export type OwnerVehicleUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<OwnerVehicleCreateWithoutVehicleInput, OwnerVehicleUncheckedCreateWithoutVehicleInput> | OwnerVehicleCreateWithoutVehicleInput[] | OwnerVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutVehicleInput | OwnerVehicleCreateOrConnectWithoutVehicleInput[]
    createMany?: OwnerVehicleCreateManyVehicleInputEnvelope
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
  }

  export type BookingsUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingsCreateWithoutVehicleInput, BookingsUncheckedCreateWithoutVehicleInput> | BookingsCreateWithoutVehicleInput[] | BookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutVehicleInput | BookingsCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutVehicleInput | BookingsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingsCreateManyVehicleInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutVehicleInput | BookingsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutVehicleInput | BookingsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type DriverVehicleUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DriverVehicleCreateWithoutVehicleInput, DriverVehicleUncheckedCreateWithoutVehicleInput> | DriverVehicleCreateWithoutVehicleInput[] | DriverVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutVehicleInput | DriverVehicleCreateOrConnectWithoutVehicleInput[]
    upsert?: DriverVehicleUpsertWithWhereUniqueWithoutVehicleInput | DriverVehicleUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DriverVehicleCreateManyVehicleInputEnvelope
    set?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    disconnect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    delete?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    update?: DriverVehicleUpdateWithWhereUniqueWithoutVehicleInput | DriverVehicleUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DriverVehicleUpdateManyWithWhereWithoutVehicleInput | DriverVehicleUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DriverVehicleScalarWhereInput | DriverVehicleScalarWhereInput[]
  }

  export type OwnerVehicleUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<OwnerVehicleCreateWithoutVehicleInput, OwnerVehicleUncheckedCreateWithoutVehicleInput> | OwnerVehicleCreateWithoutVehicleInput[] | OwnerVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutVehicleInput | OwnerVehicleCreateOrConnectWithoutVehicleInput[]
    upsert?: OwnerVehicleUpsertWithWhereUniqueWithoutVehicleInput | OwnerVehicleUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: OwnerVehicleCreateManyVehicleInputEnvelope
    set?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    disconnect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    delete?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    update?: OwnerVehicleUpdateWithWhereUniqueWithoutVehicleInput | OwnerVehicleUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: OwnerVehicleUpdateManyWithWhereWithoutVehicleInput | OwnerVehicleUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: OwnerVehicleScalarWhereInput | OwnerVehicleScalarWhereInput[]
  }

  export type BookingsUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingsCreateWithoutVehicleInput, BookingsUncheckedCreateWithoutVehicleInput> | BookingsCreateWithoutVehicleInput[] | BookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutVehicleInput | BookingsCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutVehicleInput | BookingsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingsCreateManyVehicleInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutVehicleInput | BookingsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutVehicleInput | BookingsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type DriverVehicleUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DriverVehicleCreateWithoutVehicleInput, DriverVehicleUncheckedCreateWithoutVehicleInput> | DriverVehicleCreateWithoutVehicleInput[] | DriverVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleCreateOrConnectWithoutVehicleInput | DriverVehicleCreateOrConnectWithoutVehicleInput[]
    upsert?: DriverVehicleUpsertWithWhereUniqueWithoutVehicleInput | DriverVehicleUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DriverVehicleCreateManyVehicleInputEnvelope
    set?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    disconnect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    delete?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    connect?: DriverVehicleWhereUniqueInput | DriverVehicleWhereUniqueInput[]
    update?: DriverVehicleUpdateWithWhereUniqueWithoutVehicleInput | DriverVehicleUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DriverVehicleUpdateManyWithWhereWithoutVehicleInput | DriverVehicleUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DriverVehicleScalarWhereInput | DriverVehicleScalarWhereInput[]
  }

  export type OwnerVehicleUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<OwnerVehicleCreateWithoutVehicleInput, OwnerVehicleUncheckedCreateWithoutVehicleInput> | OwnerVehicleCreateWithoutVehicleInput[] | OwnerVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: OwnerVehicleCreateOrConnectWithoutVehicleInput | OwnerVehicleCreateOrConnectWithoutVehicleInput[]
    upsert?: OwnerVehicleUpsertWithWhereUniqueWithoutVehicleInput | OwnerVehicleUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: OwnerVehicleCreateManyVehicleInputEnvelope
    set?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    disconnect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    delete?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    connect?: OwnerVehicleWhereUniqueInput | OwnerVehicleWhereUniqueInput[]
    update?: OwnerVehicleUpdateWithWhereUniqueWithoutVehicleInput | OwnerVehicleUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: OwnerVehicleUpdateManyWithWhereWithoutVehicleInput | OwnerVehicleUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: OwnerVehicleScalarWhereInput | OwnerVehicleScalarWhereInput[]
  }

  export type permission_audit_logsCreateNestedManyWithoutAdminInput = {
    create?: XOR<permission_audit_logsCreateWithoutAdminInput, permission_audit_logsUncheckedCreateWithoutAdminInput> | permission_audit_logsCreateWithoutAdminInput[] | permission_audit_logsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutAdminInput | permission_audit_logsCreateOrConnectWithoutAdminInput[]
    createMany?: permission_audit_logsCreateManyAdminInputEnvelope
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
  }

  export type rolesCreateNestedManyWithoutAdminInput = {
    create?: XOR<rolesCreateWithoutAdminInput, rolesUncheckedCreateWithoutAdminInput> | rolesCreateWithoutAdminInput[] | rolesUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: rolesCreateOrConnectWithoutAdminInput | rolesCreateOrConnectWithoutAdminInput[]
    createMany?: rolesCreateManyAdminInputEnvelope
    connect?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
  }

  export type user_rolesCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_adminIdToadminInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type permission_audit_logsUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<permission_audit_logsCreateWithoutAdminInput, permission_audit_logsUncheckedCreateWithoutAdminInput> | permission_audit_logsCreateWithoutAdminInput[] | permission_audit_logsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutAdminInput | permission_audit_logsCreateOrConnectWithoutAdminInput[]
    createMany?: permission_audit_logsCreateManyAdminInputEnvelope
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
  }

  export type rolesUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<rolesCreateWithoutAdminInput, rolesUncheckedCreateWithoutAdminInput> | rolesCreateWithoutAdminInput[] | rolesUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: rolesCreateOrConnectWithoutAdminInput | rolesCreateOrConnectWithoutAdminInput[]
    createMany?: rolesCreateManyAdminInputEnvelope
    connect?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_adminIdToadminInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type permission_audit_logsUpdateManyWithoutAdminNestedInput = {
    create?: XOR<permission_audit_logsCreateWithoutAdminInput, permission_audit_logsUncheckedCreateWithoutAdminInput> | permission_audit_logsCreateWithoutAdminInput[] | permission_audit_logsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutAdminInput | permission_audit_logsCreateOrConnectWithoutAdminInput[]
    upsert?: permission_audit_logsUpsertWithWhereUniqueWithoutAdminInput | permission_audit_logsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: permission_audit_logsCreateManyAdminInputEnvelope
    set?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    disconnect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    delete?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    update?: permission_audit_logsUpdateWithWhereUniqueWithoutAdminInput | permission_audit_logsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: permission_audit_logsUpdateManyWithWhereWithoutAdminInput | permission_audit_logsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
  }

  export type rolesUpdateManyWithoutAdminNestedInput = {
    create?: XOR<rolesCreateWithoutAdminInput, rolesUncheckedCreateWithoutAdminInput> | rolesCreateWithoutAdminInput[] | rolesUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: rolesCreateOrConnectWithoutAdminInput | rolesCreateOrConnectWithoutAdminInput[]
    upsert?: rolesUpsertWithWhereUniqueWithoutAdminInput | rolesUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: rolesCreateManyAdminInputEnvelope
    set?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    disconnect?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    delete?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    connect?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    update?: rolesUpdateWithWhereUniqueWithoutAdminInput | rolesUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: rolesUpdateManyWithWhereWithoutAdminInput | rolesUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: rolesScalarWhereInput | rolesScalarWhereInput[]
  }

  export type user_rolesUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput | user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_adminIdToadminInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput | user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_adminIdToadminInput | user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_adminIdToadminInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type user_rolesUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_assignedByIdToadminInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type permission_audit_logsUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<permission_audit_logsCreateWithoutAdminInput, permission_audit_logsUncheckedCreateWithoutAdminInput> | permission_audit_logsCreateWithoutAdminInput[] | permission_audit_logsUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutAdminInput | permission_audit_logsCreateOrConnectWithoutAdminInput[]
    upsert?: permission_audit_logsUpsertWithWhereUniqueWithoutAdminInput | permission_audit_logsUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: permission_audit_logsCreateManyAdminInputEnvelope
    set?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    disconnect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    delete?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    update?: permission_audit_logsUpdateWithWhereUniqueWithoutAdminInput | permission_audit_logsUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: permission_audit_logsUpdateManyWithWhereWithoutAdminInput | permission_audit_logsUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
  }

  export type rolesUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<rolesCreateWithoutAdminInput, rolesUncheckedCreateWithoutAdminInput> | rolesCreateWithoutAdminInput[] | rolesUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: rolesCreateOrConnectWithoutAdminInput | rolesCreateOrConnectWithoutAdminInput[]
    upsert?: rolesUpsertWithWhereUniqueWithoutAdminInput | rolesUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: rolesCreateManyAdminInputEnvelope
    set?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    disconnect?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    delete?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    connect?: rolesWhereUniqueInput | rolesWhereUniqueInput[]
    update?: rolesUpdateWithWhereUniqueWithoutAdminInput | rolesUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: rolesUpdateManyWithWhereWithoutAdminInput | rolesUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: rolesScalarWhereInput | rolesScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput | user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_adminIdToadminInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput | user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_adminIdToadminInput | user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_adminIdToadminInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput = {
    create?: XOR<user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput> | user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput[] | user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput[]
    createMany?: user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_assignedByIdToadminInput | user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_assignedByIdToadminInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type adminCreateNestedOneWithoutPermission_audit_logsInput = {
    create?: XOR<adminCreateWithoutPermission_audit_logsInput, adminUncheckedCreateWithoutPermission_audit_logsInput>
    connectOrCreate?: adminCreateOrConnectWithoutPermission_audit_logsInput
    connect?: adminWhereUniqueInput
  }

  export type permissionsCreateNestedOneWithoutPermission_audit_logsInput = {
    create?: XOR<permissionsCreateWithoutPermission_audit_logsInput, permissionsUncheckedCreateWithoutPermission_audit_logsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutPermission_audit_logsInput
    connect?: permissionsWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutPermission_audit_logsInput = {
    create?: XOR<rolesCreateWithoutPermission_audit_logsInput, rolesUncheckedCreateWithoutPermission_audit_logsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutPermission_audit_logsInput
    connect?: rolesWhereUniqueInput
  }

  export type EnumAuditActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditActionType
  }

  export type adminUpdateOneRequiredWithoutPermission_audit_logsNestedInput = {
    create?: XOR<adminCreateWithoutPermission_audit_logsInput, adminUncheckedCreateWithoutPermission_audit_logsInput>
    connectOrCreate?: adminCreateOrConnectWithoutPermission_audit_logsInput
    upsert?: adminUpsertWithoutPermission_audit_logsInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutPermission_audit_logsInput, adminUpdateWithoutPermission_audit_logsInput>, adminUncheckedUpdateWithoutPermission_audit_logsInput>
  }

  export type permissionsUpdateOneWithoutPermission_audit_logsNestedInput = {
    create?: XOR<permissionsCreateWithoutPermission_audit_logsInput, permissionsUncheckedCreateWithoutPermission_audit_logsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutPermission_audit_logsInput
    upsert?: permissionsUpsertWithoutPermission_audit_logsInput
    disconnect?: permissionsWhereInput | boolean
    delete?: permissionsWhereInput | boolean
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutPermission_audit_logsInput, permissionsUpdateWithoutPermission_audit_logsInput>, permissionsUncheckedUpdateWithoutPermission_audit_logsInput>
  }

  export type rolesUpdateOneWithoutPermission_audit_logsNestedInput = {
    create?: XOR<rolesCreateWithoutPermission_audit_logsInput, rolesUncheckedCreateWithoutPermission_audit_logsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutPermission_audit_logsInput
    upsert?: rolesUpsertWithoutPermission_audit_logsInput
    disconnect?: rolesWhereInput | boolean
    delete?: rolesWhereInput | boolean
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutPermission_audit_logsInput, rolesUpdateWithoutPermission_audit_logsInput>, rolesUncheckedUpdateWithoutPermission_audit_logsInput>
  }

  export type permissionsCreateNestedManyWithoutPermission_categoriesInput = {
    create?: XOR<permissionsCreateWithoutPermission_categoriesInput, permissionsUncheckedCreateWithoutPermission_categoriesInput> | permissionsCreateWithoutPermission_categoriesInput[] | permissionsUncheckedCreateWithoutPermission_categoriesInput[]
    connectOrCreate?: permissionsCreateOrConnectWithoutPermission_categoriesInput | permissionsCreateOrConnectWithoutPermission_categoriesInput[]
    createMany?: permissionsCreateManyPermission_categoriesInputEnvelope
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
  }

  export type permissionsUncheckedCreateNestedManyWithoutPermission_categoriesInput = {
    create?: XOR<permissionsCreateWithoutPermission_categoriesInput, permissionsUncheckedCreateWithoutPermission_categoriesInput> | permissionsCreateWithoutPermission_categoriesInput[] | permissionsUncheckedCreateWithoutPermission_categoriesInput[]
    connectOrCreate?: permissionsCreateOrConnectWithoutPermission_categoriesInput | permissionsCreateOrConnectWithoutPermission_categoriesInput[]
    createMany?: permissionsCreateManyPermission_categoriesInputEnvelope
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
  }

  export type permissionsUpdateManyWithoutPermission_categoriesNestedInput = {
    create?: XOR<permissionsCreateWithoutPermission_categoriesInput, permissionsUncheckedCreateWithoutPermission_categoriesInput> | permissionsCreateWithoutPermission_categoriesInput[] | permissionsUncheckedCreateWithoutPermission_categoriesInput[]
    connectOrCreate?: permissionsCreateOrConnectWithoutPermission_categoriesInput | permissionsCreateOrConnectWithoutPermission_categoriesInput[]
    upsert?: permissionsUpsertWithWhereUniqueWithoutPermission_categoriesInput | permissionsUpsertWithWhereUniqueWithoutPermission_categoriesInput[]
    createMany?: permissionsCreateManyPermission_categoriesInputEnvelope
    set?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    disconnect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    delete?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    update?: permissionsUpdateWithWhereUniqueWithoutPermission_categoriesInput | permissionsUpdateWithWhereUniqueWithoutPermission_categoriesInput[]
    updateMany?: permissionsUpdateManyWithWhereWithoutPermission_categoriesInput | permissionsUpdateManyWithWhereWithoutPermission_categoriesInput[]
    deleteMany?: permissionsScalarWhereInput | permissionsScalarWhereInput[]
  }

  export type permissionsUncheckedUpdateManyWithoutPermission_categoriesNestedInput = {
    create?: XOR<permissionsCreateWithoutPermission_categoriesInput, permissionsUncheckedCreateWithoutPermission_categoriesInput> | permissionsCreateWithoutPermission_categoriesInput[] | permissionsUncheckedCreateWithoutPermission_categoriesInput[]
    connectOrCreate?: permissionsCreateOrConnectWithoutPermission_categoriesInput | permissionsCreateOrConnectWithoutPermission_categoriesInput[]
    upsert?: permissionsUpsertWithWhereUniqueWithoutPermission_categoriesInput | permissionsUpsertWithWhereUniqueWithoutPermission_categoriesInput[]
    createMany?: permissionsCreateManyPermission_categoriesInputEnvelope
    set?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    disconnect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    delete?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    connect?: permissionsWhereUniqueInput | permissionsWhereUniqueInput[]
    update?: permissionsUpdateWithWhereUniqueWithoutPermission_categoriesInput | permissionsUpdateWithWhereUniqueWithoutPermission_categoriesInput[]
    updateMany?: permissionsUpdateManyWithWhereWithoutPermission_categoriesInput | permissionsUpdateManyWithWhereWithoutPermission_categoriesInput[]
    deleteMany?: permissionsScalarWhereInput | permissionsScalarWhereInput[]
  }

  export type permission_audit_logsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<permission_audit_logsCreateWithoutPermissionsInput, permission_audit_logsUncheckedCreateWithoutPermissionsInput> | permission_audit_logsCreateWithoutPermissionsInput[] | permission_audit_logsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutPermissionsInput | permission_audit_logsCreateOrConnectWithoutPermissionsInput[]
    createMany?: permission_audit_logsCreateManyPermissionsInputEnvelope
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
  }

  export type permission_categoriesCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<permission_categoriesCreateWithoutPermissionsInput, permission_categoriesUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: permission_categoriesCreateOrConnectWithoutPermissionsInput
    connect?: permission_categoriesWhereUniqueInput
  }

  export type role_permissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type permission_audit_logsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<permission_audit_logsCreateWithoutPermissionsInput, permission_audit_logsUncheckedCreateWithoutPermissionsInput> | permission_audit_logsCreateWithoutPermissionsInput[] | permission_audit_logsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutPermissionsInput | permission_audit_logsCreateOrConnectWithoutPermissionsInput[]
    createMany?: permission_audit_logsCreateManyPermissionsInputEnvelope
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
  }

  export type role_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type permission_audit_logsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<permission_audit_logsCreateWithoutPermissionsInput, permission_audit_logsUncheckedCreateWithoutPermissionsInput> | permission_audit_logsCreateWithoutPermissionsInput[] | permission_audit_logsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutPermissionsInput | permission_audit_logsCreateOrConnectWithoutPermissionsInput[]
    upsert?: permission_audit_logsUpsertWithWhereUniqueWithoutPermissionsInput | permission_audit_logsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: permission_audit_logsCreateManyPermissionsInputEnvelope
    set?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    disconnect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    delete?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    update?: permission_audit_logsUpdateWithWhereUniqueWithoutPermissionsInput | permission_audit_logsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: permission_audit_logsUpdateManyWithWhereWithoutPermissionsInput | permission_audit_logsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
  }

  export type permission_categoriesUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<permission_categoriesCreateWithoutPermissionsInput, permission_categoriesUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: permission_categoriesCreateOrConnectWithoutPermissionsInput
    upsert?: permission_categoriesUpsertWithoutPermissionsInput
    connect?: permission_categoriesWhereUniqueInput
    update?: XOR<XOR<permission_categoriesUpdateToOneWithWhereWithoutPermissionsInput, permission_categoriesUpdateWithoutPermissionsInput>, permission_categoriesUncheckedUpdateWithoutPermissionsInput>
  }

  export type role_permissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type permission_audit_logsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<permission_audit_logsCreateWithoutPermissionsInput, permission_audit_logsUncheckedCreateWithoutPermissionsInput> | permission_audit_logsCreateWithoutPermissionsInput[] | permission_audit_logsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutPermissionsInput | permission_audit_logsCreateOrConnectWithoutPermissionsInput[]
    upsert?: permission_audit_logsUpsertWithWhereUniqueWithoutPermissionsInput | permission_audit_logsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: permission_audit_logsCreateManyPermissionsInputEnvelope
    set?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    disconnect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    delete?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    update?: permission_audit_logsUpdateWithWhereUniqueWithoutPermissionsInput | permission_audit_logsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: permission_audit_logsUpdateManyWithWhereWithoutPermissionsInput | permission_audit_logsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
  }

  export type role_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput> | role_permissionsCreateWithoutPermissionsInput[] | role_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutPermissionsInput | role_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_permissionsCreateManyPermissionsInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type permissionsCreateNestedOneWithoutRole_permissionsInput = {
    create?: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_permissionsInput
    connect?: permissionsWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutRole_permissionsInput = {
    create?: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_permissionsInput
    connect?: rolesWhereUniqueInput
  }

  export type permissionsUpdateOneRequiredWithoutRole_permissionsNestedInput = {
    create?: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_permissionsInput
    upsert?: permissionsUpsertWithoutRole_permissionsInput
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutRole_permissionsInput, permissionsUpdateWithoutRole_permissionsInput>, permissionsUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type rolesUpdateOneRequiredWithoutRole_permissionsNestedInput = {
    create?: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_permissionsInput
    upsert?: rolesUpsertWithoutRole_permissionsInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutRole_permissionsInput, rolesUpdateWithoutRole_permissionsInput>, rolesUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type permission_audit_logsCreateNestedManyWithoutRolesInput = {
    create?: XOR<permission_audit_logsCreateWithoutRolesInput, permission_audit_logsUncheckedCreateWithoutRolesInput> | permission_audit_logsCreateWithoutRolesInput[] | permission_audit_logsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutRolesInput | permission_audit_logsCreateOrConnectWithoutRolesInput[]
    createMany?: permission_audit_logsCreateManyRolesInputEnvelope
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
  }

  export type role_permissionsCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type adminCreateNestedOneWithoutRolesInput = {
    create?: XOR<adminCreateWithoutRolesInput, adminUncheckedCreateWithoutRolesInput>
    connectOrCreate?: adminCreateOrConnectWithoutRolesInput
    connect?: adminWhereUniqueInput
  }

  export type user_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type permission_audit_logsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<permission_audit_logsCreateWithoutRolesInput, permission_audit_logsUncheckedCreateWithoutRolesInput> | permission_audit_logsCreateWithoutRolesInput[] | permission_audit_logsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutRolesInput | permission_audit_logsCreateOrConnectWithoutRolesInput[]
    createMany?: permission_audit_logsCreateManyRolesInputEnvelope
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
  }

  export type role_permissionsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type permission_audit_logsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<permission_audit_logsCreateWithoutRolesInput, permission_audit_logsUncheckedCreateWithoutRolesInput> | permission_audit_logsCreateWithoutRolesInput[] | permission_audit_logsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutRolesInput | permission_audit_logsCreateOrConnectWithoutRolesInput[]
    upsert?: permission_audit_logsUpsertWithWhereUniqueWithoutRolesInput | permission_audit_logsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: permission_audit_logsCreateManyRolesInputEnvelope
    set?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    disconnect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    delete?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    update?: permission_audit_logsUpdateWithWhereUniqueWithoutRolesInput | permission_audit_logsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: permission_audit_logsUpdateManyWithWhereWithoutRolesInput | permission_audit_logsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
  }

  export type role_permissionsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutRolesInput | role_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type adminUpdateOneWithoutRolesNestedInput = {
    create?: XOR<adminCreateWithoutRolesInput, adminUncheckedCreateWithoutRolesInput>
    connectOrCreate?: adminCreateOrConnectWithoutRolesInput
    upsert?: adminUpsertWithoutRolesInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutRolesInput, adminUpdateWithoutRolesInput>, adminUncheckedUpdateWithoutRolesInput>
  }

  export type user_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type permission_audit_logsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<permission_audit_logsCreateWithoutRolesInput, permission_audit_logsUncheckedCreateWithoutRolesInput> | permission_audit_logsCreateWithoutRolesInput[] | permission_audit_logsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: permission_audit_logsCreateOrConnectWithoutRolesInput | permission_audit_logsCreateOrConnectWithoutRolesInput[]
    upsert?: permission_audit_logsUpsertWithWhereUniqueWithoutRolesInput | permission_audit_logsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: permission_audit_logsCreateManyRolesInputEnvelope
    set?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    disconnect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    delete?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    connect?: permission_audit_logsWhereUniqueInput | permission_audit_logsWhereUniqueInput[]
    update?: permission_audit_logsUpdateWithWhereUniqueWithoutRolesInput | permission_audit_logsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: permission_audit_logsUpdateManyWithWhereWithoutRolesInput | permission_audit_logsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
  }

  export type role_permissionsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutRolesInput | role_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type adminCreateNestedOneWithoutUser_roles_user_roles_adminIdToadminInput = {
    create?: XOR<adminCreateWithoutUser_roles_user_roles_adminIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_adminIdToadminInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_roles_user_roles_adminIdToadminInput
    connect?: adminWhereUniqueInput
  }

  export type adminCreateNestedOneWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    create?: XOR<adminCreateWithoutUser_roles_user_roles_assignedByIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_assignedByIdToadminInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_roles_user_roles_assignedByIdToadminInput
    connect?: adminWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type adminUpdateOneRequiredWithoutUser_roles_user_roles_adminIdToadminNestedInput = {
    create?: XOR<adminCreateWithoutUser_roles_user_roles_adminIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_adminIdToadminInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_roles_user_roles_adminIdToadminInput
    upsert?: adminUpsertWithoutUser_roles_user_roles_adminIdToadminInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUser_roles_user_roles_adminIdToadminInput, adminUpdateWithoutUser_roles_user_roles_adminIdToadminInput>, adminUncheckedUpdateWithoutUser_roles_user_roles_adminIdToadminInput>
  }

  export type adminUpdateOneWithoutUser_roles_user_roles_assignedByIdToadminNestedInput = {
    create?: XOR<adminCreateWithoutUser_roles_user_roles_assignedByIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_assignedByIdToadminInput>
    connectOrCreate?: adminCreateOrConnectWithoutUser_roles_user_roles_assignedByIdToadminInput
    upsert?: adminUpsertWithoutUser_roles_user_roles_assignedByIdToadminInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUser_roles_user_roles_assignedByIdToadminInput, adminUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput>, adminUncheckedUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput>
  }

  export type rolesUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    upsert?: rolesUpsertWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUser_rolesInput, rolesUpdateWithoutUser_rolesInput>, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditActionType | EnumAuditActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionTypeFilter<$PrismaModel> | $Enums.AuditActionType
  }

  export type NestedEnumAuditActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditActionType | EnumAuditActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditActionType[] | ListEnumAuditActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditActionTypeFilter<$PrismaModel>
  }

  export type DriverCreateWithoutBookingsInput = {
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutBookingsInput = {
    Id?: number
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletUncheckedCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutBookingsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    MobileNumber: string
    CreatedDate?: Date | string
    LastLoggedIn?: Date | string
    Gender: $Enums.Gender
    Name: string
    UserWallet?: UserWalletCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    Id?: number
    MobileNumber: string
    CreatedDate?: Date | string
    LastLoggedIn?: Date | string
    Gender: $Enums.Gender
    Name: string
    UserWallet?: UserWalletUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type VehicleCreateWithoutBookingsInput = {
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutVehicleInput
    OwnerVehicle?: OwnerVehicleCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutBookingsInput = {
    Id?: number
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutVehicleInput
    OwnerVehicle?: OwnerVehicleUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutBookingsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
  }

  export type FareNegotiationCreateWithoutBookingsInput = {
    NegotiatedFare: string
    NegotiatedTime?: Date | string
    Driver: DriverCreateNestedOneWithoutFareNegotiationInput
    Owner: OwnerCreateNestedOneWithoutFareNegotiationInput
  }

  export type FareNegotiationUncheckedCreateWithoutBookingsInput = {
    Id?: number
    DriverId: number
    OwnerId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type FareNegotiationCreateOrConnectWithoutBookingsInput = {
    where: FareNegotiationWhereUniqueInput
    create: XOR<FareNegotiationCreateWithoutBookingsInput, FareNegotiationUncheckedCreateWithoutBookingsInput>
  }

  export type FareNegotiationCreateManyBookingsInputEnvelope = {
    data: FareNegotiationCreateManyBookingsInput | FareNegotiationCreateManyBookingsInput[]
    skipDuplicates?: boolean
  }

  export type DriverUpsertWithoutBookingsInput = {
    update: XOR<DriverUpdateWithoutBookingsInput, DriverUncheckedUpdateWithoutBookingsInput>
    create: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutBookingsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutBookingsInput, DriverUncheckedUpdateWithoutBookingsInput>
  }

  export type DriverUpdateWithoutBookingsInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    DriverVehicle?: DriverVehicleUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutBookingsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUncheckedUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
    UserWallet?: UserWalletUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
    UserWallet?: UserWalletUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VehicleUpsertWithoutBookingsInput = {
    update: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutBookingsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateWithoutBookingsInput = {
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    DriverVehicle?: DriverVehicleUpdateManyWithoutVehicleNestedInput
    OwnerVehicle?: OwnerVehicleUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutBookingsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    OwnerVehicle?: OwnerVehicleUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type FareNegotiationUpsertWithWhereUniqueWithoutBookingsInput = {
    where: FareNegotiationWhereUniqueInput
    update: XOR<FareNegotiationUpdateWithoutBookingsInput, FareNegotiationUncheckedUpdateWithoutBookingsInput>
    create: XOR<FareNegotiationCreateWithoutBookingsInput, FareNegotiationUncheckedCreateWithoutBookingsInput>
  }

  export type FareNegotiationUpdateWithWhereUniqueWithoutBookingsInput = {
    where: FareNegotiationWhereUniqueInput
    data: XOR<FareNegotiationUpdateWithoutBookingsInput, FareNegotiationUncheckedUpdateWithoutBookingsInput>
  }

  export type FareNegotiationUpdateManyWithWhereWithoutBookingsInput = {
    where: FareNegotiationScalarWhereInput
    data: XOR<FareNegotiationUpdateManyMutationInput, FareNegotiationUncheckedUpdateManyWithoutBookingsInput>
  }

  export type FareNegotiationScalarWhereInput = {
    AND?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
    OR?: FareNegotiationScalarWhereInput[]
    NOT?: FareNegotiationScalarWhereInput | FareNegotiationScalarWhereInput[]
    Id?: IntFilter<"FareNegotiation"> | number
    BookingId?: IntFilter<"FareNegotiation"> | number
    DriverId?: IntFilter<"FareNegotiation"> | number
    OwnerId?: IntFilter<"FareNegotiation"> | number
    NegotiatedFare?: StringFilter<"FareNegotiation"> | string
    NegotiatedTime?: DateTimeFilter<"FareNegotiation"> | Date | string
  }

  export type BookingsCreateWithoutDriverInput = {
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    Fare: string
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    User: UserCreateNestedOneWithoutBookingsInput
    Vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutBookingsInput
  }

  export type BookingsUncheckedCreateWithoutDriverInput = {
    Id?: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    Fare: string
    VehicleId?: number | null
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type BookingsCreateOrConnectWithoutDriverInput = {
    where: BookingsWhereUniqueInput
    create: XOR<BookingsCreateWithoutDriverInput, BookingsUncheckedCreateWithoutDriverInput>
  }

  export type BookingsCreateManyDriverInputEnvelope = {
    data: BookingsCreateManyDriverInput | BookingsCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type DriverVehicleCreateWithoutDriverInput = {
    Vehicle: VehicleCreateNestedOneWithoutDriverVehicleInput
  }

  export type DriverVehicleUncheckedCreateWithoutDriverInput = {
    Id?: number
    VehicleId: number
  }

  export type DriverVehicleCreateOrConnectWithoutDriverInput = {
    where: DriverVehicleWhereUniqueInput
    create: XOR<DriverVehicleCreateWithoutDriverInput, DriverVehicleUncheckedCreateWithoutDriverInput>
  }

  export type DriverVehicleCreateManyDriverInputEnvelope = {
    data: DriverVehicleCreateManyDriverInput | DriverVehicleCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type DriverWalletCreateWithoutDriverInput = {
    Amount: number
    LastUpdated?: Date | string
  }

  export type DriverWalletUncheckedCreateWithoutDriverInput = {
    Id?: number
    Amount: number
    LastUpdated?: Date | string
  }

  export type DriverWalletCreateOrConnectWithoutDriverInput = {
    where: DriverWalletWhereUniqueInput
    create: XOR<DriverWalletCreateWithoutDriverInput, DriverWalletUncheckedCreateWithoutDriverInput>
  }

  export type FareNegotiationCreateWithoutDriverInput = {
    NegotiatedFare: string
    NegotiatedTime?: Date | string
    Bookings: BookingsCreateNestedOneWithoutFareNegotiationInput
    Owner: OwnerCreateNestedOneWithoutFareNegotiationInput
  }

  export type FareNegotiationUncheckedCreateWithoutDriverInput = {
    Id?: number
    BookingId: number
    OwnerId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type FareNegotiationCreateOrConnectWithoutDriverInput = {
    where: FareNegotiationWhereUniqueInput
    create: XOR<FareNegotiationCreateWithoutDriverInput, FareNegotiationUncheckedCreateWithoutDriverInput>
  }

  export type FareNegotiationCreateManyDriverInputEnvelope = {
    data: FareNegotiationCreateManyDriverInput | FareNegotiationCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type OwnerDriverCreateWithoutDriverInput = {
    Owner: OwnerCreateNestedOneWithoutOwnerDriverInput
  }

  export type OwnerDriverUncheckedCreateWithoutDriverInput = {
    Id?: number
    OwnerId: number
  }

  export type OwnerDriverCreateOrConnectWithoutDriverInput = {
    where: OwnerDriverWhereUniqueInput
    create: XOR<OwnerDriverCreateWithoutDriverInput, OwnerDriverUncheckedCreateWithoutDriverInput>
  }

  export type OwnerDriverCreateManyDriverInputEnvelope = {
    data: OwnerDriverCreateManyDriverInput | OwnerDriverCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type BookingsUpsertWithWhereUniqueWithoutDriverInput = {
    where: BookingsWhereUniqueInput
    update: XOR<BookingsUpdateWithoutDriverInput, BookingsUncheckedUpdateWithoutDriverInput>
    create: XOR<BookingsCreateWithoutDriverInput, BookingsUncheckedCreateWithoutDriverInput>
  }

  export type BookingsUpdateWithWhereUniqueWithoutDriverInput = {
    where: BookingsWhereUniqueInput
    data: XOR<BookingsUpdateWithoutDriverInput, BookingsUncheckedUpdateWithoutDriverInput>
  }

  export type BookingsUpdateManyWithWhereWithoutDriverInput = {
    where: BookingsScalarWhereInput
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyWithoutDriverInput>
  }

  export type BookingsScalarWhereInput = {
    AND?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
    OR?: BookingsScalarWhereInput[]
    NOT?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
    Id?: IntFilter<"Bookings"> | number
    UserId?: IntFilter<"Bookings"> | number
    PickUpLocation?: StringFilter<"Bookings"> | string
    DropLocation?: StringFilter<"Bookings"> | string
    Product?: StringFilter<"Bookings"> | string
    Distance?: StringFilter<"Bookings"> | string
    Status?: EnumBookingStatusFilter<"Bookings"> | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFilter<"Bookings"> | $Enums.PaymentMode
    BookingTime?: DateTimeFilter<"Bookings"> | Date | string
    DriverId?: IntNullableFilter<"Bookings"> | number | null
    Fare?: StringFilter<"Bookings"> | string
    VehicleId?: IntNullableFilter<"Bookings"> | number | null
    StartTime?: DateTimeFilter<"Bookings"> | Date | string
    CreatedDateTime?: DateTimeFilter<"Bookings"> | Date | string
    UpdatedDateTime?: DateTimeFilter<"Bookings"> | Date | string
  }

  export type DriverVehicleUpsertWithWhereUniqueWithoutDriverInput = {
    where: DriverVehicleWhereUniqueInput
    update: XOR<DriverVehicleUpdateWithoutDriverInput, DriverVehicleUncheckedUpdateWithoutDriverInput>
    create: XOR<DriverVehicleCreateWithoutDriverInput, DriverVehicleUncheckedCreateWithoutDriverInput>
  }

  export type DriverVehicleUpdateWithWhereUniqueWithoutDriverInput = {
    where: DriverVehicleWhereUniqueInput
    data: XOR<DriverVehicleUpdateWithoutDriverInput, DriverVehicleUncheckedUpdateWithoutDriverInput>
  }

  export type DriverVehicleUpdateManyWithWhereWithoutDriverInput = {
    where: DriverVehicleScalarWhereInput
    data: XOR<DriverVehicleUpdateManyMutationInput, DriverVehicleUncheckedUpdateManyWithoutDriverInput>
  }

  export type DriverVehicleScalarWhereInput = {
    AND?: DriverVehicleScalarWhereInput | DriverVehicleScalarWhereInput[]
    OR?: DriverVehicleScalarWhereInput[]
    NOT?: DriverVehicleScalarWhereInput | DriverVehicleScalarWhereInput[]
    Id?: IntFilter<"DriverVehicle"> | number
    DriverId?: IntFilter<"DriverVehicle"> | number
    VehicleId?: IntFilter<"DriverVehicle"> | number
  }

  export type DriverWalletUpsertWithoutDriverInput = {
    update: XOR<DriverWalletUpdateWithoutDriverInput, DriverWalletUncheckedUpdateWithoutDriverInput>
    create: XOR<DriverWalletCreateWithoutDriverInput, DriverWalletUncheckedCreateWithoutDriverInput>
    where?: DriverWalletWhereInput
  }

  export type DriverWalletUpdateToOneWithWhereWithoutDriverInput = {
    where?: DriverWalletWhereInput
    data: XOR<DriverWalletUpdateWithoutDriverInput, DriverWalletUncheckedUpdateWithoutDriverInput>
  }

  export type DriverWalletUpdateWithoutDriverInput = {
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverWalletUncheckedUpdateWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareNegotiationUpsertWithWhereUniqueWithoutDriverInput = {
    where: FareNegotiationWhereUniqueInput
    update: XOR<FareNegotiationUpdateWithoutDriverInput, FareNegotiationUncheckedUpdateWithoutDriverInput>
    create: XOR<FareNegotiationCreateWithoutDriverInput, FareNegotiationUncheckedCreateWithoutDriverInput>
  }

  export type FareNegotiationUpdateWithWhereUniqueWithoutDriverInput = {
    where: FareNegotiationWhereUniqueInput
    data: XOR<FareNegotiationUpdateWithoutDriverInput, FareNegotiationUncheckedUpdateWithoutDriverInput>
  }

  export type FareNegotiationUpdateManyWithWhereWithoutDriverInput = {
    where: FareNegotiationScalarWhereInput
    data: XOR<FareNegotiationUpdateManyMutationInput, FareNegotiationUncheckedUpdateManyWithoutDriverInput>
  }

  export type OwnerDriverUpsertWithWhereUniqueWithoutDriverInput = {
    where: OwnerDriverWhereUniqueInput
    update: XOR<OwnerDriverUpdateWithoutDriverInput, OwnerDriverUncheckedUpdateWithoutDriverInput>
    create: XOR<OwnerDriverCreateWithoutDriverInput, OwnerDriverUncheckedCreateWithoutDriverInput>
  }

  export type OwnerDriverUpdateWithWhereUniqueWithoutDriverInput = {
    where: OwnerDriverWhereUniqueInput
    data: XOR<OwnerDriverUpdateWithoutDriverInput, OwnerDriverUncheckedUpdateWithoutDriverInput>
  }

  export type OwnerDriverUpdateManyWithWhereWithoutDriverInput = {
    where: OwnerDriverScalarWhereInput
    data: XOR<OwnerDriverUpdateManyMutationInput, OwnerDriverUncheckedUpdateManyWithoutDriverInput>
  }

  export type OwnerDriverScalarWhereInput = {
    AND?: OwnerDriverScalarWhereInput | OwnerDriverScalarWhereInput[]
    OR?: OwnerDriverScalarWhereInput[]
    NOT?: OwnerDriverScalarWhereInput | OwnerDriverScalarWhereInput[]
    Id?: IntFilter<"OwnerDriver"> | number
    OwnerId?: IntFilter<"OwnerDriver"> | number
    DriverId?: IntFilter<"OwnerDriver"> | number
  }

  export type DriverCreateWithoutDriverVehicleInput = {
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutDriverVehicleInput = {
    Id?: number
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsUncheckedCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletUncheckedCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutDriverVehicleInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutDriverVehicleInput, DriverUncheckedCreateWithoutDriverVehicleInput>
  }

  export type VehicleCreateWithoutDriverVehicleInput = {
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    Bookings?: BookingsCreateNestedManyWithoutVehicleInput
    OwnerVehicle?: OwnerVehicleCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutDriverVehicleInput = {
    Id?: number
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    Bookings?: BookingsUncheckedCreateNestedManyWithoutVehicleInput
    OwnerVehicle?: OwnerVehicleUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutDriverVehicleInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutDriverVehicleInput, VehicleUncheckedCreateWithoutDriverVehicleInput>
  }

  export type DriverUpsertWithoutDriverVehicleInput = {
    update: XOR<DriverUpdateWithoutDriverVehicleInput, DriverUncheckedUpdateWithoutDriverVehicleInput>
    create: XOR<DriverCreateWithoutDriverVehicleInput, DriverUncheckedCreateWithoutDriverVehicleInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutDriverVehicleInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutDriverVehicleInput, DriverUncheckedUpdateWithoutDriverVehicleInput>
  }

  export type DriverUpdateWithoutDriverVehicleInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutDriverVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUncheckedUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUncheckedUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type VehicleUpsertWithoutDriverVehicleInput = {
    update: XOR<VehicleUpdateWithoutDriverVehicleInput, VehicleUncheckedUpdateWithoutDriverVehicleInput>
    create: XOR<VehicleCreateWithoutDriverVehicleInput, VehicleUncheckedCreateWithoutDriverVehicleInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutDriverVehicleInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutDriverVehicleInput, VehicleUncheckedUpdateWithoutDriverVehicleInput>
  }

  export type VehicleUpdateWithoutDriverVehicleInput = {
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUpdateManyWithoutVehicleNestedInput
    OwnerVehicle?: OwnerVehicleUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutDriverVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUncheckedUpdateManyWithoutVehicleNestedInput
    OwnerVehicle?: OwnerVehicleUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type DriverCreateWithoutDriverWalletInput = {
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutDriverInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutDriverWalletInput = {
    Id?: number
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsUncheckedCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutDriverInput
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutDriverInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutDriverWalletInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutDriverWalletInput, DriverUncheckedCreateWithoutDriverWalletInput>
  }

  export type DriverUpsertWithoutDriverWalletInput = {
    update: XOR<DriverUpdateWithoutDriverWalletInput, DriverUncheckedUpdateWithoutDriverWalletInput>
    create: XOR<DriverCreateWithoutDriverWalletInput, DriverUncheckedCreateWithoutDriverWalletInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutDriverWalletInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutDriverWalletInput, DriverUncheckedUpdateWithoutDriverWalletInput>
  }

  export type DriverUpdateWithoutDriverWalletInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUpdateManyWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutDriverWalletInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUncheckedUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type BookingsCreateWithoutFareNegotiationInput = {
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    Fare: string
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    Driver?: DriverCreateNestedOneWithoutBookingsInput
    User: UserCreateNestedOneWithoutBookingsInput
    Vehicle?: VehicleCreateNestedOneWithoutBookingsInput
  }

  export type BookingsUncheckedCreateWithoutFareNegotiationInput = {
    Id?: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    DriverId?: number | null
    Fare: string
    VehicleId?: number | null
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
  }

  export type BookingsCreateOrConnectWithoutFareNegotiationInput = {
    where: BookingsWhereUniqueInput
    create: XOR<BookingsCreateWithoutFareNegotiationInput, BookingsUncheckedCreateWithoutFareNegotiationInput>
  }

  export type DriverCreateWithoutFareNegotiationInput = {
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletCreateNestedOneWithoutDriverInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutFareNegotiationInput = {
    Id?: number
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsUncheckedCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletUncheckedCreateNestedOneWithoutDriverInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutFareNegotiationInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutFareNegotiationInput, DriverUncheckedCreateWithoutFareNegotiationInput>
  }

  export type OwnerCreateWithoutFareNegotiationInput = {
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletCreateNestedOneWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutFareNegotiationInput = {
    Id?: number
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleUncheckedCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletUncheckedCreateNestedOneWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutFareNegotiationInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutFareNegotiationInput, OwnerUncheckedCreateWithoutFareNegotiationInput>
  }

  export type BookingsUpsertWithoutFareNegotiationInput = {
    update: XOR<BookingsUpdateWithoutFareNegotiationInput, BookingsUncheckedUpdateWithoutFareNegotiationInput>
    create: XOR<BookingsCreateWithoutFareNegotiationInput, BookingsUncheckedCreateWithoutFareNegotiationInput>
    where?: BookingsWhereInput
  }

  export type BookingsUpdateToOneWithWhereWithoutFareNegotiationInput = {
    where?: BookingsWhereInput
    data: XOR<BookingsUpdateWithoutFareNegotiationInput, BookingsUncheckedUpdateWithoutFareNegotiationInput>
  }

  export type BookingsUpdateWithoutFareNegotiationInput = {
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Driver?: DriverUpdateOneWithoutBookingsNestedInput
    User?: UserUpdateOneRequiredWithoutBookingsNestedInput
    Vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateWithoutFareNegotiationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverId?: NullableIntFieldUpdateOperationsInput | number | null
    Fare?: StringFieldUpdateOperationsInput | string
    VehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUpsertWithoutFareNegotiationInput = {
    update: XOR<DriverUpdateWithoutFareNegotiationInput, DriverUncheckedUpdateWithoutFareNegotiationInput>
    create: XOR<DriverCreateWithoutFareNegotiationInput, DriverUncheckedCreateWithoutFareNegotiationInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutFareNegotiationInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutFareNegotiationInput, DriverUncheckedUpdateWithoutFareNegotiationInput>
  }

  export type DriverUpdateWithoutFareNegotiationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUpdateOneWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutFareNegotiationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUncheckedUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUncheckedUpdateOneWithoutDriverNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type OwnerUpsertWithoutFareNegotiationInput = {
    update: XOR<OwnerUpdateWithoutFareNegotiationInput, OwnerUncheckedUpdateWithoutFareNegotiationInput>
    create: XOR<OwnerCreateWithoutFareNegotiationInput, OwnerUncheckedCreateWithoutFareNegotiationInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutFareNegotiationInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutFareNegotiationInput, OwnerUncheckedUpdateWithoutFareNegotiationInput>
  }

  export type OwnerUpdateWithoutFareNegotiationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    OwnerDriver?: OwnerDriverUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUpdateOneWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutFareNegotiationInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUncheckedUpdateOneWithoutOwnerNestedInput
  }

  export type FareNegotiationCreateWithoutOwnerInput = {
    NegotiatedFare: string
    NegotiatedTime?: Date | string
    Bookings: BookingsCreateNestedOneWithoutFareNegotiationInput
    Driver: DriverCreateNestedOneWithoutFareNegotiationInput
  }

  export type FareNegotiationUncheckedCreateWithoutOwnerInput = {
    Id?: number
    BookingId: number
    DriverId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type FareNegotiationCreateOrConnectWithoutOwnerInput = {
    where: FareNegotiationWhereUniqueInput
    create: XOR<FareNegotiationCreateWithoutOwnerInput, FareNegotiationUncheckedCreateWithoutOwnerInput>
  }

  export type FareNegotiationCreateManyOwnerInputEnvelope = {
    data: FareNegotiationCreateManyOwnerInput | FareNegotiationCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OwnerDriverCreateWithoutOwnerInput = {
    Driver: DriverCreateNestedOneWithoutOwnerDriverInput
  }

  export type OwnerDriverUncheckedCreateWithoutOwnerInput = {
    Id?: number
    DriverId: number
  }

  export type OwnerDriverCreateOrConnectWithoutOwnerInput = {
    where: OwnerDriverWhereUniqueInput
    create: XOR<OwnerDriverCreateWithoutOwnerInput, OwnerDriverUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerDriverCreateManyOwnerInputEnvelope = {
    data: OwnerDriverCreateManyOwnerInput | OwnerDriverCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OwnerVehicleCreateWithoutOwnerInput = {
    Vehicle: VehicleCreateNestedOneWithoutOwnerVehicleInput
  }

  export type OwnerVehicleUncheckedCreateWithoutOwnerInput = {
    Id?: number
    VehicleId: number
  }

  export type OwnerVehicleCreateOrConnectWithoutOwnerInput = {
    where: OwnerVehicleWhereUniqueInput
    create: XOR<OwnerVehicleCreateWithoutOwnerInput, OwnerVehicleUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerVehicleCreateManyOwnerInputEnvelope = {
    data: OwnerVehicleCreateManyOwnerInput | OwnerVehicleCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OwnerWalletCreateWithoutOwnerInput = {
    Amount: number
    LastUpdated?: Date | string
  }

  export type OwnerWalletUncheckedCreateWithoutOwnerInput = {
    Id?: number
    Amount: number
    LastUpdated?: Date | string
  }

  export type OwnerWalletCreateOrConnectWithoutOwnerInput = {
    where: OwnerWalletWhereUniqueInput
    create: XOR<OwnerWalletCreateWithoutOwnerInput, OwnerWalletUncheckedCreateWithoutOwnerInput>
  }

  export type FareNegotiationUpsertWithWhereUniqueWithoutOwnerInput = {
    where: FareNegotiationWhereUniqueInput
    update: XOR<FareNegotiationUpdateWithoutOwnerInput, FareNegotiationUncheckedUpdateWithoutOwnerInput>
    create: XOR<FareNegotiationCreateWithoutOwnerInput, FareNegotiationUncheckedCreateWithoutOwnerInput>
  }

  export type FareNegotiationUpdateWithWhereUniqueWithoutOwnerInput = {
    where: FareNegotiationWhereUniqueInput
    data: XOR<FareNegotiationUpdateWithoutOwnerInput, FareNegotiationUncheckedUpdateWithoutOwnerInput>
  }

  export type FareNegotiationUpdateManyWithWhereWithoutOwnerInput = {
    where: FareNegotiationScalarWhereInput
    data: XOR<FareNegotiationUpdateManyMutationInput, FareNegotiationUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OwnerDriverUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OwnerDriverWhereUniqueInput
    update: XOR<OwnerDriverUpdateWithoutOwnerInput, OwnerDriverUncheckedUpdateWithoutOwnerInput>
    create: XOR<OwnerDriverCreateWithoutOwnerInput, OwnerDriverUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerDriverUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OwnerDriverWhereUniqueInput
    data: XOR<OwnerDriverUpdateWithoutOwnerInput, OwnerDriverUncheckedUpdateWithoutOwnerInput>
  }

  export type OwnerDriverUpdateManyWithWhereWithoutOwnerInput = {
    where: OwnerDriverScalarWhereInput
    data: XOR<OwnerDriverUpdateManyMutationInput, OwnerDriverUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OwnerVehicleUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OwnerVehicleWhereUniqueInput
    update: XOR<OwnerVehicleUpdateWithoutOwnerInput, OwnerVehicleUncheckedUpdateWithoutOwnerInput>
    create: XOR<OwnerVehicleCreateWithoutOwnerInput, OwnerVehicleUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerVehicleUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OwnerVehicleWhereUniqueInput
    data: XOR<OwnerVehicleUpdateWithoutOwnerInput, OwnerVehicleUncheckedUpdateWithoutOwnerInput>
  }

  export type OwnerVehicleUpdateManyWithWhereWithoutOwnerInput = {
    where: OwnerVehicleScalarWhereInput
    data: XOR<OwnerVehicleUpdateManyMutationInput, OwnerVehicleUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OwnerVehicleScalarWhereInput = {
    AND?: OwnerVehicleScalarWhereInput | OwnerVehicleScalarWhereInput[]
    OR?: OwnerVehicleScalarWhereInput[]
    NOT?: OwnerVehicleScalarWhereInput | OwnerVehicleScalarWhereInput[]
    Id?: IntFilter<"OwnerVehicle"> | number
    OwnerId?: IntFilter<"OwnerVehicle"> | number
    VehicleId?: IntFilter<"OwnerVehicle"> | number
  }

  export type OwnerWalletUpsertWithoutOwnerInput = {
    update: XOR<OwnerWalletUpdateWithoutOwnerInput, OwnerWalletUncheckedUpdateWithoutOwnerInput>
    create: XOR<OwnerWalletCreateWithoutOwnerInput, OwnerWalletUncheckedCreateWithoutOwnerInput>
    where?: OwnerWalletWhereInput
  }

  export type OwnerWalletUpdateToOneWithWhereWithoutOwnerInput = {
    where?: OwnerWalletWhereInput
    data: XOR<OwnerWalletUpdateWithoutOwnerInput, OwnerWalletUncheckedUpdateWithoutOwnerInput>
  }

  export type OwnerWalletUpdateWithoutOwnerInput = {
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerWalletUncheckedUpdateWithoutOwnerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
    LastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateWithoutOwnerDriverInput = {
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutOwnerDriverInput = {
    Id?: number
    Name?: string | null
    Gender: $Enums.Gender
    Password?: string | null
    MobileNumber: string
    DOB?: Date | string | null
    DrivingLicenceNumber: string
    DrivingLicenceFrontImage: string
    DrivingLicenceBackImage: string
    DriverImage: string
    Email?: string | null
    AdhaarCardNumber: string
    FrontSideAdhaarImage: string
    BackSideAdhaarImage: string
    PanNumber: string
    PanImage: string
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    IsOnline?: boolean
    Bookings?: BookingsUncheckedCreateNestedManyWithoutDriverInput
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutDriverInput
    DriverWallet?: DriverWalletUncheckedCreateNestedOneWithoutDriverInput
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutOwnerDriverInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutOwnerDriverInput, DriverUncheckedCreateWithoutOwnerDriverInput>
  }

  export type OwnerCreateWithoutOwnerDriverInput = {
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletCreateNestedOneWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutOwnerDriverInput = {
    Id?: number
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleUncheckedCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletUncheckedCreateNestedOneWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutOwnerDriverInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutOwnerDriverInput, OwnerUncheckedCreateWithoutOwnerDriverInput>
  }

  export type DriverUpsertWithoutOwnerDriverInput = {
    update: XOR<DriverUpdateWithoutOwnerDriverInput, DriverUncheckedUpdateWithoutOwnerDriverInput>
    create: XOR<DriverCreateWithoutOwnerDriverInput, DriverUncheckedCreateWithoutOwnerDriverInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutOwnerDriverInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutOwnerDriverInput, DriverUncheckedUpdateWithoutOwnerDriverInput>
  }

  export type DriverUpdateWithoutOwnerDriverInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutOwnerDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DrivingLicenceNumber?: StringFieldUpdateOperationsInput | string
    DrivingLicenceFrontImage?: StringFieldUpdateOperationsInput | string
    DrivingLicenceBackImage?: StringFieldUpdateOperationsInput | string
    DriverImage?: StringFieldUpdateOperationsInput | string
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    AdhaarCardNumber?: StringFieldUpdateOperationsInput | string
    FrontSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    BackSideAdhaarImage?: StringFieldUpdateOperationsInput | string
    PanNumber?: StringFieldUpdateOperationsInput | string
    PanImage?: StringFieldUpdateOperationsInput | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    IsOnline?: BoolFieldUpdateOperationsInput | boolean
    Bookings?: BookingsUncheckedUpdateManyWithoutDriverNestedInput
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutDriverNestedInput
    DriverWallet?: DriverWalletUncheckedUpdateOneWithoutDriverNestedInput
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type OwnerUpsertWithoutOwnerDriverInput = {
    update: XOR<OwnerUpdateWithoutOwnerDriverInput, OwnerUncheckedUpdateWithoutOwnerDriverInput>
    create: XOR<OwnerCreateWithoutOwnerDriverInput, OwnerUncheckedCreateWithoutOwnerDriverInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutOwnerDriverInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutOwnerDriverInput, OwnerUncheckedUpdateWithoutOwnerDriverInput>
  }

  export type OwnerUpdateWithoutOwnerDriverInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUpdateOneWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutOwnerDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUncheckedUpdateOneWithoutOwnerNestedInput
  }

  export type OwnerCreateWithoutOwnerVehicleInput = {
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutOwnerInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletCreateNestedOneWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutOwnerVehicleInput = {
    Id?: number
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutOwnerInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutOwnerInput
    OwnerWallet?: OwnerWalletUncheckedCreateNestedOneWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutOwnerVehicleInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutOwnerVehicleInput, OwnerUncheckedCreateWithoutOwnerVehicleInput>
  }

  export type VehicleCreateWithoutOwnerVehicleInput = {
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    Bookings?: BookingsCreateNestedManyWithoutVehicleInput
    DriverVehicle?: DriverVehicleCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutOwnerVehicleInput = {
    Id?: number
    Model: string
    Year: string
    Category: string
    VehicleImage?: string | null
    VehicleInsuranceImage?: string | null
    PermitImage?: string | null
    VehicleNumber: string
    Bookings?: BookingsUncheckedCreateNestedManyWithoutVehicleInput
    DriverVehicle?: DriverVehicleUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutOwnerVehicleInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutOwnerVehicleInput, VehicleUncheckedCreateWithoutOwnerVehicleInput>
  }

  export type OwnerUpsertWithoutOwnerVehicleInput = {
    update: XOR<OwnerUpdateWithoutOwnerVehicleInput, OwnerUncheckedUpdateWithoutOwnerVehicleInput>
    create: XOR<OwnerCreateWithoutOwnerVehicleInput, OwnerUncheckedCreateWithoutOwnerVehicleInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutOwnerVehicleInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutOwnerVehicleInput, OwnerUncheckedUpdateWithoutOwnerVehicleInput>
  }

  export type OwnerUpdateWithoutOwnerVehicleInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUpdateManyWithoutOwnerNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUpdateOneWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutOwnerVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerWallet?: OwnerWalletUncheckedUpdateOneWithoutOwnerNestedInput
  }

  export type VehicleUpsertWithoutOwnerVehicleInput = {
    update: XOR<VehicleUpdateWithoutOwnerVehicleInput, VehicleUncheckedUpdateWithoutOwnerVehicleInput>
    create: XOR<VehicleCreateWithoutOwnerVehicleInput, VehicleUncheckedCreateWithoutOwnerVehicleInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutOwnerVehicleInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutOwnerVehicleInput, VehicleUncheckedUpdateWithoutOwnerVehicleInput>
  }

  export type VehicleUpdateWithoutOwnerVehicleInput = {
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUpdateManyWithoutVehicleNestedInput
    DriverVehicle?: DriverVehicleUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutOwnerVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Model?: StringFieldUpdateOperationsInput | string
    Year?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    VehicleImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleInsuranceImage?: NullableStringFieldUpdateOperationsInput | string | null
    PermitImage?: NullableStringFieldUpdateOperationsInput | string | null
    VehicleNumber?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUncheckedUpdateManyWithoutVehicleNestedInput
    DriverVehicle?: DriverVehicleUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type OwnerCreateWithoutOwnerWalletInput = {
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutOwnerInput
    OwnerDriver?: OwnerDriverCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutOwnerWalletInput = {
    Id?: number
    Name: string
    Password: string
    MobileNumber: string
    DOB?: Date | string | null
    Email?: string | null
    Gender: $Enums.Gender
    AdhaarCardNumber?: string | null
    FrontSideAdhaarImage?: string | null
    BackSideAdhaarImage?: string | null
    PanNumber?: string | null
    PanImage?: string | null
    LastLoggedIn?: Date | string
    CreatedDate?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutOwnerInput
    OwnerDriver?: OwnerDriverUncheckedCreateNestedManyWithoutOwnerInput
    OwnerVehicle?: OwnerVehicleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutOwnerWalletInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutOwnerWalletInput, OwnerUncheckedCreateWithoutOwnerWalletInput>
  }

  export type OwnerUpsertWithoutOwnerWalletInput = {
    update: XOR<OwnerUpdateWithoutOwnerWalletInput, OwnerUncheckedUpdateWithoutOwnerWalletInput>
    create: XOR<OwnerCreateWithoutOwnerWalletInput, OwnerUncheckedCreateWithoutOwnerWalletInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutOwnerWalletInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutOwnerWalletInput, OwnerUncheckedUpdateWithoutOwnerWalletInput>
  }

  export type OwnerUpdateWithoutOwnerWalletInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUpdateManyWithoutOwnerNestedInput
    OwnerDriver?: OwnerDriverUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutOwnerWalletInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    MobileNumber?: StringFieldUpdateOperationsInput | string
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    AdhaarCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FrontSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    BackSideAdhaarImage?: NullableStringFieldUpdateOperationsInput | string | null
    PanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PanImage?: NullableStringFieldUpdateOperationsInput | string | null
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerDriver?: OwnerDriverUncheckedUpdateManyWithoutOwnerNestedInput
    OwnerVehicle?: OwnerVehicleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type BookingsCreateWithoutUserInput = {
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    Fare: string
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    Driver?: DriverCreateNestedOneWithoutBookingsInput
    Vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutBookingsInput
  }

  export type BookingsUncheckedCreateWithoutUserInput = {
    Id?: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    DriverId?: number | null
    Fare: string
    VehicleId?: number | null
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type BookingsCreateOrConnectWithoutUserInput = {
    where: BookingsWhereUniqueInput
    create: XOR<BookingsCreateWithoutUserInput, BookingsUncheckedCreateWithoutUserInput>
  }

  export type BookingsCreateManyUserInputEnvelope = {
    data: BookingsCreateManyUserInput | BookingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserWalletCreateWithoutUserInput = {
    Amount: number
  }

  export type UserWalletUncheckedCreateWithoutUserInput = {
    Id?: number
    Amount: number
  }

  export type UserWalletCreateOrConnectWithoutUserInput = {
    where: UserWalletWhereUniqueInput
    create: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
  }

  export type BookingsUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingsWhereUniqueInput
    update: XOR<BookingsUpdateWithoutUserInput, BookingsUncheckedUpdateWithoutUserInput>
    create: XOR<BookingsCreateWithoutUserInput, BookingsUncheckedCreateWithoutUserInput>
  }

  export type BookingsUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingsWhereUniqueInput
    data: XOR<BookingsUpdateWithoutUserInput, BookingsUncheckedUpdateWithoutUserInput>
  }

  export type BookingsUpdateManyWithWhereWithoutUserInput = {
    where: BookingsScalarWhereInput
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserWalletUpsertWithoutUserInput = {
    update: XOR<UserWalletUpdateWithoutUserInput, UserWalletUncheckedUpdateWithoutUserInput>
    create: XOR<UserWalletCreateWithoutUserInput, UserWalletUncheckedCreateWithoutUserInput>
    where?: UserWalletWhereInput
  }

  export type UserWalletUpdateToOneWithWhereWithoutUserInput = {
    where?: UserWalletWhereInput
    data: XOR<UserWalletUpdateWithoutUserInput, UserWalletUncheckedUpdateWithoutUserInput>
  }

  export type UserWalletUpdateWithoutUserInput = {
    Amount?: IntFieldUpdateOperationsInput | number
  }

  export type UserWalletUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Amount?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutUserWalletInput = {
    MobileNumber: string
    CreatedDate?: Date | string
    LastLoggedIn?: Date | string
    Gender: $Enums.Gender
    Name: string
    Bookings?: BookingsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserWalletInput = {
    Id?: number
    MobileNumber: string
    CreatedDate?: Date | string
    LastLoggedIn?: Date | string
    Gender: $Enums.Gender
    Name: string
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserWalletInput, UserUncheckedCreateWithoutUserWalletInput>
  }

  export type UserUpsertWithoutUserWalletInput = {
    update: XOR<UserUpdateWithoutUserWalletInput, UserUncheckedUpdateWithoutUserWalletInput>
    create: XOR<UserCreateWithoutUserWalletInput, UserUncheckedCreateWithoutUserWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserWalletInput, UserUncheckedUpdateWithoutUserWalletInput>
  }

  export type UserUpdateWithoutUserWalletInput = {
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserWalletInput = {
    Id?: IntFieldUpdateOperationsInput | number
    MobileNumber?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastLoggedIn?: DateTimeFieldUpdateOperationsInput | Date | string
    Gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    Name?: StringFieldUpdateOperationsInput | string
    Bookings?: BookingsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingsCreateWithoutVehicleInput = {
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    Fare: string
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    Driver?: DriverCreateNestedOneWithoutBookingsInput
    User: UserCreateNestedOneWithoutBookingsInput
    FareNegotiation?: FareNegotiationCreateNestedManyWithoutBookingsInput
  }

  export type BookingsUncheckedCreateWithoutVehicleInput = {
    Id?: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    DriverId?: number | null
    Fare: string
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
    FareNegotiation?: FareNegotiationUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type BookingsCreateOrConnectWithoutVehicleInput = {
    where: BookingsWhereUniqueInput
    create: XOR<BookingsCreateWithoutVehicleInput, BookingsUncheckedCreateWithoutVehicleInput>
  }

  export type BookingsCreateManyVehicleInputEnvelope = {
    data: BookingsCreateManyVehicleInput | BookingsCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type DriverVehicleCreateWithoutVehicleInput = {
    Driver: DriverCreateNestedOneWithoutDriverVehicleInput
  }

  export type DriverVehicleUncheckedCreateWithoutVehicleInput = {
    Id?: number
    DriverId: number
  }

  export type DriverVehicleCreateOrConnectWithoutVehicleInput = {
    where: DriverVehicleWhereUniqueInput
    create: XOR<DriverVehicleCreateWithoutVehicleInput, DriverVehicleUncheckedCreateWithoutVehicleInput>
  }

  export type DriverVehicleCreateManyVehicleInputEnvelope = {
    data: DriverVehicleCreateManyVehicleInput | DriverVehicleCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type OwnerVehicleCreateWithoutVehicleInput = {
    Owner: OwnerCreateNestedOneWithoutOwnerVehicleInput
  }

  export type OwnerVehicleUncheckedCreateWithoutVehicleInput = {
    Id?: number
    OwnerId: number
  }

  export type OwnerVehicleCreateOrConnectWithoutVehicleInput = {
    where: OwnerVehicleWhereUniqueInput
    create: XOR<OwnerVehicleCreateWithoutVehicleInput, OwnerVehicleUncheckedCreateWithoutVehicleInput>
  }

  export type OwnerVehicleCreateManyVehicleInputEnvelope = {
    data: OwnerVehicleCreateManyVehicleInput | OwnerVehicleCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type BookingsUpsertWithWhereUniqueWithoutVehicleInput = {
    where: BookingsWhereUniqueInput
    update: XOR<BookingsUpdateWithoutVehicleInput, BookingsUncheckedUpdateWithoutVehicleInput>
    create: XOR<BookingsCreateWithoutVehicleInput, BookingsUncheckedCreateWithoutVehicleInput>
  }

  export type BookingsUpdateWithWhereUniqueWithoutVehicleInput = {
    where: BookingsWhereUniqueInput
    data: XOR<BookingsUpdateWithoutVehicleInput, BookingsUncheckedUpdateWithoutVehicleInput>
  }

  export type BookingsUpdateManyWithWhereWithoutVehicleInput = {
    where: BookingsScalarWhereInput
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyWithoutVehicleInput>
  }

  export type DriverVehicleUpsertWithWhereUniqueWithoutVehicleInput = {
    where: DriverVehicleWhereUniqueInput
    update: XOR<DriverVehicleUpdateWithoutVehicleInput, DriverVehicleUncheckedUpdateWithoutVehicleInput>
    create: XOR<DriverVehicleCreateWithoutVehicleInput, DriverVehicleUncheckedCreateWithoutVehicleInput>
  }

  export type DriverVehicleUpdateWithWhereUniqueWithoutVehicleInput = {
    where: DriverVehicleWhereUniqueInput
    data: XOR<DriverVehicleUpdateWithoutVehicleInput, DriverVehicleUncheckedUpdateWithoutVehicleInput>
  }

  export type DriverVehicleUpdateManyWithWhereWithoutVehicleInput = {
    where: DriverVehicleScalarWhereInput
    data: XOR<DriverVehicleUpdateManyMutationInput, DriverVehicleUncheckedUpdateManyWithoutVehicleInput>
  }

  export type OwnerVehicleUpsertWithWhereUniqueWithoutVehicleInput = {
    where: OwnerVehicleWhereUniqueInput
    update: XOR<OwnerVehicleUpdateWithoutVehicleInput, OwnerVehicleUncheckedUpdateWithoutVehicleInput>
    create: XOR<OwnerVehicleCreateWithoutVehicleInput, OwnerVehicleUncheckedCreateWithoutVehicleInput>
  }

  export type OwnerVehicleUpdateWithWhereUniqueWithoutVehicleInput = {
    where: OwnerVehicleWhereUniqueInput
    data: XOR<OwnerVehicleUpdateWithoutVehicleInput, OwnerVehicleUncheckedUpdateWithoutVehicleInput>
  }

  export type OwnerVehicleUpdateManyWithWhereWithoutVehicleInput = {
    where: OwnerVehicleScalarWhereInput
    data: XOR<OwnerVehicleUpdateManyMutationInput, OwnerVehicleUncheckedUpdateManyWithoutVehicleInput>
  }

  export type permission_audit_logsCreateWithoutAdminInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    permissions?: permissionsCreateNestedOneWithoutPermission_audit_logsInput
    roles?: rolesCreateNestedOneWithoutPermission_audit_logsInput
  }

  export type permission_audit_logsUncheckedCreateWithoutAdminInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    roleId?: string | null
    permissionId?: string | null
  }

  export type permission_audit_logsCreateOrConnectWithoutAdminInput = {
    where: permission_audit_logsWhereUniqueInput
    create: XOR<permission_audit_logsCreateWithoutAdminInput, permission_audit_logsUncheckedCreateWithoutAdminInput>
  }

  export type permission_audit_logsCreateManyAdminInputEnvelope = {
    data: permission_audit_logsCreateManyAdminInput | permission_audit_logsCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type rolesCreateWithoutAdminInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
    user_roles?: user_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutAdminInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutAdminInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutAdminInput, rolesUncheckedCreateWithoutAdminInput>
  }

  export type rolesCreateManyAdminInputEnvelope = {
    data: rolesCreateManyAdminInput | rolesCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput = {
    id: string
    assignedAt?: Date | string
    admin_user_roles_assignedByIdToadmin?: adminCreateNestedOneWithoutUser_roles_user_roles_assignedByIdToadminInput
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput = {
    id: string
    assignedAt?: Date | string
    roleId: string
    assignedById?: string | null
  }

  export type user_rolesCreateOrConnectWithoutAdmin_user_roles_adminIdToadminInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput>
  }

  export type user_rolesCreateManyAdmin_user_roles_adminIdToadminInputEnvelope = {
    data: user_rolesCreateManyAdmin_user_roles_adminIdToadminInput | user_rolesCreateManyAdmin_user_roles_adminIdToadminInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput = {
    id: string
    assignedAt?: Date | string
    admin_user_roles_adminIdToadmin: adminCreateNestedOneWithoutUser_roles_user_roles_adminIdToadminInput
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput = {
    id: string
    assignedAt?: Date | string
    adminId: string
    roleId: string
  }

  export type user_rolesCreateOrConnectWithoutAdmin_user_roles_assignedByIdToadminInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput>
  }

  export type user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInputEnvelope = {
    data: user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInput | user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInput[]
    skipDuplicates?: boolean
  }

  export type permission_audit_logsUpsertWithWhereUniqueWithoutAdminInput = {
    where: permission_audit_logsWhereUniqueInput
    update: XOR<permission_audit_logsUpdateWithoutAdminInput, permission_audit_logsUncheckedUpdateWithoutAdminInput>
    create: XOR<permission_audit_logsCreateWithoutAdminInput, permission_audit_logsUncheckedCreateWithoutAdminInput>
  }

  export type permission_audit_logsUpdateWithWhereUniqueWithoutAdminInput = {
    where: permission_audit_logsWhereUniqueInput
    data: XOR<permission_audit_logsUpdateWithoutAdminInput, permission_audit_logsUncheckedUpdateWithoutAdminInput>
  }

  export type permission_audit_logsUpdateManyWithWhereWithoutAdminInput = {
    where: permission_audit_logsScalarWhereInput
    data: XOR<permission_audit_logsUpdateManyMutationInput, permission_audit_logsUncheckedUpdateManyWithoutAdminInput>
  }

  export type permission_audit_logsScalarWhereInput = {
    AND?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
    OR?: permission_audit_logsScalarWhereInput[]
    NOT?: permission_audit_logsScalarWhereInput | permission_audit_logsScalarWhereInput[]
    id?: StringFilter<"permission_audit_logs"> | string
    actionType?: EnumAuditActionTypeFilter<"permission_audit_logs"> | $Enums.AuditActionType
    details?: StringNullableFilter<"permission_audit_logs"> | string | null
    actionTimestamp?: DateTimeFilter<"permission_audit_logs"> | Date | string
    adminId?: StringFilter<"permission_audit_logs"> | string
    roleId?: StringNullableFilter<"permission_audit_logs"> | string | null
    permissionId?: StringNullableFilter<"permission_audit_logs"> | string | null
  }

  export type rolesUpsertWithWhereUniqueWithoutAdminInput = {
    where: rolesWhereUniqueInput
    update: XOR<rolesUpdateWithoutAdminInput, rolesUncheckedUpdateWithoutAdminInput>
    create: XOR<rolesCreateWithoutAdminInput, rolesUncheckedCreateWithoutAdminInput>
  }

  export type rolesUpdateWithWhereUniqueWithoutAdminInput = {
    where: rolesWhereUniqueInput
    data: XOR<rolesUpdateWithoutAdminInput, rolesUncheckedUpdateWithoutAdminInput>
  }

  export type rolesUpdateManyWithWhereWithoutAdminInput = {
    where: rolesScalarWhereInput
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyWithoutAdminInput>
  }

  export type rolesScalarWhereInput = {
    AND?: rolesScalarWhereInput | rolesScalarWhereInput[]
    OR?: rolesScalarWhereInput[]
    NOT?: rolesScalarWhereInput | rolesScalarWhereInput[]
    id?: StringFilter<"roles"> | string
    name?: StringFilter<"roles"> | string
    description?: StringNullableFilter<"roles"> | string | null
    isSystemRole?: BoolFilter<"roles"> | boolean
    createdAt?: DateTimeFilter<"roles"> | Date | string
    updatedAt?: DateTimeFilter<"roles"> | Date | string
    createdById?: StringNullableFilter<"roles"> | string | null
  }

  export type user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedUpdateWithoutAdmin_user_roles_adminIdToadminInput>
    create: XOR<user_rolesCreateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_adminIdToadminInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_adminIdToadminInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutAdmin_user_roles_adminIdToadminInput, user_rolesUncheckedUpdateWithoutAdmin_user_roles_adminIdToadminInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_adminIdToadminInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_adminIdToadminInput>
  }

  export type user_rolesScalarWhereInput = {
    AND?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    OR?: user_rolesScalarWhereInput[]
    NOT?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    id?: StringFilter<"user_roles"> | string
    assignedAt?: DateTimeFilter<"user_roles"> | Date | string
    adminId?: StringFilter<"user_roles"> | string
    roleId?: StringFilter<"user_roles"> | string
    assignedById?: StringNullableFilter<"user_roles"> | string | null
  }

  export type user_rolesUpsertWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedUpdateWithoutAdmin_user_roles_assignedByIdToadminInput>
    create: XOR<user_rolesCreateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedCreateWithoutAdmin_user_roles_assignedByIdToadminInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutAdmin_user_roles_assignedByIdToadminInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutAdmin_user_roles_assignedByIdToadminInput, user_rolesUncheckedUpdateWithoutAdmin_user_roles_assignedByIdToadminInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutAdmin_user_roles_assignedByIdToadminInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_assignedByIdToadminInput>
  }

  export type adminCreateWithoutPermission_audit_logsInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    roles?: rolesCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminUncheckedCreateWithoutPermission_audit_logsInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    roles?: rolesUncheckedCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminCreateOrConnectWithoutPermission_audit_logsInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutPermission_audit_logsInput, adminUncheckedCreateWithoutPermission_audit_logsInput>
  }

  export type permissionsCreateWithoutPermission_audit_logsInput = {
    id: string
    name: string
    code: string
    description?: string | null
    permission_categories: permission_categoriesCreateNestedOneWithoutPermissionsInput
    role_permissions?: role_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateWithoutPermission_audit_logsInput = {
    id: string
    name: string
    code: string
    description?: string | null
    categoryId: string
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsCreateOrConnectWithoutPermission_audit_logsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutPermission_audit_logsInput, permissionsUncheckedCreateWithoutPermission_audit_logsInput>
  }

  export type rolesCreateWithoutPermission_audit_logsInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
    admin?: adminCreateNestedOneWithoutRolesInput
    user_roles?: user_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutPermission_audit_logsInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    createdById?: string | null
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutPermission_audit_logsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutPermission_audit_logsInput, rolesUncheckedCreateWithoutPermission_audit_logsInput>
  }

  export type adminUpsertWithoutPermission_audit_logsInput = {
    update: XOR<adminUpdateWithoutPermission_audit_logsInput, adminUncheckedUpdateWithoutPermission_audit_logsInput>
    create: XOR<adminCreateWithoutPermission_audit_logsInput, adminUncheckedCreateWithoutPermission_audit_logsInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutPermission_audit_logsInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutPermission_audit_logsInput, adminUncheckedUpdateWithoutPermission_audit_logsInput>
  }

  export type adminUpdateWithoutPermission_audit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: rolesUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type adminUncheckedUpdateWithoutPermission_audit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: rolesUncheckedUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type permissionsUpsertWithoutPermission_audit_logsInput = {
    update: XOR<permissionsUpdateWithoutPermission_audit_logsInput, permissionsUncheckedUpdateWithoutPermission_audit_logsInput>
    create: XOR<permissionsCreateWithoutPermission_audit_logsInput, permissionsUncheckedCreateWithoutPermission_audit_logsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutPermission_audit_logsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutPermission_audit_logsInput, permissionsUncheckedUpdateWithoutPermission_audit_logsInput>
  }

  export type permissionsUpdateWithoutPermission_audit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission_categories?: permission_categoriesUpdateOneRequiredWithoutPermissionsNestedInput
    role_permissions?: role_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateWithoutPermission_audit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type rolesUpsertWithoutPermission_audit_logsInput = {
    update: XOR<rolesUpdateWithoutPermission_audit_logsInput, rolesUncheckedUpdateWithoutPermission_audit_logsInput>
    create: XOR<rolesCreateWithoutPermission_audit_logsInput, rolesUncheckedCreateWithoutPermission_audit_logsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutPermission_audit_logsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutPermission_audit_logsInput, rolesUncheckedUpdateWithoutPermission_audit_logsInput>
  }

  export type rolesUpdateWithoutPermission_audit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
    admin?: adminUpdateOneWithoutRolesNestedInput
    user_roles?: user_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutPermission_audit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type permissionsCreateWithoutPermission_categoriesInput = {
    id: string
    name: string
    code: string
    description?: string | null
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutPermissionsInput
    role_permissions?: role_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateWithoutPermission_categoriesInput = {
    id: string
    name: string
    code: string
    description?: string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutPermissionsInput
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsCreateOrConnectWithoutPermission_categoriesInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutPermission_categoriesInput, permissionsUncheckedCreateWithoutPermission_categoriesInput>
  }

  export type permissionsCreateManyPermission_categoriesInputEnvelope = {
    data: permissionsCreateManyPermission_categoriesInput | permissionsCreateManyPermission_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type permissionsUpsertWithWhereUniqueWithoutPermission_categoriesInput = {
    where: permissionsWhereUniqueInput
    update: XOR<permissionsUpdateWithoutPermission_categoriesInput, permissionsUncheckedUpdateWithoutPermission_categoriesInput>
    create: XOR<permissionsCreateWithoutPermission_categoriesInput, permissionsUncheckedCreateWithoutPermission_categoriesInput>
  }

  export type permissionsUpdateWithWhereUniqueWithoutPermission_categoriesInput = {
    where: permissionsWhereUniqueInput
    data: XOR<permissionsUpdateWithoutPermission_categoriesInput, permissionsUncheckedUpdateWithoutPermission_categoriesInput>
  }

  export type permissionsUpdateManyWithWhereWithoutPermission_categoriesInput = {
    where: permissionsScalarWhereInput
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyWithoutPermission_categoriesInput>
  }

  export type permissionsScalarWhereInput = {
    AND?: permissionsScalarWhereInput | permissionsScalarWhereInput[]
    OR?: permissionsScalarWhereInput[]
    NOT?: permissionsScalarWhereInput | permissionsScalarWhereInput[]
    id?: StringFilter<"permissions"> | string
    name?: StringFilter<"permissions"> | string
    code?: StringFilter<"permissions"> | string
    description?: StringNullableFilter<"permissions"> | string | null
    categoryId?: StringFilter<"permissions"> | string
  }

  export type permission_audit_logsCreateWithoutPermissionsInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    admin: adminCreateNestedOneWithoutPermission_audit_logsInput
    roles?: rolesCreateNestedOneWithoutPermission_audit_logsInput
  }

  export type permission_audit_logsUncheckedCreateWithoutPermissionsInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    adminId: string
    roleId?: string | null
  }

  export type permission_audit_logsCreateOrConnectWithoutPermissionsInput = {
    where: permission_audit_logsWhereUniqueInput
    create: XOR<permission_audit_logsCreateWithoutPermissionsInput, permission_audit_logsUncheckedCreateWithoutPermissionsInput>
  }

  export type permission_audit_logsCreateManyPermissionsInputEnvelope = {
    data: permission_audit_logsCreateManyPermissionsInput | permission_audit_logsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type permission_categoriesCreateWithoutPermissionsInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    displayOrder?: number
  }

  export type permission_categoriesUncheckedCreateWithoutPermissionsInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    displayOrder?: number
  }

  export type permission_categoriesCreateOrConnectWithoutPermissionsInput = {
    where: permission_categoriesWhereUniqueInput
    create: XOR<permission_categoriesCreateWithoutPermissionsInput, permission_categoriesUncheckedCreateWithoutPermissionsInput>
  }

  export type role_permissionsCreateWithoutPermissionsInput = {
    id: string
    roles: rolesCreateNestedOneWithoutRole_permissionsInput
  }

  export type role_permissionsUncheckedCreateWithoutPermissionsInput = {
    id: string
    roleId: string
  }

  export type role_permissionsCreateOrConnectWithoutPermissionsInput = {
    where: role_permissionsWhereUniqueInput
    create: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_permissionsCreateManyPermissionsInputEnvelope = {
    data: role_permissionsCreateManyPermissionsInput | role_permissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type permission_audit_logsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: permission_audit_logsWhereUniqueInput
    update: XOR<permission_audit_logsUpdateWithoutPermissionsInput, permission_audit_logsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<permission_audit_logsCreateWithoutPermissionsInput, permission_audit_logsUncheckedCreateWithoutPermissionsInput>
  }

  export type permission_audit_logsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: permission_audit_logsWhereUniqueInput
    data: XOR<permission_audit_logsUpdateWithoutPermissionsInput, permission_audit_logsUncheckedUpdateWithoutPermissionsInput>
  }

  export type permission_audit_logsUpdateManyWithWhereWithoutPermissionsInput = {
    where: permission_audit_logsScalarWhereInput
    data: XOR<permission_audit_logsUpdateManyMutationInput, permission_audit_logsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type permission_categoriesUpsertWithoutPermissionsInput = {
    update: XOR<permission_categoriesUpdateWithoutPermissionsInput, permission_categoriesUncheckedUpdateWithoutPermissionsInput>
    create: XOR<permission_categoriesCreateWithoutPermissionsInput, permission_categoriesUncheckedCreateWithoutPermissionsInput>
    where?: permission_categoriesWhereInput
  }

  export type permission_categoriesUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: permission_categoriesWhereInput
    data: XOR<permission_categoriesUpdateWithoutPermissionsInput, permission_categoriesUncheckedUpdateWithoutPermissionsInput>
  }

  export type permission_categoriesUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type permission_categoriesUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
  }

  export type role_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: role_permissionsWhereUniqueInput
    update: XOR<role_permissionsUpdateWithoutPermissionsInput, role_permissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<role_permissionsCreateWithoutPermissionsInput, role_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: role_permissionsWhereUniqueInput
    data: XOR<role_permissionsUpdateWithoutPermissionsInput, role_permissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type role_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: role_permissionsScalarWhereInput
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type role_permissionsScalarWhereInput = {
    AND?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
    OR?: role_permissionsScalarWhereInput[]
    NOT?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
    id?: StringFilter<"role_permissions"> | string
    roleId?: StringFilter<"role_permissions"> | string
    permissionId?: StringFilter<"role_permissions"> | string
  }

  export type permissionsCreateWithoutRole_permissionsInput = {
    id: string
    name: string
    code: string
    description?: string | null
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutPermissionsInput
    permission_categories: permission_categoriesCreateNestedOneWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateWithoutRole_permissionsInput = {
    id: string
    name: string
    code: string
    description?: string | null
    categoryId: string
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsCreateOrConnectWithoutRole_permissionsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
  }

  export type rolesCreateWithoutRole_permissionsInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutRolesInput
    admin?: adminCreateNestedOneWithoutRolesInput
    user_roles?: user_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutRole_permissionsInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    createdById?: string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutRolesInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutRole_permissionsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
  }

  export type permissionsUpsertWithoutRole_permissionsInput = {
    update: XOR<permissionsUpdateWithoutRole_permissionsInput, permissionsUncheckedUpdateWithoutRole_permissionsInput>
    create: XOR<permissionsCreateWithoutRole_permissionsInput, permissionsUncheckedCreateWithoutRole_permissionsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutRole_permissionsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutRole_permissionsInput, permissionsUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type permissionsUpdateWithoutRole_permissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutPermissionsNestedInput
    permission_categories?: permission_categoriesUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateWithoutRole_permissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type rolesUpsertWithoutRole_permissionsInput = {
    update: XOR<rolesUpdateWithoutRole_permissionsInput, rolesUncheckedUpdateWithoutRole_permissionsInput>
    create: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutRole_permissionsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutRole_permissionsInput, rolesUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type rolesUpdateWithoutRole_permissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutRolesNestedInput
    admin?: adminUpdateOneWithoutRolesNestedInput
    user_roles?: user_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutRole_permissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutRolesNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type permission_audit_logsCreateWithoutRolesInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    admin: adminCreateNestedOneWithoutPermission_audit_logsInput
    permissions?: permissionsCreateNestedOneWithoutPermission_audit_logsInput
  }

  export type permission_audit_logsUncheckedCreateWithoutRolesInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    adminId: string
    permissionId?: string | null
  }

  export type permission_audit_logsCreateOrConnectWithoutRolesInput = {
    where: permission_audit_logsWhereUniqueInput
    create: XOR<permission_audit_logsCreateWithoutRolesInput, permission_audit_logsUncheckedCreateWithoutRolesInput>
  }

  export type permission_audit_logsCreateManyRolesInputEnvelope = {
    data: permission_audit_logsCreateManyRolesInput | permission_audit_logsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type role_permissionsCreateWithoutRolesInput = {
    id: string
    permissions: permissionsCreateNestedOneWithoutRole_permissionsInput
  }

  export type role_permissionsUncheckedCreateWithoutRolesInput = {
    id: string
    permissionId: string
  }

  export type role_permissionsCreateOrConnectWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    create: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_permissionsCreateManyRolesInputEnvelope = {
    data: role_permissionsCreateManyRolesInput | role_permissionsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type adminCreateWithoutRolesInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminUncheckedCreateWithoutRolesInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminCreateOrConnectWithoutRolesInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutRolesInput, adminUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesCreateWithoutRolesInput = {
    id: string
    assignedAt?: Date | string
    admin_user_roles_adminIdToadmin: adminCreateNestedOneWithoutUser_roles_user_roles_adminIdToadminInput
    admin_user_roles_assignedByIdToadmin?: adminCreateNestedOneWithoutUser_roles_user_roles_assignedByIdToadminInput
  }

  export type user_rolesUncheckedCreateWithoutRolesInput = {
    id: string
    assignedAt?: Date | string
    adminId: string
    assignedById?: string | null
  }

  export type user_rolesCreateOrConnectWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesCreateManyRolesInputEnvelope = {
    data: user_rolesCreateManyRolesInput | user_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type permission_audit_logsUpsertWithWhereUniqueWithoutRolesInput = {
    where: permission_audit_logsWhereUniqueInput
    update: XOR<permission_audit_logsUpdateWithoutRolesInput, permission_audit_logsUncheckedUpdateWithoutRolesInput>
    create: XOR<permission_audit_logsCreateWithoutRolesInput, permission_audit_logsUncheckedCreateWithoutRolesInput>
  }

  export type permission_audit_logsUpdateWithWhereUniqueWithoutRolesInput = {
    where: permission_audit_logsWhereUniqueInput
    data: XOR<permission_audit_logsUpdateWithoutRolesInput, permission_audit_logsUncheckedUpdateWithoutRolesInput>
  }

  export type permission_audit_logsUpdateManyWithWhereWithoutRolesInput = {
    where: permission_audit_logsScalarWhereInput
    data: XOR<permission_audit_logsUpdateManyMutationInput, permission_audit_logsUncheckedUpdateManyWithoutRolesInput>
  }

  export type role_permissionsUpsertWithWhereUniqueWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    update: XOR<role_permissionsUpdateWithoutRolesInput, role_permissionsUncheckedUpdateWithoutRolesInput>
    create: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_permissionsUpdateWithWhereUniqueWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    data: XOR<role_permissionsUpdateWithoutRolesInput, role_permissionsUncheckedUpdateWithoutRolesInput>
  }

  export type role_permissionsUpdateManyWithWhereWithoutRolesInput = {
    where: role_permissionsScalarWhereInput
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyWithoutRolesInput>
  }

  export type adminUpsertWithoutRolesInput = {
    update: XOR<adminUpdateWithoutRolesInput, adminUncheckedUpdateWithoutRolesInput>
    create: XOR<adminCreateWithoutRolesInput, adminUncheckedCreateWithoutRolesInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutRolesInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutRolesInput, adminUncheckedUpdateWithoutRolesInput>
  }

  export type adminUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type adminUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type user_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type adminCreateWithoutUser_roles_user_roles_adminIdToadminInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutAdminInput
    roles?: rolesCreateNestedManyWithoutAdminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminUncheckedCreateWithoutUser_roles_user_roles_adminIdToadminInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutAdminInput
    roles?: rolesUncheckedCreateNestedManyWithoutAdminInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_assignedByIdToadminInput
  }

  export type adminCreateOrConnectWithoutUser_roles_user_roles_adminIdToadminInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUser_roles_user_roles_adminIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_adminIdToadminInput>
  }

  export type adminCreateWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutAdminInput
    roles?: rolesCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
  }

  export type adminUncheckedCreateWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    lastLogin?: Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutAdminInput
    roles?: rolesUncheckedCreateNestedManyWithoutAdminInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedCreateNestedManyWithoutAdmin_user_roles_adminIdToadminInput
  }

  export type adminCreateOrConnectWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUser_roles_user_roles_assignedByIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_assignedByIdToadminInput>
  }

  export type rolesCreateWithoutUser_rolesInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    permission_audit_logs?: permission_audit_logsCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
    admin?: adminCreateNestedOneWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutUser_rolesInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    createdById?: string | null
    permission_audit_logs?: permission_audit_logsUncheckedCreateNestedManyWithoutRolesInput
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutUser_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
  }

  export type adminUpsertWithoutUser_roles_user_roles_adminIdToadminInput = {
    update: XOR<adminUpdateWithoutUser_roles_user_roles_adminIdToadminInput, adminUncheckedUpdateWithoutUser_roles_user_roles_adminIdToadminInput>
    create: XOR<adminCreateWithoutUser_roles_user_roles_adminIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_adminIdToadminInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutUser_roles_user_roles_adminIdToadminInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutUser_roles_user_roles_adminIdToadminInput, adminUncheckedUpdateWithoutUser_roles_user_roles_adminIdToadminInput>
  }

  export type adminUpdateWithoutUser_roles_user_roles_adminIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutAdminNestedInput
    roles?: rolesUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type adminUncheckedUpdateWithoutUser_roles_user_roles_adminIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutAdminNestedInput
    roles?: rolesUncheckedUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_assignedByIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_assignedByIdToadminNestedInput
  }

  export type adminUpsertWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    update: XOR<adminUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput, adminUncheckedUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput>
    create: XOR<adminCreateWithoutUser_roles_user_roles_assignedByIdToadminInput, adminUncheckedCreateWithoutUser_roles_user_roles_assignedByIdToadminInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput, adminUncheckedUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput>
  }

  export type adminUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutAdminNestedInput
    roles?: rolesUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
  }

  export type adminUncheckedUpdateWithoutUser_roles_user_roles_assignedByIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutAdminNestedInput
    roles?: rolesUncheckedUpdateManyWithoutAdminNestedInput
    user_roles_user_roles_adminIdToadmin?: user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_adminIdToadminNestedInput
  }

  export type rolesUpsertWithoutUser_rolesInput = {
    update: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type rolesUpdateWithoutUser_rolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
    admin?: adminUpdateOneWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutUser_rolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type FareNegotiationCreateManyBookingsInput = {
    Id?: number
    DriverId: number
    OwnerId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type FareNegotiationUpdateWithoutBookingsInput = {
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Driver?: DriverUpdateOneRequiredWithoutFareNegotiationNestedInput
    Owner?: OwnerUpdateOneRequiredWithoutFareNegotiationNestedInput
  }

  export type FareNegotiationUncheckedUpdateWithoutBookingsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareNegotiationUncheckedUpdateManyWithoutBookingsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingsCreateManyDriverInput = {
    Id?: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    Fare: string
    VehicleId?: number | null
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
  }

  export type DriverVehicleCreateManyDriverInput = {
    Id?: number
    VehicleId: number
  }

  export type FareNegotiationCreateManyDriverInput = {
    Id?: number
    BookingId: number
    OwnerId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type OwnerDriverCreateManyDriverInput = {
    Id?: number
    OwnerId: number
  }

  export type BookingsUpdateWithoutDriverInput = {
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutBookingsNestedInput
    Vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    VehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateManyWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    VehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleUpdateWithoutDriverInput = {
    Vehicle?: VehicleUpdateOneRequiredWithoutDriverVehicleNestedInput
  }

  export type DriverVehicleUncheckedUpdateWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type DriverVehicleUncheckedUpdateManyWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type FareNegotiationUpdateWithoutDriverInput = {
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookings?: BookingsUpdateOneRequiredWithoutFareNegotiationNestedInput
    Owner?: OwnerUpdateOneRequiredWithoutFareNegotiationNestedInput
  }

  export type FareNegotiationUncheckedUpdateWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    BookingId?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareNegotiationUncheckedUpdateManyWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    BookingId?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDriverUpdateWithoutDriverInput = {
    Owner?: OwnerUpdateOneRequiredWithoutOwnerDriverNestedInput
  }

  export type OwnerDriverUncheckedUpdateWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerDriverUncheckedUpdateManyWithoutDriverInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
  }

  export type FareNegotiationCreateManyOwnerInput = {
    Id?: number
    BookingId: number
    DriverId: number
    NegotiatedFare: string
    NegotiatedTime?: Date | string
  }

  export type OwnerDriverCreateManyOwnerInput = {
    Id?: number
    DriverId: number
  }

  export type OwnerVehicleCreateManyOwnerInput = {
    Id?: number
    VehicleId: number
  }

  export type FareNegotiationUpdateWithoutOwnerInput = {
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookings?: BookingsUpdateOneRequiredWithoutFareNegotiationNestedInput
    Driver?: DriverUpdateOneRequiredWithoutFareNegotiationNestedInput
  }

  export type FareNegotiationUncheckedUpdateWithoutOwnerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    BookingId?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareNegotiationUncheckedUpdateManyWithoutOwnerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    BookingId?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
    NegotiatedFare?: StringFieldUpdateOperationsInput | string
    NegotiatedTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDriverUpdateWithoutOwnerInput = {
    Driver?: DriverUpdateOneRequiredWithoutOwnerDriverNestedInput
  }

  export type OwnerDriverUncheckedUpdateWithoutOwnerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerDriverUncheckedUpdateManyWithoutOwnerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerVehicleUpdateWithoutOwnerInput = {
    Vehicle?: VehicleUpdateOneRequiredWithoutOwnerVehicleNestedInput
  }

  export type OwnerVehicleUncheckedUpdateWithoutOwnerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerVehicleUncheckedUpdateManyWithoutOwnerInput = {
    Id?: IntFieldUpdateOperationsInput | number
    VehicleId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingsCreateManyUserInput = {
    Id?: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    DriverId?: number | null
    Fare: string
    VehicleId?: number | null
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
  }

  export type BookingsUpdateWithoutUserInput = {
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Driver?: DriverUpdateOneWithoutBookingsNestedInput
    Vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverId?: NullableIntFieldUpdateOperationsInput | number | null
    Fare?: StringFieldUpdateOperationsInput | string
    VehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateManyWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverId?: NullableIntFieldUpdateOperationsInput | number | null
    Fare?: StringFieldUpdateOperationsInput | string
    VehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingsCreateManyVehicleInput = {
    Id?: number
    UserId: number
    PickUpLocation: string
    DropLocation: string
    Product: string
    Distance: string
    Status: $Enums.BookingStatus
    PaymentMode: $Enums.PaymentMode
    BookingTime?: Date | string
    DriverId?: number | null
    Fare: string
    StartTime: Date | string
    CreatedDateTime?: Date | string
    UpdatedDateTime?: Date | string
  }

  export type DriverVehicleCreateManyVehicleInput = {
    Id?: number
    DriverId: number
  }

  export type OwnerVehicleCreateManyVehicleInput = {
    Id?: number
    OwnerId: number
  }

  export type BookingsUpdateWithoutVehicleInput = {
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Driver?: DriverUpdateOneWithoutBookingsNestedInput
    User?: UserUpdateOneRequiredWithoutBookingsNestedInput
    FareNegotiation?: FareNegotiationUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateWithoutVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverId?: NullableIntFieldUpdateOperationsInput | number | null
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FareNegotiation?: FareNegotiationUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateManyWithoutVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    PickUpLocation?: StringFieldUpdateOperationsInput | string
    DropLocation?: StringFieldUpdateOperationsInput | string
    Product?: StringFieldUpdateOperationsInput | string
    Distance?: StringFieldUpdateOperationsInput | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    PaymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    BookingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DriverId?: NullableIntFieldUpdateOperationsInput | number | null
    Fare?: StringFieldUpdateOperationsInput | string
    StartTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleUpdateWithoutVehicleInput = {
    Driver?: DriverUpdateOneRequiredWithoutDriverVehicleNestedInput
  }

  export type DriverVehicleUncheckedUpdateWithoutVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
  }

  export type DriverVehicleUncheckedUpdateManyWithoutVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DriverId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerVehicleUpdateWithoutVehicleInput = {
    Owner?: OwnerUpdateOneRequiredWithoutOwnerVehicleNestedInput
  }

  export type OwnerVehicleUncheckedUpdateWithoutVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
  }

  export type OwnerVehicleUncheckedUpdateManyWithoutVehicleInput = {
    Id?: IntFieldUpdateOperationsInput | number
    OwnerId?: IntFieldUpdateOperationsInput | number
  }

  export type permission_audit_logsCreateManyAdminInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    roleId?: string | null
    permissionId?: string | null
  }

  export type rolesCreateManyAdminInput = {
    id: string
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_rolesCreateManyAdmin_user_roles_adminIdToadminInput = {
    id: string
    assignedAt?: Date | string
    roleId: string
    assignedById?: string | null
  }

  export type user_rolesCreateManyAdmin_user_roles_assignedByIdToadminInput = {
    id: string
    assignedAt?: Date | string
    adminId: string
    roleId: string
  }

  export type permission_audit_logsUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: permissionsUpdateOneWithoutPermission_audit_logsNestedInput
    roles?: rolesUpdateOneWithoutPermission_audit_logsNestedInput
  }

  export type permission_audit_logsUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permission_audit_logsUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
    user_roles?: user_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutRolesNestedInput
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesUpdateWithoutAdmin_user_roles_adminIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_user_roles_assignedByIdToadmin?: adminUpdateOneWithoutUser_roles_user_roles_assignedByIdToadminNestedInput
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutAdmin_user_roles_adminIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_adminIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_rolesUpdateWithoutAdmin_user_roles_assignedByIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_user_roles_adminIdToadmin?: adminUpdateOneRequiredWithoutUser_roles_user_roles_adminIdToadminNestedInput
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutAdmin_user_roles_assignedByIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type user_rolesUncheckedUpdateManyWithoutAdmin_user_roles_assignedByIdToadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type permissionsCreateManyPermission_categoriesInput = {
    id: string
    name: string
    code: string
    description?: string | null
  }

  export type permissionsUpdateWithoutPermission_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audit_logs?: permission_audit_logsUpdateManyWithoutPermissionsNestedInput
    role_permissions?: role_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateWithoutPermission_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permission_audit_logs?: permission_audit_logsUncheckedUpdateManyWithoutPermissionsNestedInput
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateManyWithoutPermission_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permission_audit_logsCreateManyPermissionsInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    adminId: string
    roleId?: string | null
  }

  export type role_permissionsCreateManyPermissionsInput = {
    id: string
    roleId: string
  }

  export type permission_audit_logsUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutPermission_audit_logsNestedInput
    roles?: rolesUpdateOneWithoutPermission_audit_logsNestedInput
  }

  export type permission_audit_logsUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permission_audit_logsUncheckedUpdateManyWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_permissionsUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roles?: rolesUpdateOneRequiredWithoutRole_permissionsNestedInput
  }

  export type role_permissionsUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type role_permissionsUncheckedUpdateManyWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type permission_audit_logsCreateManyRolesInput = {
    id: string
    actionType: $Enums.AuditActionType
    details?: string | null
    actionTimestamp?: Date | string
    adminId: string
    permissionId?: string | null
  }

  export type role_permissionsCreateManyRolesInput = {
    id: string
    permissionId: string
  }

  export type user_rolesCreateManyRolesInput = {
    id: string
    assignedAt?: Date | string
    adminId: string
    assignedById?: string | null
  }

  export type permission_audit_logsUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutPermission_audit_logsNestedInput
    permissions?: permissionsUpdateOneWithoutPermission_audit_logsNestedInput
  }

  export type permission_audit_logsUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    permissionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permission_audit_logsUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumAuditActionTypeFieldUpdateOperationsInput | $Enums.AuditActionType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    actionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    permissionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type role_permissionsUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: permissionsUpdateOneRequiredWithoutRole_permissionsNestedInput
  }

  export type role_permissionsUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type role_permissionsUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type user_rolesUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_user_roles_adminIdToadmin?: adminUpdateOneRequiredWithoutUser_roles_user_roles_adminIdToadminNestedInput
    admin_user_roles_assignedByIdToadmin?: adminUpdateOneWithoutUser_roles_user_roles_assignedByIdToadminNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}